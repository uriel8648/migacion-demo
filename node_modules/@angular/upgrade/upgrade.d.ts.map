{"version":3,"file":"upgrade.d.ts","sources":["upgrade.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v12.2.17\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { CompilerOptions } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { NgModuleRef } from '@angular/core';\r\nimport { Type } from '@angular/core';\r\nimport { Version } from '@angular/core';\r\n\r\ndeclare interface IAngularBootstrapConfig {\r\n    strictDi?: boolean;\r\n}\r\n\r\ndeclare interface IInjectorService {\r\n    get(key: string): any;\r\n    has(key: string): boolean;\r\n}\r\n\r\ndeclare interface IRootScopeService {\r\n    $new(isolate?: boolean): IScope;\r\n    $id: string;\r\n    $parent: IScope;\r\n    $root: IScope;\r\n    $watch(exp: Ng1Expression, fn?: (a1?: any, a2?: any) => void): Function;\r\n    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\r\n    $destroy(): any;\r\n    $apply(exp?: Ng1Expression): any;\r\n    $digest(): any;\r\n    $evalAsync(exp: Ng1Expression, locals?: any): void;\r\n    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\r\n    $$childTail: IScope;\r\n    $$childHead: IScope;\r\n    $$nextSibling: IScope;\r\n    [key: string]: any;\r\n}\r\n\r\ndeclare interface IScope extends IRootScopeService {\r\n}\r\n\r\ndeclare type Ng1Expression = string | Function;\r\n\r\n/**\r\n * Use `UpgradeAdapter` to allow AngularJS and Angular to coexist in a single application.\r\n *\r\n * The `UpgradeAdapter` allows:\r\n * 1. creation of Angular component from AngularJS component directive\r\n *    (See [UpgradeAdapter#upgradeNg1Component()])\r\n * 2. creation of AngularJS directive from Angular component.\r\n *    (See [UpgradeAdapter#downgradeNg2Component()])\r\n * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\r\n *    coexisting in a single application.\r\n *\r\n * @usageNotes\r\n * ### Mental Model\r\n *\r\n * When reasoning about how a hybrid application works it is useful to have a mental model which\r\n * describes what is happening and explains what is happening at the lowest level.\r\n *\r\n * 1. There are two independent frameworks running in a single application, each framework treats\r\n *    the other as a black box.\r\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\r\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\r\n *    DOM elements and ignores others.\r\n * 3. AngularJS directives always execute inside AngularJS framework codebase regardless of\r\n *    where they are instantiated.\r\n * 4. Angular components always execute inside Angular framework codebase regardless of\r\n *    where they are instantiated.\r\n * 5. An AngularJS component can be upgraded to an Angular component. This creates an\r\n *    Angular directive, which bootstraps the AngularJS component directive in that location.\r\n * 6. An Angular component can be downgraded to an AngularJS component directive. This creates\r\n *    an AngularJS directive, which bootstraps the Angular component in that location.\r\n * 7. Whenever an adapter component is instantiated the host element is owned by the framework\r\n *    doing the instantiation. The other framework then instantiates and owns the view for that\r\n *    component. This implies that component bindings will always follow the semantics of the\r\n *    instantiation framework. The syntax is always that of Angular syntax.\r\n * 8. AngularJS is always bootstrapped first and owns the bottom most view.\r\n * 9. The new application is running in Angular zone, and therefore it no longer needs calls to\r\n *    `$apply()`.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * const adapter = new UpgradeAdapter(forwardRef(() => MyNg2Module), myCompilerOptions);\r\n * const module = angular.module('myExample', []);\r\n * module.directive('ng2Comp', adapter.downgradeNg2Component(Ng2Component));\r\n *\r\n * module.directive('ng1Hello', function() {\r\n *   return {\r\n *      scope: { title: '=' },\r\n *      template: 'ng1[Hello {{title}}!](<span ng-transclude></span>)'\r\n *   };\r\n * });\r\n *\r\n *\r\n * @Component({\r\n *   selector: 'ng2-comp',\r\n *   inputs: ['name'],\r\n *   template: 'ng2[<ng1-hello [title]=\"name\">transclude</ng1-hello>](<ng-content></ng-content>)',\r\n *   directives:\r\n * })\r\n * class Ng2Component {\r\n * }\r\n *\r\n * @NgModule({\r\n *   declarations: [Ng2Component, adapter.upgradeNg1Component('ng1Hello')],\r\n *   imports: [BrowserModule]\r\n * })\r\n * class MyNg2Module {}\r\n *\r\n *\r\n * document.body.innerHTML = '<ng2-comp name=\"World\">project</ng2-comp>';\r\n *\r\n * adapter.bootstrap(document.body, ['myExample']).ready(function() {\r\n *   expect(document.body.textContent).toEqual(\r\n *       \"ng2[ng1[Hello World!](transclude)](project)\");\r\n * });\r\n *\r\n * ```\r\n *\r\n * @deprecated Deprecated since v5. Use `upgrade/static` instead, which also supports\r\n * [Ahead-of-Time compilation](guide/aot-compiler).\r\n * @publicApi\r\n */\r\nexport declare class UpgradeAdapter {\r\n    private ng2AppModule;\r\n    private compilerOptions?;\r\n    private idPrefix;\r\n    private downgradedComponents;\r\n    private upgradedProviders;\r\n    private ngZone;\r\n    private ng1Module;\r\n    private moduleRef;\r\n    private ng2BootstrapDeferred;\r\n    constructor(ng2AppModule: Type<any>, compilerOptions?: CompilerOptions | undefined);\r\n    /**\r\n     * Allows Angular Component to be used from AngularJS.\r\n     *\r\n     * Use `downgradeNg2Component` to create an AngularJS Directive Definition Factory from\r\n     * Angular Component. The adapter will bootstrap Angular component from within the\r\n     * AngularJS template.\r\n     *\r\n     * @usageNotes\r\n     * ### Mental Model\r\n     *\r\n     * 1. The component is instantiated by being listed in AngularJS template. This means that the\r\n     *    host element is controlled by AngularJS, but the component's view will be controlled by\r\n     *    Angular.\r\n     * 2. Even thought the component is instantiated in AngularJS, it will be using Angular\r\n     *    syntax. This has to be done, this way because we must follow Angular components do not\r\n     *    declare how the attributes should be interpreted.\r\n     * 3. `ng-model` is controlled by AngularJS and communicates with the downgraded Angular component\r\n     *    by way of the `ControlValueAccessor` interface from @angular/forms. Only components that\r\n     *    implement this interface are eligible.\r\n     *\r\n     * ### Supported Features\r\n     *\r\n     * - Bindings:\r\n     *   - Attribute: `<comp name=\"World\">`\r\n     *   - Interpolation:  `<comp greeting=\"Hello {{name}}!\">`\r\n     *   - Expression:  `<comp [name]=\"username\">`\r\n     *   - Event:  `<comp (close)=\"doSomething()\">`\r\n     *   - ng-model: `<comp ng-model=\"name\">`\r\n     * - Content projection: yes\r\n     *\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * const adapter = new UpgradeAdapter(forwardRef(() => MyNg2Module));\r\n     * const module = angular.module('myExample', []);\r\n     * module.directive('greet', adapter.downgradeNg2Component(Greeter));\r\n     *\r\n     * @Component({\r\n     *   selector: 'greet',\r\n     *   template: '{{salutation}} {{name}}! - <ng-content></ng-content>'\r\n     * })\r\n     * class Greeter {\r\n     *   @Input() salutation: string;\r\n     *   @Input() name: string;\r\n     * }\r\n     *\r\n     * @NgModule({\r\n     *   declarations: [Greeter],\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyNg2Module {}\r\n     *\r\n     * document.body.innerHTML =\r\n     *   'ng1 template: <greet salutation=\"Hello\" [name]=\"world\">text</greet>';\r\n     *\r\n     * adapter.bootstrap(document.body, ['myExample']).ready(function() {\r\n     *   expect(document.body.textContent).toEqual(\"ng1 template: Hello world! - text\");\r\n     * });\r\n     * ```\r\n     */\r\n    downgradeNg2Component(component: Type<any>): Function;\r\n    /**\r\n     * Allows AngularJS Component to be used from Angular.\r\n     *\r\n     * Use `upgradeNg1Component` to create an Angular component from AngularJS Component\r\n     * directive. The adapter will bootstrap AngularJS component from within the Angular\r\n     * template.\r\n     *\r\n     * @usageNotes\r\n     * ### Mental Model\r\n     *\r\n     * 1. The component is instantiated by being listed in Angular template. This means that the\r\n     *    host element is controlled by Angular, but the component's view will be controlled by\r\n     *    AngularJS.\r\n     *\r\n     * ### Supported Features\r\n     *\r\n     * - Bindings:\r\n     *   - Attribute: `<comp name=\"World\">`\r\n     *   - Interpolation:  `<comp greeting=\"Hello {{name}}!\">`\r\n     *   - Expression:  `<comp [name]=\"username\">`\r\n     *   - Event:  `<comp (close)=\"doSomething()\">`\r\n     * - Transclusion: yes\r\n     * - Only some of the features of\r\n     *   [Directive Definition Object](https://docs.angularjs.org/api/ng/service/$compile) are\r\n     *   supported:\r\n     *   - `compile`: not supported because the host element is owned by Angular, which does\r\n     *     not allow modifying DOM structure during compilation.\r\n     *   - `controller`: supported. (NOTE: injection of `$attrs` and `$transclude` is not supported.)\r\n     *   - `controllerAs`: supported.\r\n     *   - `bindToController`: supported.\r\n     *   - `link`: supported. (NOTE: only pre-link function is supported.)\r\n     *   - `name`: supported.\r\n     *   - `priority`: ignored.\r\n     *   - `replace`: not supported.\r\n     *   - `require`: supported.\r\n     *   - `restrict`: must be set to 'E'.\r\n     *   - `scope`: supported.\r\n     *   - `template`: supported.\r\n     *   - `templateUrl`: supported.\r\n     *   - `terminal`: ignored.\r\n     *   - `transclude`: supported.\r\n     *\r\n     *\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * const adapter = new UpgradeAdapter(forwardRef(() => MyNg2Module));\r\n     * const module = angular.module('myExample', []);\r\n     *\r\n     * module.directive('greet', function() {\r\n     *   return {\r\n     *     scope: {salutation: '=', name: '=' },\r\n     *     template: '{{salutation}} {{name}}! - <span ng-transclude></span>'\r\n     *   };\r\n     * });\r\n     *\r\n     * module.directive('ng2', adapter.downgradeNg2Component(Ng2Component));\r\n     *\r\n     * @Component({\r\n     *   selector: 'ng2',\r\n     *   template: 'ng2 template: <greet salutation=\"Hello\" [name]=\"world\">text</greet>'\r\n     * })\r\n     * class Ng2Component {\r\n     * }\r\n     *\r\n     * @NgModule({\r\n     *   declarations: [Ng2Component, adapter.upgradeNg1Component('greet')],\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyNg2Module {}\r\n     *\r\n     * document.body.innerHTML = '<ng2></ng2>';\r\n     *\r\n     * adapter.bootstrap(document.body, ['myExample']).ready(function() {\r\n     *   expect(document.body.textContent).toEqual(\"ng2 template: Hello world! - text\");\r\n     * });\r\n     * ```\r\n     */\r\n    upgradeNg1Component(name: string): Type<any>;\r\n    /**\r\n     * Registers the adapter's AngularJS upgrade module for unit testing in AngularJS.\r\n     * Use this instead of `angular.mock.module()` to load the upgrade module into\r\n     * the AngularJS testing injector.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * const upgradeAdapter = new UpgradeAdapter(MyNg2Module);\r\n     *\r\n     * // configure the adapter with upgrade/downgrade components and services\r\n     * upgradeAdapter.downgradeNg2Component(MyComponent);\r\n     *\r\n     * let upgradeAdapterRef: UpgradeAdapterRef;\r\n     * let $compile, $rootScope;\r\n     *\r\n     * // We must register the adapter before any calls to `inject()`\r\n     * beforeEach(() => {\r\n     *   upgradeAdapterRef = upgradeAdapter.registerForNg1Tests(['heroApp']);\r\n     * });\r\n     *\r\n     * beforeEach(inject((_$compile_, _$rootScope_) => {\r\n     *   $compile = _$compile_;\r\n     *   $rootScope = _$rootScope_;\r\n     * }));\r\n     *\r\n     * it(\"says hello\", (done) => {\r\n     *   upgradeAdapterRef.ready(() => {\r\n     *     const element = $compile(\"<my-component></my-component>\")($rootScope);\r\n     *     $rootScope.$apply();\r\n     *     expect(element.html()).toContain(\"Hello World\");\r\n     *     done();\r\n     *   })\r\n     * });\r\n     *\r\n     * ```\r\n     *\r\n     * @param modules any AngularJS modules that the upgrade module should depend upon\r\n     * @returns an `UpgradeAdapterRef`, which lets you register a `ready()` callback to\r\n     * run assertions once the Angular components are ready to test through AngularJS.\r\n     */\r\n    registerForNg1Tests(modules?: string[]): UpgradeAdapterRef;\r\n    /**\r\n     * Bootstrap a hybrid AngularJS / Angular application.\r\n     *\r\n     * This `bootstrap` method is a direct replacement (takes same arguments) for AngularJS\r\n     * [`bootstrap`](https://docs.angularjs.org/api/ng/function/angular.bootstrap) method. Unlike\r\n     * AngularJS, this bootstrap is asynchronous.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * const adapter = new UpgradeAdapter(MyNg2Module);\r\n     * const module = angular.module('myExample', []);\r\n     * module.directive('ng2', adapter.downgradeNg2Component(Ng2));\r\n     *\r\n     * module.directive('ng1', function() {\r\n     *   return {\r\n     *      scope: { title: '=' },\r\n     *      template: 'ng1[Hello {{title}}!](<span ng-transclude></span>)'\r\n     *   };\r\n     * });\r\n     *\r\n     *\r\n     * @Component({\r\n     *   selector: 'ng2',\r\n     *   inputs: ['name'],\r\n     *   template: 'ng2[<ng1 [title]=\"name\">transclude</ng1>](<ng-content></ng-content>)'\r\n     * })\r\n     * class Ng2 {\r\n     * }\r\n     *\r\n     * @NgModule({\r\n     *   declarations: [Ng2, adapter.upgradeNg1Component('ng1')],\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyNg2Module {}\r\n     *\r\n     * document.body.innerHTML = '<ng2 name=\"World\">project</ng2>';\r\n     *\r\n     * adapter.bootstrap(document.body, ['myExample']).ready(function() {\r\n     *   expect(document.body.textContent).toEqual(\r\n     *       \"ng2[ng1[Hello World!](transclude)](project)\");\r\n     * });\r\n     * ```\r\n     */\r\n    bootstrap(element: Element, modules?: any[], config?: IAngularBootstrapConfig): UpgradeAdapterRef;\r\n    /**\r\n     * Allows AngularJS service to be accessible from Angular.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * class Login { ... }\r\n     * class Server { ... }\r\n     *\r\n     * @Injectable()\r\n     * class Example {\r\n     *   constructor(@Inject('server') server, login: Login) {\r\n     *     ...\r\n     *   }\r\n     * }\r\n     *\r\n     * const module = angular.module('myExample', []);\r\n     * module.service('server', Server);\r\n     * module.service('login', Login);\r\n     *\r\n     * const adapter = new UpgradeAdapter(MyNg2Module);\r\n     * adapter.upgradeNg1Provider('server');\r\n     * adapter.upgradeNg1Provider('login', {asToken: Login});\r\n     *\r\n     * adapter.bootstrap(document.body, ['myExample']).ready((ref) => {\r\n     *   const example: Example = ref.ng2Injector.get(Example);\r\n     * });\r\n     *\r\n     * ```\r\n     */\r\n    upgradeNg1Provider(name: string, options?: {\r\n        asToken: any;\r\n    }): void;\r\n    /**\r\n     * Allows Angular service to be accessible from AngularJS.\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * class Example {\r\n     * }\r\n     *\r\n     * const adapter = new UpgradeAdapter(MyNg2Module);\r\n     *\r\n     * const module = angular.module('myExample', []);\r\n     * module.factory('example', adapter.downgradeNg2Provider(Example));\r\n     *\r\n     * adapter.bootstrap(document.body, ['myExample']).ready((ref) => {\r\n     *   const example: Example = ref.ng1Injector.get('example');\r\n     * });\r\n     *\r\n     * ```\r\n     */\r\n    downgradeNg2Provider(token: any): Function;\r\n    /**\r\n     * Declare the AngularJS upgrade module for this adapter without bootstrapping the whole\r\n     * hybrid application.\r\n     *\r\n     * This method is automatically called by `bootstrap()` and `registerForNg1Tests()`.\r\n     *\r\n     * @param modules The AngularJS modules that this upgrade module should depend upon.\r\n     * @returns The AngularJS upgrade module that is declared by this method\r\n     *\r\n     * @usageNotes\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * const upgradeAdapter = new UpgradeAdapter(MyNg2Module);\r\n     * upgradeAdapter.declareNg1Module(['heroApp']);\r\n     * ```\r\n     */\r\n    private declareNg1Module;\r\n}\r\n\r\n/**\r\n * Use `UpgradeAdapterRef` to control a hybrid AngularJS / Angular application.\r\n *\r\n * @deprecated Deprecated since v5. Use `upgrade/static` instead, which also supports\r\n * [Ahead-of-Time compilation](guide/aot-compiler).\r\n * @publicApi\r\n */\r\nexport declare class UpgradeAdapterRef {\r\n    ng1RootScope: IRootScopeService;\r\n    ng1Injector: IInjectorService;\r\n    ng2ModuleRef: NgModuleRef<any>;\r\n    ng2Injector: Injector;\r\n    /**\r\n     * Register a callback function which is notified upon successful hybrid AngularJS / Angular\r\n     * application has been bootstrapped.\r\n     *\r\n     * The `ready` callback function is invoked inside the Angular zone, therefore it does not\r\n     * require a call to `$apply()`.\r\n     */\r\n    ready(fn: (upgradeAdapterRef: UpgradeAdapterRef) => void): void;\r\n    /**\r\n     * Dispose of running hybrid AngularJS / Angular application.\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const VERSION: Version;\r\n\r\nexport { }\r\n"]}