{"version":3,"file":"testing.d.ts","sources":["testing.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v12.2.17\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { Type } from '@angular/core';\r\n\r\ndeclare let angular: {\r\n    bootstrap: (e: Element, modules: (string | IInjectable)[], config?: IAngularBootstrapConfig) => IInjectorService;\r\n    module: (prefix: string, dependencies?: string[]) => IModule;\r\n    element: {\r\n        (e: string | Element | Document | IAugmentedJQuery): IAugmentedJQuery;\r\n        cleanData: (nodes: Node[] | NodeList) => void;\r\n    };\r\n    injector: (modules: Array<string | IInjectable>, strictDi?: boolean) => IInjectorService;\r\n    version: {\r\n        major: number;\r\n    };\r\n    resumeBootstrap: () => void;\r\n    getTestability: (e: Element) => ITestabilityService;\r\n};\r\n\r\n\r\n/**\r\n * A helper function to use when unit testing AngularJS services that depend upon downgraded Angular\r\n * services.\r\n *\r\n * This function returns an AngularJS module that is configured to wire up the AngularJS and Angular\r\n * injectors without the need to actually bootstrap a hybrid application.\r\n * This makes it simpler and faster to unit test services.\r\n *\r\n * Use the returned AngularJS module in a call to\r\n * [`angular.mocks.module`](https://docs.angularjs.org/api/ngMock/function/angular.mock.module) to\r\n * include this module in the unit test injector.\r\n *\r\n * In the following code snippet, we are configuring the `$injector` with two modules:\r\n * The AngularJS `ng1AppModule`, which is the AngularJS part of our hybrid application and the\r\n * `Ng2AppModule`, which is the Angular part.\r\n *\r\n * <code-example path=\"upgrade/static/ts/full/module.spec.ts\"\r\n * region=\"angularjs-setup\"></code-example>\r\n *\r\n * Once this is done we can get hold of services via the AngularJS `$injector` as normal.\r\n * Services that are (or have dependencies on) a downgraded Angular service, will be instantiated as\r\n * needed by the Angular root `Injector`.\r\n *\r\n * In the following code snippet, `heroesService` is a downgraded Angular service that we are\r\n * accessing from AngularJS.\r\n *\r\n * <code-example path=\"upgrade/static/ts/full/module.spec.ts\"\r\n * region=\"angularjs-spec\"></code-example>\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n * This helper is for testing services not components.\r\n * For Component testing you must still bootstrap a hybrid app. See `UpgradeModule` or\r\n * `downgradeModule` for more information.\r\n *\r\n * </div>\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n * The resulting configuration does not wire up AngularJS digests to Zone hooks. It is the\r\n * responsibility of the test writer to call `$rootScope.$apply`, as necessary, to trigger\r\n * AngularJS handlers of async events from Angular.\r\n *\r\n * </div>\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n * The helper sets up global variables to hold the shared Angular and AngularJS injectors.\r\n *\r\n * * Only call this helper once per spec.\r\n * * Do not use `createAngularJSTestingModule` in the same spec as `createAngularTestingModule`.\r\n *\r\n * </div>\r\n *\r\n * Here is the example application and its unit tests that use `createAngularTestingModule`\r\n * and `createAngularJSTestingModule`.\r\n *\r\n * <code-tabs>\r\n *  <code-pane header=\"module.spec.ts\" path=\"upgrade/static/ts/full/module.spec.ts\"></code-pane>\r\n *  <code-pane header=\"module.ts\" path=\"upgrade/static/ts/full/module.ts\"></code-pane>\r\n * </code-tabs>\r\n *\r\n *\r\n * @param angularModules a collection of Angular modules to include in the configuration.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function createAngularJSTestingModule(angularModules: any[]): string;\r\n\r\n/**\r\n * A helper function to use when unit testing Angular services that depend upon upgraded AngularJS\r\n * services.\r\n *\r\n * This function returns an `NgModule` decorated class that is configured to wire up the Angular\r\n * and AngularJS injectors without the need to actually bootstrap a hybrid application.\r\n * This makes it simpler and faster to unit test services.\r\n *\r\n * Use the returned class as an \"import\" when configuring the `TestBed`.\r\n *\r\n * In the following code snippet, we are configuring the TestBed with two imports.\r\n * The `Ng2AppModule` is the Angular part of our hybrid application and the `ng1AppModule` is the\r\n * AngularJS part.\r\n *\r\n * <code-example path=\"upgrade/static/ts/full/module.spec.ts\" region=\"angular-setup\"></code-example>\r\n *\r\n * Once this is done we can get hold of services via the Angular `Injector` as normal.\r\n * Services that are (or have dependencies on) an upgraded AngularJS service, will be instantiated\r\n * as needed by the AngularJS `$injector`.\r\n *\r\n * In the following code snippet, `HeroesService` is an Angular service that depends upon an\r\n * AngularJS service, `titleCase`.\r\n *\r\n * <code-example path=\"upgrade/static/ts/full/module.spec.ts\" region=\"angular-spec\"></code-example>\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n * This helper is for testing services not Components.\r\n * For Component testing you must still bootstrap a hybrid app. See `UpgradeModule` or\r\n * `downgradeModule` for more information.\r\n *\r\n * </div>\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n * The resulting configuration does not wire up AngularJS digests to Zone hooks. It is the\r\n * responsibility of the test writer to call `$rootScope.$apply`, as necessary, to trigger\r\n * AngularJS handlers of async events from Angular.\r\n *\r\n * </div>\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n * The helper sets up global variables to hold the shared Angular and AngularJS injectors.\r\n *\r\n * * Only call this helper once per spec.\r\n * * Do not use `createAngularTestingModule` in the same spec as `createAngularJSTestingModule`.\r\n *\r\n * </div>\r\n *\r\n * Here is the example application and its unit tests that use `createAngularTestingModule`\r\n * and `createAngularJSTestingModule`.\r\n *\r\n * <code-tabs>\r\n *  <code-pane header=\"module.spec.ts\" path=\"upgrade/static/ts/full/module.spec.ts\"></code-pane>\r\n *  <code-pane header=\"module.ts\" path=\"upgrade/static/ts/full/module.ts\"></code-pane>\r\n * </code-tabs>\r\n *\r\n *\r\n * @param angularJSModules a collection of the names of AngularJS modules to include in the\r\n * configuration.\r\n * @param [strictDi] whether the AngularJS injector should have `strictDI` enabled.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function createAngularTestingModule(angularJSModules: string[], strictDi?: boolean): Type<any>;\r\n\r\ndeclare type DirectiveRequireProperty = SingleOrListOrMap<string>;\r\n\r\ndeclare type DirectiveTranscludeProperty = boolean | 'element' | {\r\n    [key: string]: string;\r\n};\r\n\r\ndeclare interface IAngularBootstrapConfig {\r\n    strictDi?: boolean;\r\n}\r\n\r\ndeclare interface IAnnotatedFunction extends Function {\r\n    $inject?: Function extends {\r\n        $inject?: string[];\r\n    } ? Ng1Token[] : ReadonlyArray<Ng1Token>;\r\n}\r\n\r\ndeclare type IAugmentedJQuery = Node[] & {\r\n    on?: (name: string, fn: () => void) => void;\r\n    data?: (name: string, value?: any) => any;\r\n    text?: () => string;\r\n    inheritedData?: (name: string, value?: any) => any;\r\n    children?: () => IAugmentedJQuery;\r\n    contents?: () => IAugmentedJQuery;\r\n    parent?: () => IAugmentedJQuery;\r\n    empty?: () => void;\r\n    append?: (content: IAugmentedJQuery | string) => IAugmentedJQuery;\r\n    controller?: (name: string) => any;\r\n    isolateScope?: () => IScope;\r\n    injector?: () => IInjectorService;\r\n    triggerHandler?: (eventTypeOrObject: string | Event, extraParameters?: any[]) => IAugmentedJQuery;\r\n    remove?: () => void;\r\n    removeData?: () => void;\r\n};\r\n\r\ndeclare interface IComponent {\r\n    bindings?: {\r\n        [key: string]: string;\r\n    };\r\n    controller?: string | IInjectable;\r\n    controllerAs?: string;\r\n    require?: DirectiveRequireProperty;\r\n    template?: string | Function;\r\n    templateUrl?: string | Function;\r\n    transclude?: DirectiveTranscludeProperty;\r\n}\r\n\r\ndeclare type IInjectable = (Ng1Token | Function)[] | IAnnotatedFunction;\r\n\r\ndeclare interface IInjectorService {\r\n    get(key: string): any;\r\n    has(key: string): boolean;\r\n}\r\n\r\ndeclare interface IModule {\r\n    name: string;\r\n    requires: (string | IInjectable)[];\r\n    config(fn: IInjectable): IModule;\r\n    directive(selector: string, factory: IInjectable): IModule;\r\n    component(selector: string, component: IComponent): IModule;\r\n    controller(name: string, type: IInjectable): IModule;\r\n    factory(key: Ng1Token, factoryFn: IInjectable): IModule;\r\n    value(key: Ng1Token, value: any): IModule;\r\n    constant(token: Ng1Token, value: any): IModule;\r\n    run(a: IInjectable): IModule;\r\n}\r\n\r\ndeclare interface IRootScopeService {\r\n    $new(isolate?: boolean): IScope;\r\n    $id: string;\r\n    $parent: IScope;\r\n    $root: IScope;\r\n    $watch(exp: Ng1Expression, fn?: (a1?: any, a2?: any) => void): Function;\r\n    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\r\n    $destroy(): any;\r\n    $apply(exp?: Ng1Expression): any;\r\n    $digest(): any;\r\n    $evalAsync(exp: Ng1Expression, locals?: any): void;\r\n    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\r\n    $$childTail: IScope;\r\n    $$childHead: IScope;\r\n    $$nextSibling: IScope;\r\n    [key: string]: any;\r\n}\r\n\r\ndeclare interface IScope extends IRootScopeService {\r\n}\r\n\r\ndeclare interface ITestabilityService {\r\n    findBindings(element: Element, expression: string, opt_exactMatch?: boolean): Element[];\r\n    findModels(element: Element, expression: string, opt_exactMatch?: boolean): Element[];\r\n    getLocation(): string;\r\n    setLocation(url: string): void;\r\n    whenStable(callback: Function): void;\r\n}\r\n\r\ndeclare type Ng1Expression = string | Function;\r\n\r\n\r\ndeclare type Ng1Token = string;\r\n\r\ndeclare type SingleOrListOrMap<T> = T | T[] | {\r\n    [key: string]: T;\r\n};\r\n\r\nexport declare const ɵangular_packages_upgrade_static_testing_testing_a: typeof angular.module;\r\n\r\nexport declare const ɵangular_packages_upgrade_static_testing_testing_b = \"$$angularUpgradeAppType\";\r\n\r\nexport declare const enum ɵangular_packages_upgrade_static_testing_testing_c {\r\n    None = 0,\r\n    Dynamic = 1,\r\n    Static = 2,\r\n    Lite = 3\r\n}\r\n\r\nexport declare const ɵangular_packages_upgrade_static_testing_testing_d = \"$$angularInjector\";\r\n\r\nexport { }\r\n"]}