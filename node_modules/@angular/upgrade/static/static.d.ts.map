{"version":3,"file":"static.d.ts","sources":["static.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v12.2.17\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { DoCheck } from '@angular/core';\r\nimport { ElementRef } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { NgModuleFactory } from '@angular/core';\r\nimport { NgModuleRef } from '@angular/core';\r\nimport { NgZone } from '@angular/core';\r\nimport { OnChanges } from '@angular/core';\r\nimport { OnDestroy } from '@angular/core';\r\nimport { OnInit } from '@angular/core';\r\nimport { PlatformRef } from '@angular/core';\r\nimport { SimpleChanges } from '@angular/core';\r\nimport { StaticProvider } from '@angular/core';\r\nimport { Type } from '@angular/core';\r\nimport { Version } from '@angular/core';\r\n\r\n/**\r\n * @description\r\n *\r\n * A helper function that allows an Angular component to be used from AngularJS.\r\n *\r\n * *Part of the [upgrade/static](api?query=upgrade%2Fstatic)\r\n * library for hybrid upgrade apps that support AOT compilation*\r\n *\r\n * This helper function returns a factory function to be used for registering\r\n * an AngularJS wrapper directive for \"downgrading\" an Angular component.\r\n *\r\n * @usageNotes\r\n * ### Examples\r\n *\r\n * Let's assume that you have an Angular component called `ng2Heroes` that needs\r\n * to be made available in AngularJS templates.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng2-heroes\"}\r\n *\r\n * We must create an AngularJS [directive](https://docs.angularjs.org/guide/directive)\r\n * that will make this Angular component available inside AngularJS templates.\r\n * The `downgradeComponent()` function returns a factory function that we\r\n * can use to define the AngularJS directive that wraps the \"downgraded\" component.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng2-heroes-wrapper\"}\r\n *\r\n * For more details and examples on downgrading Angular components to AngularJS components please\r\n * visit the [Upgrade guide](guide/upgrade#using-angular-components-from-angularjs-code).\r\n *\r\n * @param info contains information about the Component that is being downgraded:\r\n *\r\n * - `component: Type<any>`: The type of the Component that will be downgraded\r\n * - `downgradedModule?: string`: The name of the downgraded module (if any) that the component\r\n *   \"belongs to\", as returned by a call to `downgradeModule()`. It is the module, whose\r\n *   corresponding Angular module will be bootstrapped, when the component needs to be instantiated.\r\n *   <br />\r\n *   (This option is only necessary when using `downgradeModule()` to downgrade more than one\r\n *   Angular module.)\r\n * - `propagateDigest?: boolean`: Whether to perform {@link ChangeDetectorRef#detectChanges\r\n *   change detection} on the component on every\r\n *   [$digest](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest). If set to `false`,\r\n *   change detection will still be performed when any of the component's inputs changes.\r\n *   (Default: true)\r\n *\r\n * @returns a factory function that can be used to register the component in an\r\n * AngularJS module.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function downgradeComponent(info: {\r\n    component: Type<any>;\r\n    downgradedModule?: string;\r\n    propagateDigest?: boolean;\r\n    /** @deprecated since v4. This parameter is no longer used */\r\n    inputs?: string[];\r\n    /** @deprecated since v4. This parameter is no longer used */\r\n    outputs?: string[];\r\n    /** @deprecated since v4. This parameter is no longer used */\r\n    selectors?: string[];\r\n}): any;\r\n\r\n\r\n/**\r\n * @description\r\n *\r\n * A helper function to allow an Angular service to be accessible from AngularJS.\r\n *\r\n * *Part of the [upgrade/static](api?query=upgrade%2Fstatic)\r\n * library for hybrid upgrade apps that support AOT compilation*\r\n *\r\n * This helper function returns a factory function that provides access to the Angular\r\n * service identified by the `token` parameter.\r\n *\r\n * @usageNotes\r\n * ### Examples\r\n *\r\n * First ensure that the service to be downgraded is provided in an `NgModule`\r\n * that will be part of the upgrade application. For example, let's assume we have\r\n * defined `HeroesService`\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng2-heroes-service\"}\r\n *\r\n * and that we have included this in our upgrade app `NgModule`\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng2-module\"}\r\n *\r\n * Now we can register the `downgradeInjectable` factory function for the service\r\n * on an AngularJS module.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"downgrade-ng2-heroes-service\"}\r\n *\r\n * Inside an AngularJS component's controller we can get hold of the\r\n * downgraded service via the name we gave when downgrading.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"example-app\"}\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n *   When using `downgradeModule()`, downgraded injectables will not be available until the Angular\r\n *   module that provides them is instantiated. In order to be safe, you need to ensure that the\r\n *   downgraded injectables are not used anywhere _outside_ the part of the app where it is\r\n *   guaranteed that their module has been instantiated.\r\n *\r\n *   For example, it is _OK_ to use a downgraded service in an upgraded component that is only used\r\n *   from a downgraded Angular component provided by the same Angular module as the injectable, but\r\n *   it is _not OK_ to use it in an AngularJS component that may be used independently of Angular or\r\n *   use it in a downgraded Angular component from a different module.\r\n *\r\n * </div>\r\n *\r\n * @param token an `InjectionToken` that identifies a service provided from Angular.\r\n * @param downgradedModule the name of the downgraded module (if any) that the injectable\r\n * \"belongs to\", as returned by a call to `downgradeModule()`. It is the module, whose injector will\r\n * be used for instantiating the injectable.<br />\r\n * (This option is only necessary when using `downgradeModule()` to downgrade more than one Angular\r\n * module.)\r\n *\r\n * @returns a [factory function](https://docs.angularjs.org/guide/di) that can be\r\n * used to register the service on an AngularJS module.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function downgradeInjectable(token: any, downgradedModule?: string): Function;\r\n\r\n/**\r\n * @description\r\n *\r\n * A helper function for creating an AngularJS module that can bootstrap an Angular module\r\n * \"on-demand\" (possibly lazily) when a {@link downgradeComponent downgraded component} needs to be\r\n * instantiated.\r\n *\r\n * *Part of the [upgrade/static](api?query=upgrade/static) library for hybrid upgrade apps that\r\n * support AOT compilation.*\r\n *\r\n * It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to\r\n * pay the cost up-front. For example, you can have an AngularJS application that uses Angular for\r\n * specific routes and only instantiate the Angular modules if/when the user visits one of these\r\n * routes.\r\n *\r\n * The Angular module will be bootstrapped once (when requested for the first time) and the same\r\n * reference will be used from that point onwards.\r\n *\r\n * `downgradeModule()` requires either an `NgModuleFactory` or a function:\r\n * - `NgModuleFactory`: If you pass an `NgModuleFactory`, it will be used to instantiate a module\r\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}.\r\n * - `Function`: If you pass a function, it is expected to return a promise resolving to an\r\n *   `NgModuleRef`. The function is called with an array of extra {@link StaticProvider Providers}\r\n *   that are expected to be available from the returned `NgModuleRef`'s `Injector`.\r\n *\r\n * `downgradeModule()` returns the name of the created AngularJS wrapper module. You can use it to\r\n * declare a dependency in your main AngularJS module.\r\n *\r\n * {@example upgrade/static/ts/lite/module.ts region=\"basic-how-to\"}\r\n *\r\n * For more details on how to use `downgradeModule()` see\r\n * [Upgrading for Performance](guide/upgrade-performance).\r\n *\r\n * @usageNotes\r\n *\r\n * Apart from `UpgradeModule`, you can use the rest of the `upgrade/static` helpers as usual to\r\n * build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be\r\n * available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded\r\n * component.\r\n *\r\n * <div class=\"alert is-important\">\r\n *\r\n *   You cannot use `downgradeModule()` and `UpgradeModule` in the same hybrid application.<br />\r\n *   Use one or the other.\r\n *\r\n * </div>\r\n *\r\n * ### Differences with `UpgradeModule`\r\n *\r\n * Besides their different API, there are two important internal differences between\r\n * `downgradeModule()` and `UpgradeModule` that affect the behavior of hybrid applications:\r\n *\r\n * 1. Unlike `UpgradeModule`, `downgradeModule()` does not bootstrap the main AngularJS module\r\n *    inside the {@link NgZone Angular zone}.\r\n * 2. Unlike `UpgradeModule`, `downgradeModule()` does not automatically run a\r\n *    [$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest) when changes are\r\n *    detected in the Angular part of the application.\r\n *\r\n * What this means is that applications using `UpgradeModule` will run change detection more\r\n * frequently in order to ensure that both frameworks are properly notified about possible changes.\r\n * This will inevitably result in more change detection runs than necessary.\r\n *\r\n * `downgradeModule()`, on the other side, does not try to tie the two change detection systems as\r\n * tightly, restricting the explicit change detection runs only to cases where it knows it is\r\n * necessary (e.g. when the inputs of a downgraded component change). This improves performance,\r\n * especially in change-detection-heavy applications, but leaves it up to the developer to manually\r\n * notify each framework as needed.\r\n *\r\n * For a more detailed discussion of the differences and their implications, see\r\n * [Upgrading for Performance](guide/upgrade-performance).\r\n *\r\n * <div class=\"alert is-helpful\">\r\n *\r\n *   You can manually trigger a change detection run in AngularJS using\r\n *   [scope.$apply(...)](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply) or\r\n *   [$rootScope.$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest).\r\n *\r\n *   You can manually trigger a change detection run in Angular using {@link NgZone#run\r\n *   ngZone.run(...)}.\r\n *\r\n * </div>\r\n *\r\n * ### Downgrading multiple modules\r\n *\r\n * It is possible to downgrade multiple modules and include them in an AngularJS application. In\r\n * that case, each downgraded module will be bootstrapped when an associated downgraded component or\r\n * injectable needs to be instantiated.\r\n *\r\n * Things to keep in mind, when downgrading multiple modules:\r\n *\r\n * - Each downgraded component/injectable needs to be explicitly associated with a downgraded\r\n *   module. See `downgradeComponent()` and `downgradeInjectable()` for more details.\r\n *\r\n * - If you want some injectables to be shared among all downgraded modules, you can provide them as\r\n *   `StaticProvider`s, when creating the `PlatformRef` (e.g. via `platformBrowser` or\r\n *   `platformBrowserDynamic`).\r\n *\r\n * - When using {@link PlatformRef#bootstrapmodule `bootstrapModule()`} or\r\n *   {@link PlatformRef#bootstrapmodulefactory `bootstrapModuleFactory()`} to bootstrap the\r\n *   downgraded modules, each one is considered a \"root\" module. As a consequence, a new instance\r\n *   will be created for every injectable provided in `\"root\"` (via\r\n *   {@link Injectable#providedIn `providedIn`}).\r\n *   If this is not your intention, you can have a shared module (that will act as act as the \"root\"\r\n *   module) and create all downgraded modules using that module's injector:\r\n *\r\n *   {@example upgrade/static/ts/lite-multi-shared/module.ts region=\"shared-root-module\"}\r\n *\r\n * @publicApi\r\n */\r\nexport declare function downgradeModule<T>(moduleFactoryOrBootstrapFn: NgModuleFactory<T> | ((extraProviders: StaticProvider[]) => Promise<NgModuleRef<T>>)): string;\r\n\r\n/**\r\n * Returns the current AngularJS global.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function getAngularJSGlobal(): any;\r\n\r\n/**\r\n * @deprecated Use `getAngularJSGlobal` instead.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function getAngularLib(): any;\r\n\r\ndeclare interface IInjectorService {\r\n    get(key: string): any;\r\n    has(key: string): boolean;\r\n}\r\n\r\n/**\r\n * Resets the AngularJS global.\r\n *\r\n * Used when AngularJS is loaded lazily, and not available on `window`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function setAngularJSGlobal(ng: any): void;\r\n\r\n/**\r\n * @deprecated Use `setAngularJSGlobal` instead.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function setAngularLib(ng: any): void;\r\n\r\n/**\r\n * @description\r\n *\r\n * A helper class that allows an AngularJS component to be used from Angular.\r\n *\r\n * *Part of the [upgrade/static](api?query=upgrade%2Fstatic)\r\n * library for hybrid upgrade apps that support AOT compilation.*\r\n *\r\n * This helper class should be used as a base class for creating Angular directives\r\n * that wrap AngularJS components that need to be \"upgraded\".\r\n *\r\n * @usageNotes\r\n * ### Examples\r\n *\r\n * Let's assume that you have an AngularJS component called `ng1Hero` that needs\r\n * to be made available in Angular templates.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng1-hero\"}\r\n *\r\n * We must create a `Directive` that will make this AngularJS component\r\n * available inside Angular templates.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng1-hero-wrapper\"}\r\n *\r\n * In this example you can see that we must derive from the `UpgradeComponent`\r\n * base class but also provide an {@link Directive `@Directive`} decorator. This is\r\n * because the AOT compiler requires that this information is statically available at\r\n * compile time.\r\n *\r\n * Note that we must do the following:\r\n * * specify the directive's selector (`ng1-hero`)\r\n * * specify all inputs and outputs that the AngularJS component expects\r\n * * derive from `UpgradeComponent`\r\n * * call the base class from the constructor, passing\r\n *   * the AngularJS name of the component (`ng1Hero`)\r\n *   * the `ElementRef` and `Injector` for the component wrapper\r\n *\r\n * @publicApi\r\n * @extensible\r\n */\r\nexport declare class UpgradeComponent implements OnInit, OnChanges, DoCheck, OnDestroy {\r\n    private name;\r\n    private elementRef;\r\n    private injector;\r\n    private helper;\r\n    private $injector;\r\n    private element;\r\n    private $element;\r\n    private $componentScope;\r\n    private directive;\r\n    private bindings;\r\n    private controllerInstance;\r\n    private bindingDestination;\r\n    private pendingChanges;\r\n    private unregisterDoCheckWatcher;\r\n    /**\r\n     * Create a new `UpgradeComponent` instance. You should not normally need to do this.\r\n     * Instead you should derive a new class from this one and call the super constructor\r\n     * from the base class.\r\n     *\r\n     * {@example upgrade/static/ts/full/module.ts region=\"ng1-hero-wrapper\" }\r\n     *\r\n     * * The `name` parameter should be the name of the AngularJS directive.\r\n     * * The `elementRef` and `injector` parameters should be acquired from Angular by dependency\r\n     *   injection into the base class constructor.\r\n     */\r\n    constructor(name: string, elementRef: ElementRef, injector: Injector);\r\n    ngOnInit(): void;\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    ngDoCheck(): void;\r\n    ngOnDestroy(): void;\r\n    private initializeBindings;\r\n    private initializeOutputs;\r\n    private bindOutputs;\r\n    private forwardChanges;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * An `NgModule`, which you import to provide AngularJS core services,\r\n * and has an instance method used to bootstrap the hybrid upgrade application.\r\n *\r\n * *Part of the [upgrade/static](api?query=upgrade/static)\r\n * library for hybrid upgrade apps that support AOT compilation*\r\n *\r\n * The `upgrade/static` package contains helpers that allow AngularJS and Angular components\r\n * to be used together inside a hybrid upgrade application, which supports AOT compilation.\r\n *\r\n * Specifically, the classes and functions in the `upgrade/static` module allow the following:\r\n *\r\n * 1. Creation of an Angular directive that wraps and exposes an AngularJS component so\r\n *    that it can be used in an Angular template. See `UpgradeComponent`.\r\n * 2. Creation of an AngularJS directive that wraps and exposes an Angular component so\r\n *    that it can be used in an AngularJS template. See `downgradeComponent`.\r\n * 3. Creation of an Angular root injector provider that wraps and exposes an AngularJS\r\n *    service so that it can be injected into an Angular context. See\r\n *    {@link UpgradeModule#upgrading-an-angular-1-service Upgrading an AngularJS service} below.\r\n * 4. Creation of an AngularJS service that wraps and exposes an Angular injectable\r\n *    so that it can be injected into an AngularJS context. See `downgradeInjectable`.\r\n * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\r\n *    coexisting in a single application.\r\n *\r\n * @usageNotes\r\n *\r\n * ```ts\r\n * import {UpgradeModule} from '@angular/upgrade/static';\r\n * ```\r\n *\r\n * See also the {@link UpgradeModule#examples examples} below.\r\n *\r\n * ### Mental Model\r\n *\r\n * When reasoning about how a hybrid application works it is useful to have a mental model which\r\n * describes what is happening and explains what is happening at the lowest level.\r\n *\r\n * 1. There are two independent frameworks running in a single application, each framework treats\r\n *    the other as a black box.\r\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\r\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\r\n *    DOM elements and ignores others.\r\n * 3. AngularJS directives always execute inside the AngularJS framework codebase regardless of\r\n *    where they are instantiated.\r\n * 4. Angular components always execute inside the Angular framework codebase regardless of\r\n *    where they are instantiated.\r\n * 5. An AngularJS component can be \"upgraded\"\" to an Angular component. This is achieved by\r\n *    defining an Angular directive, which bootstraps the AngularJS component at its location\r\n *    in the DOM. See `UpgradeComponent`.\r\n * 6. An Angular component can be \"downgraded\" to an AngularJS component. This is achieved by\r\n *    defining an AngularJS directive, which bootstraps the Angular component at its location\r\n *    in the DOM. See `downgradeComponent`.\r\n * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\r\n *    the framework doing the instantiation. The other framework then instantiates and owns the\r\n *    view for that component.\r\n *    1. This implies that the component bindings will always follow the semantics of the\r\n *       instantiation framework.\r\n *    2. The DOM attributes are parsed by the framework that owns the current template. So\r\n *       attributes in AngularJS templates must use kebab-case, while AngularJS templates must use\r\n *       camelCase.\r\n *    3. However the template binding syntax will always use the Angular style, e.g. square\r\n *       brackets (`[...]`) for property binding.\r\n * 8. Angular is bootstrapped first; AngularJS is bootstrapped second. AngularJS always owns the\r\n *    root component of the application.\r\n * 9. The new application is running in an Angular zone, and therefore it no longer needs calls to\r\n *    `$apply()`.\r\n *\r\n * ### The `UpgradeModule` class\r\n *\r\n * This class is an `NgModule`, which you import to provide AngularJS core services,\r\n * and has an instance method used to bootstrap the hybrid upgrade application.\r\n *\r\n * * Core AngularJS services\r\n *   Importing this `NgModule` will add providers for the core\r\n *   [AngularJS services](https://docs.angularjs.org/api/ng/service) to the root injector.\r\n *\r\n * * Bootstrap\r\n *   The runtime instance of this class contains a {@link UpgradeModule#bootstrap `bootstrap()`}\r\n *   method, which you use to bootstrap the top level AngularJS module onto an element in the\r\n *   DOM for the hybrid upgrade app.\r\n *\r\n *   It also contains properties to access the {@link UpgradeModule#injector root injector}, the\r\n *   bootstrap `NgZone` and the\r\n *   [AngularJS $injector](https://docs.angularjs.org/api/auto/service/$injector).\r\n *\r\n * ### Examples\r\n *\r\n * Import the `UpgradeModule` into your top level {@link NgModule Angular `NgModule`}.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region='ng2-module'}\r\n *\r\n * Then inject `UpgradeModule` into your Angular `NgModule` and use it to bootstrap the top level\r\n * [AngularJS module](https://docs.angularjs.org/api/ng/type/angular.Module) in the\r\n * `ngDoBootstrap()` method.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region='bootstrap-ng1'}\r\n *\r\n * Finally, kick off the whole process, by bootstrapping your top level Angular `NgModule`.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region='bootstrap-ng2'}\r\n *\r\n * {@a upgrading-an-angular-1-service}\r\n * ### Upgrading an AngularJS service\r\n *\r\n * There is no specific API for upgrading an AngularJS service. Instead you should just follow the\r\n * following recipe:\r\n *\r\n * Let's say you have an AngularJS service:\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"ng1-text-formatter-service\"}\r\n *\r\n * Then you should define an Angular provider to be included in your `NgModule` `providers`\r\n * property.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"upgrade-ng1-service\"}\r\n *\r\n * Then you can use the \"upgraded\" AngularJS service by injecting it into an Angular component\r\n * or service.\r\n *\r\n * {@example upgrade/static/ts/full/module.ts region=\"use-ng1-upgraded-service\"}\r\n *\r\n * @publicApi\r\n */\r\nexport declare class UpgradeModule {\r\n    /** The bootstrap zone for the upgrade application */\r\n    ngZone: NgZone;\r\n    /**\r\n     * The owning `NgModuleRef`s `PlatformRef` instance.\r\n     * This is used to tie the lifecycle of the bootstrapped AngularJS apps to that of the Angular\r\n     * `PlatformRef`.\r\n     */\r\n    private platformRef;\r\n    /**\r\n     * The AngularJS `$injector` for the upgrade application.\r\n     */\r\n    $injector: any;\r\n    /** The Angular Injector **/\r\n    injector: Injector;\r\n    constructor(\r\n    /** The root `Injector` for the upgrade application. */\r\n    injector: Injector, \r\n    /** The bootstrap zone for the upgrade application */\r\n    ngZone: NgZone, \r\n    /**\r\n     * The owning `NgModuleRef`s `PlatformRef` instance.\r\n     * This is used to tie the lifecycle of the bootstrapped AngularJS apps to that of the Angular\r\n     * `PlatformRef`.\r\n     */\r\n    platformRef: PlatformRef);\r\n    /**\r\n     * Bootstrap an AngularJS application from this NgModule\r\n     * @param element the element on which to bootstrap the AngularJS application\r\n     * @param [modules] the AngularJS modules to bootstrap for this application\r\n     * @param [config] optional extra AngularJS bootstrap configuration\r\n     */\r\n    bootstrap(element: Element, modules?: string[], config?: any): void;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const VERSION: Version;\r\n\r\nexport declare function ɵangular_packages_upgrade_static_static_a(): IInjectorService;\r\n\r\nexport declare function ɵangular_packages_upgrade_static_static_b(i: IInjectorService): any;\r\n\r\nexport declare function ɵangular_packages_upgrade_static_static_c(i: IInjectorService): any;\r\n\r\nexport declare function ɵangular_packages_upgrade_static_static_d(i: IInjectorService): any;\r\n\r\nexport declare const ɵangular_packages_upgrade_static_static_e: {\r\n    provide: string;\r\n    useFactory: typeof ɵangular_packages_upgrade_static_static_b;\r\n    deps: string[];\r\n}[];\r\n\r\nexport { }\r\n"]}