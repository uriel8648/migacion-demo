"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_helpers_1 = require("../../common/core.helpers");
var core_reflect_meta_1 = __importDefault(require("../../common/core.reflect.meta"));
var core_tokens_1 = require("../../common/core.tokens");
var ng_mocks_universe_1 = __importDefault(require("../../common/ng-mocks-universe"));
var get_override_def_1 = __importDefault(require("./get-override-def"));
var skip_override_1 = __importDefault(require("./skip-override"));
exports.default = (function (replaceDef, defValue) {
    var e_1, _a;
    var overrides = new Map();
    try {
        for (var _b = __values((0, core_helpers_1.mapValues)(ng_mocks_universe_1.default.touches)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var proto = _c.value;
            var source = proto;
            var value = ng_mocks_universe_1.default.getBuildDeclaration(source) || source;
            if ((0, skip_override_1.default)(replaceDef, defValue, source, value)) {
                continue;
            }
            var original = (0, core_reflect_meta_1.default)(value);
            var override = (0, get_override_def_1.default)(original);
            if (!override) {
                continue;
            }
            overrides.set(value, [{ set: override }, { set: original }]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        provide: core_tokens_1.NG_MOCKS_OVERRIDES,
        useValue: overrides,
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLW5nLW1vY2tzLW92ZXJyaWRlcy10b2tlbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9tb2NrLWJ1aWxkZXIvcHJvbWlzZS9jcmVhdGUtbmctbW9ja3Mtb3ZlcnJpZGVzLXRva2VuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSwwREFBc0Q7QUFDdEQscUZBQTZEO0FBQzdELHdEQUE4RDtBQUU5RCxxRkFBNkQ7QUFFN0Qsd0VBQWdEO0FBQ2hELGtFQUEyQztBQUUzQyxtQkFBZSxVQUFDLFVBQW9CLEVBQUUsUUFBdUI7O0lBQzNELElBQU0sU0FBUyxHQUFtRSxJQUFJLEdBQUcsRUFBRSxDQUFDOztRQUM1RixLQUFvQixJQUFBLEtBQUEsU0FBQSxJQUFBLHdCQUFTLEVBQUMsMkJBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQSxnQkFBQSw0QkFBRTtZQUFuRCxJQUFNLEtBQUssV0FBQTtZQUNkLElBQU0sTUFBTSxHQUFRLEtBQUssQ0FBQztZQUMxQixJQUFNLEtBQUssR0FBRywyQkFBZSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQztZQUNwRSxJQUFJLElBQUEsdUJBQVksRUFBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRTtnQkFDckQsU0FBUzthQUNWO1lBRUQsSUFBTSxRQUFRLEdBQUcsSUFBQSwyQkFBZSxFQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hDLElBQU0sUUFBUSxHQUFHLElBQUEsMEJBQWMsRUFBQyxRQUFRLENBQUMsQ0FBQztZQUMxQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNiLFNBQVM7YUFDVjtZQUNELFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQzlEOzs7Ozs7Ozs7SUFFRCxPQUFPO1FBQ0wsT0FBTyxFQUFFLGdDQUFrQjtRQUMzQixRQUFRLEVBQUUsU0FBUztLQUNwQixDQUFDO0FBQ0osQ0FBQyxFQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmFsdWVQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWV0YWRhdGFPdmVycmlkZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XG5cbmltcG9ydCB7IG1hcFZhbHVlcyB9IGZyb20gJy4uLy4uL2NvbW1vbi9jb3JlLmhlbHBlcnMnO1xuaW1wb3J0IGNvcmVSZWZsZWN0TWV0YSBmcm9tICcuLi8uLi9jb21tb24vY29yZS5yZWZsZWN0Lm1ldGEnO1xuaW1wb3J0IHsgTkdfTU9DS1NfT1ZFUlJJREVTIH0gZnJvbSAnLi4vLi4vY29tbW9uL2NvcmUudG9rZW5zJztcbmltcG9ydCB7IFR5cGUgfSBmcm9tICcuLi8uLi9jb21tb24vY29yZS50eXBlcyc7XG5pbXBvcnQgbmdNb2Nrc1VuaXZlcnNlIGZyb20gJy4uLy4uL2NvbW1vbi9uZy1tb2Nrcy11bml2ZXJzZSc7XG5cbmltcG9ydCBnZXRPdmVycmlkZURlZiBmcm9tICcuL2dldC1vdmVycmlkZS1kZWYnO1xuaW1wb3J0IHNraXBPdmVycmlkZSBmcm9tICcuL3NraXAtb3ZlcnJpZGUnO1xuXG5leHBvcnQgZGVmYXVsdCAocmVwbGFjZURlZjogU2V0PGFueT4sIGRlZlZhbHVlOiBNYXA8YW55LCBhbnk+KTogVmFsdWVQcm92aWRlciA9PiB7XG4gIGNvbnN0IG92ZXJyaWRlczogTWFwPFR5cGU8YW55PiwgW01ldGFkYXRhT3ZlcnJpZGU8YW55PiwgTWV0YWRhdGFPdmVycmlkZTxhbnk+XT4gPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcHJvdG8gb2YgbWFwVmFsdWVzKG5nTW9ja3NVbml2ZXJzZS50b3VjaGVzKSkge1xuICAgIGNvbnN0IHNvdXJjZTogYW55ID0gcHJvdG87XG4gICAgY29uc3QgdmFsdWUgPSBuZ01vY2tzVW5pdmVyc2UuZ2V0QnVpbGREZWNsYXJhdGlvbihzb3VyY2UpIHx8IHNvdXJjZTtcbiAgICBpZiAoc2tpcE92ZXJyaWRlKHJlcGxhY2VEZWYsIGRlZlZhbHVlLCBzb3VyY2UsIHZhbHVlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSBjb3JlUmVmbGVjdE1ldGEodmFsdWUpO1xuICAgIGNvbnN0IG92ZXJyaWRlID0gZ2V0T3ZlcnJpZGVEZWYob3JpZ2luYWwpO1xuICAgIGlmICghb3ZlcnJpZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBvdmVycmlkZXMuc2V0KHZhbHVlLCBbeyBzZXQ6IG92ZXJyaWRlIH0sIHsgc2V0OiBvcmlnaW5hbCB9XSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3ZpZGU6IE5HX01PQ0tTX09WRVJSSURFUyxcbiAgICB1c2VWYWx1ZTogb3ZlcnJpZGVzLFxuICB9O1xufTtcbiJdfQ==