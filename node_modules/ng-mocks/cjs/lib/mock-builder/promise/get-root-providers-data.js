"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_helpers_1 = require("../../common/core.helpers");
var ng_mocks_universe_1 = __importDefault(require("../../common/ng-mocks-universe"));
exports.default = (function () {
    // We need buckets here to process first all depsSkip, then deps and only after that all other defs.
    var buckets = [
        (0, core_helpers_1.mapValues)(ng_mocks_universe_1.default.config.get('ngMocksDepsSkip')),
        (0, core_helpers_1.mapValues)(ng_mocks_universe_1.default.config.get('ngMocksDeps')),
        (0, core_helpers_1.mapValues)(ng_mocks_universe_1.default.touches),
    ];
    // Also we need to track what has been touched to check params recursively, but avoiding duplicates.
    var touched = [].concat.apply([], __spreadArray([], __read(buckets), false));
    return {
        buckets: buckets,
        touched: touched,
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LXJvb3QtcHJvdmlkZXJzLWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1idWlsZGVyL3Byb21pc2UvZ2V0LXJvb3QtcHJvdmlkZXJzLWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQXNEO0FBQ3RELHFGQUE2RDtBQUU3RCxtQkFBZTtJQUliLG9HQUFvRztJQUNwRyxJQUFNLE9BQU8sR0FBVTtRQUNyQixJQUFBLHdCQUFTLEVBQUMsMkJBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDeEQsSUFBQSx3QkFBUyxFQUFDLDJCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNwRCxJQUFBLHdCQUFTLEVBQUMsMkJBQWUsQ0FBQyxPQUFPLENBQUM7S0FDbkMsQ0FBQztJQUVGLG9HQUFvRztJQUNwRyxJQUFNLE9BQU8sR0FBVSxFQUFFLENBQUMsTUFBTSxPQUFULEVBQUUsMkJBQVcsT0FBTyxVQUFDLENBQUM7SUFFN0MsT0FBTztRQUNMLE9BQU8sU0FBQTtRQUNQLE9BQU8sU0FBQTtLQUNSLENBQUM7QUFDSixDQUFDLEVBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXBWYWx1ZXMgfSBmcm9tICcuLi8uLi9jb21tb24vY29yZS5oZWxwZXJzJztcbmltcG9ydCBuZ01vY2tzVW5pdmVyc2UgZnJvbSAnLi4vLi4vY29tbW9uL25nLW1vY2tzLXVuaXZlcnNlJztcblxuZXhwb3J0IGRlZmF1bHQgKCk6IHtcbiAgYnVja2V0czogYW55W107XG4gIHRvdWNoZWQ6IGFueVtdO1xufSA9PiB7XG4gIC8vIFdlIG5lZWQgYnVja2V0cyBoZXJlIHRvIHByb2Nlc3MgZmlyc3QgYWxsIGRlcHNTa2lwLCB0aGVuIGRlcHMgYW5kIG9ubHkgYWZ0ZXIgdGhhdCBhbGwgb3RoZXIgZGVmcy5cbiAgY29uc3QgYnVja2V0czogYW55W10gPSBbXG4gICAgbWFwVmFsdWVzKG5nTW9ja3NVbml2ZXJzZS5jb25maWcuZ2V0KCduZ01vY2tzRGVwc1NraXAnKSksXG4gICAgbWFwVmFsdWVzKG5nTW9ja3NVbml2ZXJzZS5jb25maWcuZ2V0KCduZ01vY2tzRGVwcycpKSxcbiAgICBtYXBWYWx1ZXMobmdNb2Nrc1VuaXZlcnNlLnRvdWNoZXMpLFxuICBdO1xuXG4gIC8vIEFsc28gd2UgbmVlZCB0byB0cmFjayB3aGF0IGhhcyBiZWVuIHRvdWNoZWQgdG8gY2hlY2sgcGFyYW1zIHJlY3Vyc2l2ZWx5LCBidXQgYXZvaWRpbmcgZHVwbGljYXRlcy5cbiAgY29uc3QgdG91Y2hlZDogYW55W10gPSBbXS5jb25jYXQoLi4uYnVja2V0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICBidWNrZXRzLFxuICAgIHRvdWNoZWQsXG4gIH07XG59O1xuIl19