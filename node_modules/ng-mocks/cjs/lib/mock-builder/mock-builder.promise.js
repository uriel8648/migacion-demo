"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockBuilderPromise = void 0;
var testing_1 = require("@angular/core/testing");
var core_helpers_1 = require("../common/core.helpers");
var func_is_ng_def_1 = require("../common/func.is-ng-def");
var func_is_ng_module_def_with_providers_1 = require("../common/func.is-ng-module-def-with-providers");
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var mock_builder_stash_1 = require("./mock-builder-stash");
var add_missing_keep_declarations_and_modules_1 = __importDefault(require("./promise/add-missing-keep-declarations-and-modules"));
var add_missing_mock_declarations_and_modules_1 = __importDefault(require("./promise/add-missing-mock-declarations-and-modules"));
var add_requested_providers_1 = __importDefault(require("./promise/add-requested-providers"));
var apply_platform_modules_1 = __importDefault(require("./promise/apply-platform-modules"));
var create_ng_mocks_overrides_token_1 = __importDefault(require("./promise/create-ng-mocks-overrides-token"));
var create_ng_mocks_token_1 = __importDefault(require("./promise/create-ng-mocks-token"));
var create_ng_mocks_touches_token_1 = __importDefault(require("./promise/create-ng-mocks-touches-token"));
var detect_wrong_declarations_1 = __importDefault(require("./promise/detect-wrong-declarations"));
var handle_entry_components_1 = __importDefault(require("./promise/handle-entry-components"));
var handle_root_providers_1 = __importDefault(require("./promise/handle-root-providers"));
var init_ng_modules_1 = __importDefault(require("./promise/init-ng-modules"));
var init_universe_1 = __importDefault(require("./promise/init-universe"));
var parse_mock_arguments_1 = __importDefault(require("./promise/parse-mock-arguments"));
var parse_provider_1 = __importDefault(require("./promise/parse-provider"));
var normaliseModule = function (module) {
    return (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(module)
        ? { def: module.ngModule, providers: module.providers }
        : { def: module, providers: undefined };
};
var generateProviderValue = function (provider, existing, multi) {
    return multi ? __spreadArray(__spreadArray([], __read((Array.isArray(existing) ? existing : /* istanbul ignore next */ [])), false), [provider], false) : provider;
};
var defaultMock = {}; // simulating Symbol
var MockBuilderPromise = /** @class */ (function () {
    function MockBuilderPromise() {
        this.beforeCC = new Set();
        this.configDef = new Map();
        this.defProviders = new Map();
        this.defValue = new Map();
        this.excludeDef = new Set();
        this.keepDef = new Set();
        this.mockDef = new Set();
        this.providerDef = new Map();
        this.replaceDef = new Set();
        this.stash = new mock_builder_stash_1.MockBuilderStash();
        // istanbul ignore else
        // tslint:disable-next-line strict-type-predicates
        if (typeof Symbol !== 'undefined') {
            this[Symbol.toStringTag] = 'Promise';
        }
    }
    MockBuilderPromise.prototype.beforeCompileComponents = function (callback) {
        this.beforeCC.add(callback);
        return this;
    };
    MockBuilderPromise.prototype.build = function () {
        this.stash.backup();
        ng_mocks_universe_1.default.config.set('mockNgDefResolver', new Map());
        var params = this.combineParams();
        var ngModule = (0, init_ng_modules_1.default)(params, (0, init_universe_1.default)(params));
        (0, detect_wrong_declarations_1.default)(params);
        (0, add_missing_keep_declarations_and_modules_1.default)(ngModule, params);
        (0, add_missing_mock_declarations_and_modules_1.default)(ngModule, params);
        (0, add_requested_providers_1.default)(ngModule, params);
        (0, handle_root_providers_1.default)(ngModule, params);
        (0, handle_entry_components_1.default)(ngModule);
        (0, apply_platform_modules_1.default)();
        ngModule.providers.push((0, create_ng_mocks_token_1.default)());
        ngModule.providers.push((0, create_ng_mocks_touches_token_1.default)());
        ngModule.providers.push((0, create_ng_mocks_overrides_token_1.default)(this.replaceDef, this.defValue));
        ng_mocks_universe_1.default.config.delete('mockNgDefResolver');
        this.stash.restore();
        return ngModule;
    };
    // istanbul ignore next
    MockBuilderPromise.prototype.catch = function (reject) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.then().catch(reject)];
            });
        });
    };
    MockBuilderPromise.prototype.exclude = function (def) {
        this.wipe(def);
        this.excludeDef.add(def);
        return this;
    };
    // istanbul ignore next
    MockBuilderPromise.prototype.finally = function (callback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.then().finally(callback)];
            });
        });
    };
    MockBuilderPromise.prototype.keep = function (input, config) {
        var _a = normaliseModule(input), def = _a.def, providers = _a.providers;
        var existing = this.keepDef.has(def) ? this.defProviders.get(def) : [];
        this.wipe(def);
        this.keepDef.add(def);
        // a magic to support modules with providers.
        if (providers) {
            this.defProviders.set(def, __spreadArray(__spreadArray([], __read((existing || /* istanbul ignore next */ [])), false), __read(providers), false));
        }
        if (config) {
            this.configDef.set(def, config);
        }
        else {
            this.configDef.delete(def);
        }
        return this;
    };
    MockBuilderPromise.prototype.mock = function (input, a1, a2) {
        if (a1 === void 0) { a1 = defaultMock; }
        var _a = normaliseModule(input), def = _a.def, providers = _a.providers;
        var _b = (0, parse_mock_arguments_1.default)(def, a1, a2, defaultMock), config = _b.config, mock = _b.mock;
        var existing = this.mockDef.has(def) ? this.defProviders.get(def) : [];
        this.wipe(def);
        this.mockDef.add(def);
        // a magic to support modules with providers.
        if (providers) {
            this.defProviders.set(def, __spreadArray(__spreadArray([], __read((existing || /* istanbul ignore next */ [])), false), __read(providers), false));
        }
        this.setDefValue(def, mock);
        this.setConfigDef(def, config);
        return this;
    };
    MockBuilderPromise.prototype.provide = function (def) {
        var e_1, _a;
        try {
            for (var _b = __values((0, core_helpers_1.flatten)(def)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var provider = _c.value;
                var _d = (0, parse_provider_1.default)(provider), provide = _d.provide, multi = _d.multi;
                var existing = this.providerDef.has(provide) ? this.providerDef.get(provide) : [];
                this.wipe(provide);
                this.providerDef.set(provide, generateProviderValue(provider, existing, multi));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    MockBuilderPromise.prototype.replace = function (source, destination, config) {
        if (!(0, func_is_ng_def_1.isNgDef)(destination) || !(0, func_is_ng_def_1.isNgDef)(source) || (0, func_is_ng_def_1.isNgDef)(destination, 'i') || (0, func_is_ng_def_1.isNgDef)(source, 'i')) {
            throw new Error('Cannot replace the declaration, both have to be a Module, a Component, a Directive or a Pipe, for Providers use `.mock` or `.provide`');
        }
        this.wipe(source);
        this.replaceDef.add(source);
        this.defValue.set(source, destination);
        if (config) {
            this.configDef.set(source, config);
        }
        else {
            this.configDef.delete(source);
        }
        return this;
    };
    MockBuilderPromise.prototype.then = function (fulfill, reject) {
        return __awaiter(this, void 0, void 0, function () {
            var promise;
            var _this = this;
            return __generator(this, function (_a) {
                promise = new Promise(function (resolve) {
                    var e_2, _a;
                    var testBed = testing_1.TestBed.configureTestingModule(_this.build());
                    try {
                        for (var _b = __values((0, core_helpers_1.mapValues)(_this.beforeCC)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var callback = _c.value;
                            callback(testBed);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    var testBedPromise = testBed.compileComponents();
                    testBedPromise.then(function () {
                        resolve({ testBed: testBed });
                    });
                });
                return [2 /*return*/, promise.then(fulfill, reject)];
            });
        });
    };
    MockBuilderPromise.prototype.combineParams = function () {
        return {
            configDef: this.configDef,
            defProviders: this.defProviders,
            defValue: this.defValue,
            excludeDef: this.excludeDef,
            keepDef: this.keepDef,
            mockDef: this.mockDef,
            providerDef: this.providerDef,
            replaceDef: this.replaceDef,
        };
    };
    MockBuilderPromise.prototype.setConfigDef = function (def, config) {
        if (config) {
            this.configDef.set(def, config);
        }
        else {
            this.configDef.delete(def);
        }
    };
    MockBuilderPromise.prototype.setDefValue = function (def, mock) {
        if (mock !== defaultMock) {
            this.defValue.set(def, mock);
        }
        else {
            this.defValue.delete(def);
        }
    };
    MockBuilderPromise.prototype.wipe = function (def) {
        this.defProviders.delete(def);
        this.defValue.delete(def);
        this.excludeDef.delete(def);
        this.keepDef.delete(def);
        this.mockDef.delete(def);
        this.providerDef.delete(def);
        this.replaceDef.delete(def);
    };
    return MockBuilderPromise;
}());
exports.MockBuilderPromise = MockBuilderPromise;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1idWlsZGVyLnByb21pc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1idWlsZGVyL21vY2stYnVpbGRlci5wcm9taXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLGlEQUFnRDtBQUVoRCx1REFBNEQ7QUFFNUQsMkRBQW1EO0FBQ25ELHVHQUE0RjtBQUM1RixrRkFBMEQ7QUFFMUQsMkRBQXdEO0FBQ3hELGtJQUF1RztBQUN2RyxrSUFBdUc7QUFDdkcsOEZBQXNFO0FBQ3RFLDRGQUFvRTtBQUNwRSw4R0FBb0Y7QUFDcEYsMEZBQWlFO0FBQ2pFLDBHQUFnRjtBQUNoRixrR0FBMEU7QUFDMUUsOEZBQXNFO0FBQ3RFLDBGQUFrRTtBQUNsRSw4RUFBc0Q7QUFDdEQsMEVBQW1EO0FBQ25ELHdGQUFnRTtBQUNoRSw0RUFBcUQ7QUFJckQsSUFBTSxlQUFlLEdBQUcsVUFDdEIsTUFBVztJQUtYLE9BQUEsSUFBQSxpRUFBMEIsRUFBQyxNQUFNLENBQUM7UUFDaEMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTLEVBQUU7UUFDdkQsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFO0FBRnpDLENBRXlDLENBQUM7QUFFNUMsSUFBTSxxQkFBcUIsR0FBRyxVQUFDLFFBQWEsRUFBRSxRQUFhLEVBQUUsS0FBYztJQUN6RSxPQUFBLEtBQUssQ0FBQyxDQUFDLHdDQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLENBQUMsWUFBRSxRQUFRLFVBQUUsQ0FBQyxDQUFDLFFBQVE7QUFBdEcsQ0FBc0csQ0FBQztBQUV6RyxJQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsQ0FBQyxvQkFBb0I7QUFNNUM7SUFZRTtRQVhVLGFBQVEsR0FBMkMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUM3RCxjQUFTLEdBQTZCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDaEQsaUJBQVksR0FBZ0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN0RCxhQUFRLEdBQTRCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDOUMsZUFBVSxHQUE4QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2xELFlBQU8sR0FBMkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUM1QyxZQUFPLEdBQTJCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDNUMsZ0JBQVcsR0FBK0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNwRCxlQUFVLEdBQThCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDbEQsVUFBSyxHQUFxQixJQUFJLHFDQUFnQixFQUFFLENBQUM7UUFHekQsdUJBQXVCO1FBQ3ZCLGtEQUFrRDtRQUNsRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtZQUNoQyxJQUFZLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztTQUMvQztJQUNILENBQUM7SUFFTSxvREFBdUIsR0FBOUIsVUFBK0IsUUFBMkM7UUFDeEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFNUIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sa0NBQUssR0FBWjtRQUNFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDcEIsMkJBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztRQUUzRCxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFcEMsSUFBTSxRQUFRLEdBQUcsSUFBQSx5QkFBYSxFQUFDLE1BQU0sRUFBRSxJQUFBLHVCQUFZLEVBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUM3RCxJQUFBLG1DQUF1QixFQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hDLElBQUEsbURBQW9DLEVBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZELElBQUEsbURBQW9DLEVBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZELElBQUEsaUNBQXFCLEVBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUEsK0JBQW1CLEVBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLElBQUEsaUNBQXFCLEVBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEMsSUFBQSxnQ0FBb0IsR0FBRSxDQUFDO1FBRXZCLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUEsK0JBQWtCLEdBQUUsQ0FBQyxDQUFDO1FBQzlDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUEsdUNBQXlCLEdBQUUsQ0FBQyxDQUFDO1FBQ3JELFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUEseUNBQTJCLEVBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUVyRiwyQkFBZSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRXJCLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRCx1QkFBdUI7SUFDVixrQ0FBSyxHQUFsQixVQUFtQixNQUFpRTs7O2dCQUNsRixzQkFBTyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFDOzs7S0FDbEM7SUFFTSxvQ0FBTyxHQUFkLFVBQWUsR0FBUTtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFekIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsdUJBQXVCO0lBQ1Ysb0NBQU8sR0FBcEIsVUFBcUIsUUFBMEM7OztnQkFDN0Qsc0JBQU8sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBQzs7O0tBQ3RDO0lBRU0saUNBQUksR0FBWCxVQUFZLEtBQVUsRUFBRSxNQUEyQjtRQUMzQyxJQUFBLEtBQXFCLGVBQWUsQ0FBQyxLQUFLLENBQUMsRUFBekMsR0FBRyxTQUFBLEVBQUUsU0FBUyxlQUEyQixDQUFDO1FBRWxELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV0Qiw2Q0FBNkM7UUFDN0MsSUFBSSxTQUFTLEVBQUU7WUFDYixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLHlDQUFNLENBQUMsUUFBUSxJQUFJLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxrQkFBSyxTQUFTLFVBQUUsQ0FBQztTQUM1RjtRQUVELElBQUksTUFBTSxFQUFFO1lBQ1YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2pDO2FBQU07WUFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM1QjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLGlDQUFJLEdBQVgsVUFBWSxLQUFVLEVBQUUsRUFBcUIsRUFBRSxFQUFRO1FBQS9CLG1CQUFBLEVBQUEsZ0JBQXFCO1FBQ3JDLElBQUEsS0FBcUIsZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUF6QyxHQUFHLFNBQUEsRUFBRSxTQUFTLGVBQTJCLENBQUM7UUFFNUMsSUFBQSxLQUFtQixJQUFBLDhCQUFrQixFQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFdBQVcsQ0FBQyxFQUE3RCxNQUFNLFlBQUEsRUFBRSxJQUFJLFVBQWlELENBQUM7UUFFdEUsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDekUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXRCLDZDQUE2QztRQUM3QyxJQUFJLFNBQVMsRUFBRTtZQUNiLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcseUNBQU0sQ0FBQyxRQUFRLElBQUksMEJBQTBCLENBQUMsRUFBRSxDQUFDLGtCQUFLLFNBQVMsVUFBRSxDQUFDO1NBQzVGO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFL0IsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sb0NBQU8sR0FBZCxVQUFlLEdBQWE7OztZQUMxQixLQUF1QixJQUFBLEtBQUEsU0FBQSxJQUFBLHNCQUFPLEVBQUMsR0FBRyxDQUFDLENBQUEsZ0JBQUEsNEJBQUU7Z0JBQWhDLElBQU0sUUFBUSxXQUFBO2dCQUNYLElBQUEsS0FBcUIsSUFBQSx3QkFBYSxFQUFDLFFBQVEsQ0FBQyxFQUExQyxPQUFPLGFBQUEsRUFBRSxLQUFLLFdBQTRCLENBQUM7Z0JBQ25ELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNwRixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQ2pGOzs7Ozs7Ozs7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTSxvQ0FBTyxHQUFkLFVBQWUsTUFBaUIsRUFBRSxXQUFzQixFQUFFLE1BQTJCO1FBQ25GLElBQUksQ0FBQyxJQUFBLHdCQUFPLEVBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFBLHdCQUFPLEVBQUMsTUFBTSxDQUFDLElBQUksSUFBQSx3QkFBTyxFQUFDLFdBQVcsRUFBRSxHQUFHLENBQUMsSUFBSSxJQUFBLHdCQUFPLEVBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxFQUFFO1lBQ2xHLE1BQU0sSUFBSSxLQUFLLENBQ2IsdUlBQXVJLENBQ3hJLENBQUM7U0FDSDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRXZDLElBQUksTUFBTSxFQUFFO1lBQ1YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3BDO2FBQU07WUFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMvQjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVZLGlDQUFJLEdBQWpCLFVBQ0UsT0FBbUYsRUFDbkYsTUFBK0Q7Ozs7O2dCQUV6RCxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsVUFBQyxPQUE0Qzs7b0JBQ3ZFLElBQU0sT0FBTyxHQUFHLGlCQUFPLENBQUMsc0JBQXNCLENBQUMsS0FBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7O3dCQUM3RCxLQUF1QixJQUFBLEtBQUEsU0FBQSxJQUFBLHdCQUFTLEVBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBLGdCQUFBLDRCQUFFOzRCQUE1QyxJQUFNLFFBQVEsV0FBQTs0QkFDakIsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3lCQUNuQjs7Ozs7Ozs7O29CQUNELElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO29CQUNuRCxjQUFjLENBQUMsSUFBSSxDQUFDO3dCQUNsQixPQUFPLENBQUMsRUFBRSxPQUFPLFNBQUEsRUFBRSxDQUFDLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUVILHNCQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxFQUFDOzs7S0FDdEM7SUFFTywwQ0FBYSxHQUFyQjtRQUNFLE9BQU87WUFDTCxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDekIsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1lBQy9CLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtZQUN2QixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7WUFDM0IsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3JCLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1NBQzVCLENBQUM7SUFDSixDQUFDO0lBRU8seUNBQVksR0FBcEIsVUFBcUIsR0FBUSxFQUFFLE1BQVc7UUFDeEMsSUFBSSxNQUFNLEVBQUU7WUFDVixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDakM7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztJQUVPLHdDQUFXLEdBQW5CLFVBQW9CLEdBQVEsRUFBRSxJQUFTO1FBQ3JDLElBQUksSUFBSSxLQUFLLFdBQVcsRUFBRTtZQUN4QixJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDOUI7YUFBTTtZQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO0lBQ0gsQ0FBQztJQUVPLGlDQUFJLEdBQVosVUFBYSxHQUFjO1FBQ3pCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFDSCx5QkFBQztBQUFELENBQUMsQUFwTUQsSUFvTUM7QUFwTVksZ0RBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUsIFByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUZXN0QmVkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS90ZXN0aW5nJztcblxuaW1wb3J0IHsgZmxhdHRlbiwgbWFwVmFsdWVzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUuaGVscGVycyc7XG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IHsgaXNOZ0RlZiB9IGZyb20gJy4uL2NvbW1vbi9mdW5jLmlzLW5nLWRlZic7XG5pbXBvcnQgeyBpc05nTW9kdWxlRGVmV2l0aFByb3ZpZGVycyB9IGZyb20gJy4uL2NvbW1vbi9mdW5jLmlzLW5nLW1vZHVsZS1kZWYtd2l0aC1wcm92aWRlcnMnO1xuaW1wb3J0IG5nTW9ja3NVbml2ZXJzZSBmcm9tICcuLi9jb21tb24vbmctbW9ja3MtdW5pdmVyc2UnO1xuXG5pbXBvcnQgeyBNb2NrQnVpbGRlclN0YXNoIH0gZnJvbSAnLi9tb2NrLWJ1aWxkZXItc3Rhc2gnO1xuaW1wb3J0IGFkZE1pc3NpbmdLZWVwRGVjbGFyYXRpb25zQW5kTW9kdWxlcyBmcm9tICcuL3Byb21pc2UvYWRkLW1pc3Npbmcta2VlcC1kZWNsYXJhdGlvbnMtYW5kLW1vZHVsZXMnO1xuaW1wb3J0IGFkZE1pc3NpbmdNb2NrRGVjbGFyYXRpb25zQW5kTW9kdWxlcyBmcm9tICcuL3Byb21pc2UvYWRkLW1pc3NpbmctbW9jay1kZWNsYXJhdGlvbnMtYW5kLW1vZHVsZXMnO1xuaW1wb3J0IGFkZFJlcXVlc3RlZFByb3ZpZGVycyBmcm9tICcuL3Byb21pc2UvYWRkLXJlcXVlc3RlZC1wcm92aWRlcnMnO1xuaW1wb3J0IGFwcGx5UGxhdGZvcm1Nb2R1bGVzIGZyb20gJy4vcHJvbWlzZS9hcHBseS1wbGF0Zm9ybS1tb2R1bGVzJztcbmltcG9ydCBjcmVhdGVOZ01vY2tzT3ZlcnJpZGVzVG9rZW4gZnJvbSAnLi9wcm9taXNlL2NyZWF0ZS1uZy1tb2Nrcy1vdmVycmlkZXMtdG9rZW4nO1xuaW1wb3J0IGNyZWF0ZU5nTW9ja3NUb2tlbiBmcm9tICcuL3Byb21pc2UvY3JlYXRlLW5nLW1vY2tzLXRva2VuJztcbmltcG9ydCBjcmVhdGVOZ01vY2tzVG91Y2hlc1Rva2VuIGZyb20gJy4vcHJvbWlzZS9jcmVhdGUtbmctbW9ja3MtdG91Y2hlcy10b2tlbic7XG5pbXBvcnQgZGV0ZWN0V3JvbmdEZWNsYXJhdGlvbnMgZnJvbSAnLi9wcm9taXNlL2RldGVjdC13cm9uZy1kZWNsYXJhdGlvbnMnO1xuaW1wb3J0IGhhbmRsZUVudHJ5Q29tcG9uZW50cyBmcm9tICcuL3Byb21pc2UvaGFuZGxlLWVudHJ5LWNvbXBvbmVudHMnO1xuaW1wb3J0IGhhbmRsZVJvb3RQcm92aWRlcnMgZnJvbSAnLi9wcm9taXNlL2hhbmRsZS1yb290LXByb3ZpZGVycyc7XG5pbXBvcnQgaW5pdE5nTW9kdWxlcyBmcm9tICcuL3Byb21pc2UvaW5pdC1uZy1tb2R1bGVzJztcbmltcG9ydCBpbml0VW5pdmVyc2UgZnJvbSAnLi9wcm9taXNlL2luaXQtdW5pdmVyc2UnO1xuaW1wb3J0IHBhcnNlTW9ja0FyZ3VtZW50cyBmcm9tICcuL3Byb21pc2UvcGFyc2UtbW9jay1hcmd1bWVudHMnO1xuaW1wb3J0IHBhcnNlUHJvdmlkZXIgZnJvbSAnLi9wcm9taXNlL3BhcnNlLXByb3ZpZGVyJztcbmltcG9ydCB7IEJ1aWxkZXJEYXRhIH0gZnJvbSAnLi9wcm9taXNlL3R5cGVzJztcbmltcG9ydCB7IElNb2NrQnVpbGRlciwgSU1vY2tCdWlsZGVyQ29uZmlnLCBJTW9ja0J1aWxkZXJSZXN1bHQgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3Qgbm9ybWFsaXNlTW9kdWxlID0gKFxuICBtb2R1bGU6IGFueSxcbik6IHtcbiAgZGVmOiBUeXBlPGFueT47XG4gIHByb3ZpZGVycz86IFByb3ZpZGVyW107XG59ID0+XG4gIGlzTmdNb2R1bGVEZWZXaXRoUHJvdmlkZXJzKG1vZHVsZSlcbiAgICA/IHsgZGVmOiBtb2R1bGUubmdNb2R1bGUsIHByb3ZpZGVyczogbW9kdWxlLnByb3ZpZGVycyB9XG4gICAgOiB7IGRlZjogbW9kdWxlLCBwcm92aWRlcnM6IHVuZGVmaW5lZCB9O1xuXG5jb25zdCBnZW5lcmF0ZVByb3ZpZGVyVmFsdWUgPSAocHJvdmlkZXI6IGFueSwgZXhpc3Rpbmc6IGFueSwgbXVsdGk6IGJvb2xlYW4pOiBhbnkgPT5cbiAgbXVsdGkgPyBbLi4uKEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpID8gZXhpc3RpbmcgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXSksIHByb3ZpZGVyXSA6IHByb3ZpZGVyO1xuXG5jb25zdCBkZWZhdWx0TW9jayA9IHt9OyAvLyBzaW11bGF0aW5nIFN5bWJvbFxuXG5leHBvcnQgaW50ZXJmYWNlIE1vY2tCdWlsZGVyUHJvbWlzZSB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnUHJvbWlzZSc7XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrQnVpbGRlclByb21pc2UgaW1wbGVtZW50cyBJTW9ja0J1aWxkZXIge1xuICBwcm90ZWN0ZWQgYmVmb3JlQ0M6IFNldDwodGVzdEJlZDogdHlwZW9mIFRlc3RCZWQpID0+IHZvaWQ+ID0gbmV3IFNldCgpO1xuICBwcm90ZWN0ZWQgY29uZmlnRGVmOiBCdWlsZGVyRGF0YVsnY29uZmlnRGVmJ10gPSBuZXcgTWFwKCk7XG4gIHByb3RlY3RlZCBkZWZQcm92aWRlcnM6IEJ1aWxkZXJEYXRhWydkZWZQcm92aWRlcnMnXSA9IG5ldyBNYXAoKTtcbiAgcHJvdGVjdGVkIGRlZlZhbHVlOiBCdWlsZGVyRGF0YVsnZGVmVmFsdWUnXSA9IG5ldyBNYXAoKTtcbiAgcHJvdGVjdGVkIGV4Y2x1ZGVEZWY6IEJ1aWxkZXJEYXRhWydleGNsdWRlRGVmJ10gPSBuZXcgU2V0KCk7XG4gIHByb3RlY3RlZCBrZWVwRGVmOiBCdWlsZGVyRGF0YVsna2VlcERlZiddID0gbmV3IFNldCgpO1xuICBwcm90ZWN0ZWQgbW9ja0RlZjogQnVpbGRlckRhdGFbJ21vY2tEZWYnXSA9IG5ldyBTZXQoKTtcbiAgcHJvdGVjdGVkIHByb3ZpZGVyRGVmOiBCdWlsZGVyRGF0YVsncHJvdmlkZXJEZWYnXSA9IG5ldyBNYXAoKTtcbiAgcHJvdGVjdGVkIHJlcGxhY2VEZWY6IEJ1aWxkZXJEYXRhWydyZXBsYWNlRGVmJ10gPSBuZXcgU2V0KCk7XG4gIHByb3RlY3RlZCBzdGFzaDogTW9ja0J1aWxkZXJTdGFzaCA9IG5ldyBNb2NrQnVpbGRlclN0YXNoKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHN0cmljdC10eXBlLXByZWRpY2F0ZXNcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICh0aGlzIGFzIGFueSlbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdQcm9taXNlJztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYmVmb3JlQ29tcGlsZUNvbXBvbmVudHMoY2FsbGJhY2s6ICh0ZXN0QmVkOiB0eXBlb2YgVGVzdEJlZCkgPT4gdm9pZCk6IHRoaXMge1xuICAgIHRoaXMuYmVmb3JlQ0MuYWRkKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGJ1aWxkKCk6IE5nTW9kdWxlIHtcbiAgICB0aGlzLnN0YXNoLmJhY2t1cCgpO1xuICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWcuc2V0KCdtb2NrTmdEZWZSZXNvbHZlcicsIG5ldyBNYXAoKSk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmNvbWJpbmVQYXJhbXMoKTtcblxuICAgIGNvbnN0IG5nTW9kdWxlID0gaW5pdE5nTW9kdWxlcyhwYXJhbXMsIGluaXRVbml2ZXJzZShwYXJhbXMpKTtcbiAgICBkZXRlY3RXcm9uZ0RlY2xhcmF0aW9ucyhwYXJhbXMpO1xuICAgIGFkZE1pc3NpbmdLZWVwRGVjbGFyYXRpb25zQW5kTW9kdWxlcyhuZ01vZHVsZSwgcGFyYW1zKTtcbiAgICBhZGRNaXNzaW5nTW9ja0RlY2xhcmF0aW9uc0FuZE1vZHVsZXMobmdNb2R1bGUsIHBhcmFtcyk7XG4gICAgYWRkUmVxdWVzdGVkUHJvdmlkZXJzKG5nTW9kdWxlLCBwYXJhbXMpO1xuICAgIGhhbmRsZVJvb3RQcm92aWRlcnMobmdNb2R1bGUsIHBhcmFtcyk7XG4gICAgaGFuZGxlRW50cnlDb21wb25lbnRzKG5nTW9kdWxlKTtcbiAgICBhcHBseVBsYXRmb3JtTW9kdWxlcygpO1xuXG4gICAgbmdNb2R1bGUucHJvdmlkZXJzLnB1c2goY3JlYXRlTmdNb2Nrc1Rva2VuKCkpO1xuICAgIG5nTW9kdWxlLnByb3ZpZGVycy5wdXNoKGNyZWF0ZU5nTW9ja3NUb3VjaGVzVG9rZW4oKSk7XG4gICAgbmdNb2R1bGUucHJvdmlkZXJzLnB1c2goY3JlYXRlTmdNb2Nrc092ZXJyaWRlc1Rva2VuKHRoaXMucmVwbGFjZURlZiwgdGhpcy5kZWZWYWx1ZSkpO1xuXG4gICAgbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5kZWxldGUoJ21vY2tOZ0RlZlJlc29sdmVyJyk7XG4gICAgdGhpcy5zdGFzaC5yZXN0b3JlKCk7XG5cbiAgICByZXR1cm4gbmdNb2R1bGU7XG4gIH1cblxuICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICBwdWJsaWMgYXN5bmMgY2F0Y2gocmVqZWN0PzogKChyZWFzb246IGFueSkgPT4gUHJvbWlzZUxpa2U8bmV2ZXI+KSB8IHVuZGVmaW5lZCB8IG51bGwpOiBQcm9taXNlPElNb2NrQnVpbGRlclJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnRoZW4oKS5jYXRjaChyZWplY3QpO1xuICB9XG5cbiAgcHVibGljIGV4Y2x1ZGUoZGVmOiBhbnkpOiB0aGlzIHtcbiAgICB0aGlzLndpcGUoZGVmKTtcbiAgICB0aGlzLmV4Y2x1ZGVEZWYuYWRkKGRlZik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gIHB1YmxpYyBhc3luYyBmaW5hbGx5KGNhbGxiYWNrPzogKCgpID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFByb21pc2U8SU1vY2tCdWlsZGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMudGhlbigpLmZpbmFsbHkoY2FsbGJhY2spO1xuICB9XG5cbiAgcHVibGljIGtlZXAoaW5wdXQ6IGFueSwgY29uZmlnPzogSU1vY2tCdWlsZGVyQ29uZmlnKTogdGhpcyB7XG4gICAgY29uc3QgeyBkZWYsIHByb3ZpZGVycyB9ID0gbm9ybWFsaXNlTW9kdWxlKGlucHV0KTtcblxuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5rZWVwRGVmLmhhcyhkZWYpID8gdGhpcy5kZWZQcm92aWRlcnMuZ2V0KGRlZikgOiBbXTtcbiAgICB0aGlzLndpcGUoZGVmKTtcbiAgICB0aGlzLmtlZXBEZWYuYWRkKGRlZik7XG5cbiAgICAvLyBhIG1hZ2ljIHRvIHN1cHBvcnQgbW9kdWxlcyB3aXRoIHByb3ZpZGVycy5cbiAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICB0aGlzLmRlZlByb3ZpZGVycy5zZXQoZGVmLCBbLi4uKGV4aXN0aW5nIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdKSwgLi4ucHJvdmlkZXJzXSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWdEZWYuc2V0KGRlZiwgY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25maWdEZWYuZGVsZXRlKGRlZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgbW9jayhpbnB1dDogYW55LCBhMTogYW55ID0gZGVmYXVsdE1vY2ssIGEyPzogYW55KTogdGhpcyB7XG4gICAgY29uc3QgeyBkZWYsIHByb3ZpZGVycyB9ID0gbm9ybWFsaXNlTW9kdWxlKGlucHV0KTtcblxuICAgIGNvbnN0IHsgY29uZmlnLCBtb2NrIH0gPSBwYXJzZU1vY2tBcmd1bWVudHMoZGVmLCBhMSwgYTIsIGRlZmF1bHRNb2NrKTtcblxuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5tb2NrRGVmLmhhcyhkZWYpID8gdGhpcy5kZWZQcm92aWRlcnMuZ2V0KGRlZikgOiBbXTtcbiAgICB0aGlzLndpcGUoZGVmKTtcbiAgICB0aGlzLm1vY2tEZWYuYWRkKGRlZik7XG5cbiAgICAvLyBhIG1hZ2ljIHRvIHN1cHBvcnQgbW9kdWxlcyB3aXRoIHByb3ZpZGVycy5cbiAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICB0aGlzLmRlZlByb3ZpZGVycy5zZXQoZGVmLCBbLi4uKGV4aXN0aW5nIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdKSwgLi4ucHJvdmlkZXJzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXREZWZWYWx1ZShkZWYsIG1vY2spO1xuICAgIHRoaXMuc2V0Q29uZmlnRGVmKGRlZiwgY29uZmlnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIHByb3ZpZGUoZGVmOiBQcm92aWRlcik6IHRoaXMge1xuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgZmxhdHRlbihkZWYpKSB7XG4gICAgICBjb25zdCB7IHByb3ZpZGUsIG11bHRpIH0gPSBwYXJzZVByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5wcm92aWRlckRlZi5oYXMocHJvdmlkZSkgPyB0aGlzLnByb3ZpZGVyRGVmLmdldChwcm92aWRlKSA6IFtdO1xuICAgICAgdGhpcy53aXBlKHByb3ZpZGUpO1xuICAgICAgdGhpcy5wcm92aWRlckRlZi5zZXQocHJvdmlkZSwgZ2VuZXJhdGVQcm92aWRlclZhbHVlKHByb3ZpZGVyLCBleGlzdGluZywgbXVsdGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyByZXBsYWNlKHNvdXJjZTogVHlwZTxhbnk+LCBkZXN0aW5hdGlvbjogVHlwZTxhbnk+LCBjb25maWc/OiBJTW9ja0J1aWxkZXJDb25maWcpOiB0aGlzIHtcbiAgICBpZiAoIWlzTmdEZWYoZGVzdGluYXRpb24pIHx8ICFpc05nRGVmKHNvdXJjZSkgfHwgaXNOZ0RlZihkZXN0aW5hdGlvbiwgJ2knKSB8fCBpc05nRGVmKHNvdXJjZSwgJ2knKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHJlcGxhY2UgdGhlIGRlY2xhcmF0aW9uLCBib3RoIGhhdmUgdG8gYmUgYSBNb2R1bGUsIGEgQ29tcG9uZW50LCBhIERpcmVjdGl2ZSBvciBhIFBpcGUsIGZvciBQcm92aWRlcnMgdXNlIGAubW9ja2Agb3IgYC5wcm92aWRlYCcsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMud2lwZShzb3VyY2UpO1xuICAgIHRoaXMucmVwbGFjZURlZi5hZGQoc291cmNlKTtcbiAgICB0aGlzLmRlZlZhbHVlLnNldChzb3VyY2UsIGRlc3RpbmF0aW9uKTtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnRGVmLnNldChzb3VyY2UsIGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZmlnRGVmLmRlbGV0ZShzb3VyY2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHRoZW48VFJlc3VsdDEgPSBJTW9ja0J1aWxkZXJSZXN1bHQ+KFxuICAgIGZ1bGZpbGw/OiAoKHZhbHVlOiBJTW9ja0J1aWxkZXJSZXN1bHQpID0+IFByb21pc2VMaWtlPFRSZXN1bHQxPikgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHJlamVjdD86ICgocmVhc29uOiBhbnkpID0+IFByb21pc2VMaWtlPGFueT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MT4ge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZTogKHZhbHVlOiBJTW9ja0J1aWxkZXJSZXN1bHQpID0+IHZvaWQpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHRlc3RCZWQgPSBUZXN0QmVkLmNvbmZpZ3VyZVRlc3RpbmdNb2R1bGUodGhpcy5idWlsZCgpKTtcbiAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgbWFwVmFsdWVzKHRoaXMuYmVmb3JlQ0MpKSB7XG4gICAgICAgIGNhbGxiYWNrKHRlc3RCZWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVzdEJlZFByb21pc2UgPSB0ZXN0QmVkLmNvbXBpbGVDb21wb25lbnRzKCk7XG4gICAgICB0ZXN0QmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh7IHRlc3RCZWQgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVsZmlsbCwgcmVqZWN0KTtcbiAgfVxuXG4gIHByaXZhdGUgY29tYmluZVBhcmFtcygpOiBCdWlsZGVyRGF0YSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ0RlZjogdGhpcy5jb25maWdEZWYsXG4gICAgICBkZWZQcm92aWRlcnM6IHRoaXMuZGVmUHJvdmlkZXJzLFxuICAgICAgZGVmVmFsdWU6IHRoaXMuZGVmVmFsdWUsXG4gICAgICBleGNsdWRlRGVmOiB0aGlzLmV4Y2x1ZGVEZWYsXG4gICAgICBrZWVwRGVmOiB0aGlzLmtlZXBEZWYsXG4gICAgICBtb2NrRGVmOiB0aGlzLm1vY2tEZWYsXG4gICAgICBwcm92aWRlckRlZjogdGhpcy5wcm92aWRlckRlZixcbiAgICAgIHJlcGxhY2VEZWY6IHRoaXMucmVwbGFjZURlZixcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRDb25maWdEZWYoZGVmOiBhbnksIGNvbmZpZzogYW55KTogdm9pZCB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWdEZWYuc2V0KGRlZiwgY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25maWdEZWYuZGVsZXRlKGRlZik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXREZWZWYWx1ZShkZWY6IGFueSwgbW9jazogYW55KTogdm9pZCB7XG4gICAgaWYgKG1vY2sgIT09IGRlZmF1bHRNb2NrKSB7XG4gICAgICB0aGlzLmRlZlZhbHVlLnNldChkZWYsIG1vY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZlZhbHVlLmRlbGV0ZShkZWYpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd2lwZShkZWY6IFR5cGU8YW55Pik6IHZvaWQge1xuICAgIHRoaXMuZGVmUHJvdmlkZXJzLmRlbGV0ZShkZWYpO1xuICAgIHRoaXMuZGVmVmFsdWUuZGVsZXRlKGRlZik7XG4gICAgdGhpcy5leGNsdWRlRGVmLmRlbGV0ZShkZWYpO1xuICAgIHRoaXMua2VlcERlZi5kZWxldGUoZGVmKTtcbiAgICB0aGlzLm1vY2tEZWYuZGVsZXRlKGRlZik7XG4gICAgdGhpcy5wcm92aWRlckRlZi5kZWxldGUoZGVmKTtcbiAgICB0aGlzLnJlcGxhY2VEZWYuZGVsZXRlKGRlZik7XG4gIH1cbn1cbiJdfQ==