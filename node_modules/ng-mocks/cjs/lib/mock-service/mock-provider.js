"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_config_1 = __importDefault(require("../common/core.config"));
var func_get_provider_1 = __importDefault(require("../common/func.get-provider"));
var func_is_ng_injection_token_1 = require("../common/func.is-ng-injection-token");
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var helper_define_property_descriptor_1 = __importDefault(require("./helper.define-property-descriptor"));
var helper_extract_property_descriptor_1 = __importDefault(require("./helper.extract-property-descriptor"));
var helper_use_factory_1 = __importDefault(require("./helper.use-factory"));
var mock_service_1 = require("./mock-service");
var neverMockProvidedFunction = core_config_1.default.neverMockProvidedFunction, neverMockToken = core_config_1.default.neverMockToken;
var applyMissingClassProperties = function (instance, useClass) {
    var e_1, _a;
    var existing = Object.getOwnPropertyNames(instance);
    var child = (0, mock_service_1.MockService)(useClass);
    try {
        for (var _b = __values(Object.getOwnPropertyNames(child)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var name_1 = _c.value;
            if (existing.indexOf(name_1) !== -1) {
                continue;
            }
            var def = (0, helper_extract_property_descriptor_1.default)(child, name_1);
            (0, helper_define_property_descriptor_1.default)(instance, name_1, def);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
var createFactoryProvider = function (provider, provide) {
    return (0, helper_use_factory_1.default)(provide, function () {
        var instance = (0, mock_service_1.MockService)(provide);
        // Magic below adds missed properties to the instance to
        // fulfill missed abstract methods.
        if (provide !== provider && Object.keys(provider).indexOf('useClass') !== -1) {
            applyMissingClassProperties(instance, provider.useClass);
        }
        return instance;
    });
};
var normalizePrimitivesMap = [
    [function (value) { return typeof value === 'boolean'; }, false],
    [function (value) { return typeof value === 'number'; }, 0],
    [function (value) { return typeof value === 'string'; }, ''],
    [function (value) { return value === null; }, null],
];
var normalizePrimitives = function (value) {
    var e_2, _a;
    try {
        for (var normalizePrimitivesMap_1 = __values(normalizePrimitivesMap), normalizePrimitivesMap_1_1 = normalizePrimitivesMap_1.next(); !normalizePrimitivesMap_1_1.done; normalizePrimitivesMap_1_1 = normalizePrimitivesMap_1.next()) {
            var _b = __read(normalizePrimitivesMap_1_1.value, 2), check = _b[0], result = _b[1];
            if (check(value)) {
                return result;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (normalizePrimitivesMap_1_1 && !normalizePrimitivesMap_1_1.done && (_a = normalizePrimitivesMap_1.return)) _a.call(normalizePrimitivesMap_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return undefined;
};
var createValueProvider = function (provider, provide) {
    return (0, helper_use_factory_1.default)(provide, function () {
        return provider.useValue && typeof provider.useValue === 'object'
            ? (0, mock_service_1.MockService)(provider.useValue)
            : normalizePrimitives(provider.useValue);
    });
};
var createClassProvider = function (provider, provide) {
    return ng_mocks_universe_1.default.builtProviders.has(provider.useClass) &&
        ng_mocks_universe_1.default.builtProviders.get(provider.useClass) === provider.useClass
        ? provider
        : (0, helper_use_factory_1.default)(provide, function () { return (0, mock_service_1.MockService)(provider.useClass); });
};
var createMockProvider = function (provider, provide, cacheProviders) {
    var mockProvider;
    if (typeof provide === 'function') {
        mockProvider = createFactoryProvider(provider, provide);
    }
    if (provide === provider && mockProvider && cacheProviders) {
        cacheProviders.set(provide, mockProvider);
    }
    return mockProvider;
};
// Tokens are special subject, we can skip adding them because in a mock module they are useless.
// The main problem is that providing undefined to HTTP_INTERCEPTORS and others breaks their code.
// If a testing module / component requires omitted tokens then they should be provided manually
// during creation of TestBed module.
var handleProvider = function (provider, provide, useFactory) {
    var _a;
    if (provide === provider) {
        return useFactory ? (0, helper_use_factory_1.default)(provider, function () { return undefined; }) : undefined;
    }
    if (provider.multi) {
        (_a = ng_mocks_universe_1.default.config.get('ngMocksMulti')) === null || _a === void 0 ? void 0 : _a.add(provide);
        return undefined;
    }
    var mockProvider;
    // istanbul ignore else
    if (Object.keys(provider).indexOf('useValue') !== -1) {
        mockProvider = createValueProvider(provider, provide);
    }
    else if (Object.keys(provider).indexOf('useExisting') !== -1) {
        mockProvider = provider;
    }
    else if (Object.keys(provider).indexOf('useClass') !== -1) {
        mockProvider = createClassProvider(provider, provide);
    }
    else if (Object.keys(provider).indexOf('useFactory') !== -1) {
        mockProvider = (0, helper_use_factory_1.default)(provide, function () { return ({}); });
    }
    return mockProvider;
};
var isNeverMockFunction = function (provide) {
    return typeof provide === 'function' && neverMockProvidedFunction.indexOf(provide.name) !== -1;
};
var isNeverMockToken = function (provide) {
    return (0, func_is_ng_injection_token_1.isNgInjectionToken)(provide) && neverMockToken.indexOf(provide.toString()) !== -1;
};
function default_1(provider, useFactory) {
    if (useFactory === void 0) { useFactory = false; }
    var provide = (0, func_get_provider_1.default)(provider);
    if (ng_mocks_universe_1.default.getResolution(provide) === 'mock') {
        // nothing to do
    }
    else if (isNeverMockFunction(provide)) {
        return provider;
    } /* istanbul ignore if because we mock BrowserModule */
    else if (isNeverMockToken(provide)) {
        return undefined;
    }
    // Only pure provides should be cached to avoid their influence on
    // another different declarations.
    var cacheProviders = ng_mocks_universe_1.default.flags.has('cacheProvider')
        ? ng_mocks_universe_1.default.cacheProviders
        : /* istanbul ignore next */ undefined;
    if (provide === provider && cacheProviders && cacheProviders.has(provide)) {
        return cacheProviders.get(provide);
    }
    return createMockProvider(provider, provide, cacheProviders) || handleProvider(provider, provide, useFactory);
}
exports.default = default_1;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9tb2NrLXNlcnZpY2UvbW9jay1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHNFQUErQztBQUUvQyxrRkFBMEQ7QUFDMUQsbUZBQTBFO0FBQzFFLGtGQUEwRDtBQUUxRCwwR0FBaUY7QUFDakYsNEdBQW1GO0FBQ25GLDRFQUFvRDtBQUNwRCwrQ0FBNkM7QUFFckMsSUFBQSx5QkFBeUIsR0FBcUIscUJBQVUsMEJBQS9CLEVBQUUsY0FBYyxHQUFLLHFCQUFVLGVBQWYsQ0FBZ0I7QUFFakUsSUFBTSwyQkFBMkIsR0FBRyxVQUFDLFFBQWEsRUFBRSxRQUFtQjs7SUFDckUsSUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3RELElBQU0sS0FBSyxHQUFHLElBQUEsMEJBQVcsRUFBQyxRQUFRLENBQUMsQ0FBQzs7UUFFcEMsS0FBbUIsSUFBQSxLQUFBLFNBQUEsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFBLGdCQUFBLDRCQUFFO1lBQWpELElBQU0sTUFBSSxXQUFBO1lBQ2IsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUNqQyxTQUFTO2FBQ1Y7WUFDRCxJQUFNLEdBQUcsR0FBRyxJQUFBLDRDQUErQixFQUFDLEtBQUssRUFBRSxNQUFJLENBQUMsQ0FBQztZQUN6RCxJQUFBLDJDQUE4QixFQUFDLFFBQVEsRUFBRSxNQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDckQ7Ozs7Ozs7OztBQUNILENBQUMsQ0FBQztBQUVGLElBQU0scUJBQXFCLEdBQUcsVUFBQyxRQUFhLEVBQUUsT0FBWTtJQUN4RCxPQUFBLElBQUEsNEJBQWdCLEVBQUMsT0FBTyxFQUFFO1FBQ3hCLElBQU0sUUFBUSxHQUFHLElBQUEsMEJBQVcsRUFBQyxPQUFPLENBQUMsQ0FBQztRQUN0Qyx3REFBd0Q7UUFDeEQsbUNBQW1DO1FBQ25DLElBQUksT0FBTyxLQUFLLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUM1RSwyQkFBMkIsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQyxDQUFDO0FBVEYsQ0FTRSxDQUFDO0FBRUwsSUFBTSxzQkFBc0IsR0FBMEM7SUFDcEUsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLE9BQU8sS0FBSyxLQUFLLFNBQVMsRUFBMUIsQ0FBMEIsRUFBRSxLQUFLLENBQUM7SUFDNUMsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBekIsQ0FBeUIsRUFBRSxDQUFDLENBQUM7SUFDdkMsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBekIsQ0FBeUIsRUFBRSxFQUFFLENBQUM7SUFDeEMsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUssS0FBSyxJQUFJLEVBQWQsQ0FBYyxFQUFFLElBQUksQ0FBQztDQUNoQyxDQUFDO0FBRUYsSUFBTSxtQkFBbUIsR0FBRyxVQUFDLEtBQVU7OztRQUNyQyxLQUE4QixJQUFBLDJCQUFBLFNBQUEsc0JBQXNCLENBQUEsOERBQUEsa0dBQUU7WUFBM0MsSUFBQSxLQUFBLDJDQUFlLEVBQWQsS0FBSyxRQUFBLEVBQUUsTUFBTSxRQUFBO1lBQ3ZCLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUNoQixPQUFPLE1BQU0sQ0FBQzthQUNmO1NBQ0Y7Ozs7Ozs7OztJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMsQ0FBQztBQUVGLElBQU0sbUJBQW1CLEdBQUcsVUFBQyxRQUFhLEVBQUUsT0FBWTtJQUN0RCxPQUFBLElBQUEsNEJBQWdCLEVBQUMsT0FBTyxFQUFFO1FBQ3hCLE9BQUEsUUFBUSxDQUFDLFFBQVEsSUFBSSxPQUFPLFFBQVEsQ0FBQyxRQUFRLEtBQUssUUFBUTtZQUN4RCxDQUFDLENBQUMsSUFBQSwwQkFBVyxFQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7WUFDaEMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7SUFGMUMsQ0FFMEMsQ0FDM0M7QUFKRCxDQUlDLENBQUM7QUFFSixJQUFNLG1CQUFtQixHQUFHLFVBQUMsUUFBYSxFQUFFLE9BQVk7SUFDdEQsT0FBQSwyQkFBZSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUNyRCwyQkFBZSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxRQUFRO1FBQ3pFLENBQUMsQ0FBQyxRQUFRO1FBQ1YsQ0FBQyxDQUFDLElBQUEsNEJBQWdCLEVBQUMsT0FBTyxFQUFFLGNBQU0sT0FBQSxJQUFBLDBCQUFXLEVBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUE5QixDQUE4QixDQUFDO0FBSG5FLENBR21FLENBQUM7QUFFdEUsSUFBTSxrQkFBa0IsR0FBRyxVQUFDLFFBQWEsRUFBRSxPQUFZLEVBQUUsY0FBOEI7SUFDckYsSUFBSSxZQUFrQyxDQUFDO0lBQ3ZDLElBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO1FBQ2pDLFlBQVksR0FBRyxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDekQ7SUFDRCxJQUFJLE9BQU8sS0FBSyxRQUFRLElBQUksWUFBWSxJQUFJLGNBQWMsRUFBRTtRQUMxRCxjQUFjLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztLQUMzQztJQUVELE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUMsQ0FBQztBQUVGLGlHQUFpRztBQUNqRyxrR0FBa0c7QUFDbEcsZ0dBQWdHO0FBQ2hHLHFDQUFxQztBQUNyQyxJQUFNLGNBQWMsR0FBRyxVQUFDLFFBQWEsRUFBRSxPQUFZLEVBQUUsVUFBbUI7O0lBQ3RFLElBQUksT0FBTyxLQUFLLFFBQVEsRUFBRTtRQUN4QixPQUFPLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBQSw0QkFBZ0IsRUFBQyxRQUFRLEVBQUUsY0FBTSxPQUFBLFNBQVMsRUFBVCxDQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0tBQzdFO0lBQ0QsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO1FBQ2xCLE1BQUEsMkJBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQywwQ0FBRSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFekQsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxJQUFJLFlBQWlCLENBQUM7SUFDdEIsdUJBQXVCO0lBQ3ZCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDcEQsWUFBWSxHQUFHLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUN2RDtTQUFNLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDOUQsWUFBWSxHQUFHLFFBQVEsQ0FBQztLQUN6QjtTQUFNLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDM0QsWUFBWSxHQUFHLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUN2RDtTQUFNLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDN0QsWUFBWSxHQUFHLElBQUEsNEJBQWdCLEVBQUMsT0FBTyxFQUFFLGNBQU0sT0FBQSxDQUFDLEVBQUUsQ0FBQyxFQUFKLENBQUksQ0FBQyxDQUFDO0tBQ3REO0lBRUQsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQyxDQUFDO0FBRUYsSUFBTSxtQkFBbUIsR0FBRyxVQUFDLE9BQVk7SUFDdkMsT0FBQSxPQUFPLE9BQU8sS0FBSyxVQUFVLElBQUkseUJBQXlCLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFBdkYsQ0FBdUYsQ0FBQztBQUUxRixJQUFNLGdCQUFnQixHQUFHLFVBQUMsT0FBWTtJQUNwQyxPQUFBLElBQUEsK0NBQWtCLEVBQUMsT0FBTyxDQUFDLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7QUFBaEYsQ0FBZ0YsQ0FBQztBQUVuRixtQkFBeUIsUUFBYSxFQUFFLFVBQWtCO0lBQWxCLDJCQUFBLEVBQUEsa0JBQWtCO0lBQ3hELElBQU0sT0FBTyxHQUFHLElBQUEsMkJBQWUsRUFBQyxRQUFRLENBQUMsQ0FBQztJQUUxQyxJQUFJLDJCQUFlLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxLQUFLLE1BQU0sRUFBRTtRQUNyRCxnQkFBZ0I7S0FDakI7U0FBTSxJQUFJLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZDLE9BQU8sUUFBUSxDQUFDO0tBQ2pCLENBQUMsc0RBQXNEO1NBQU0sSUFBSSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUMzRixPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUVELGtFQUFrRTtJQUNsRSxrQ0FBa0M7SUFDbEMsSUFBTSxjQUFjLEdBQUcsMkJBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQztRQUMvRCxDQUFDLENBQUMsMkJBQWUsQ0FBQyxjQUFjO1FBQ2hDLENBQUMsQ0FBQywwQkFBMEIsQ0FBQyxTQUFTLENBQUM7SUFDekMsSUFBSSxPQUFPLEtBQUssUUFBUSxJQUFJLGNBQWMsSUFBSSxjQUFjLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3pFLE9BQU8sY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNwQztJQUVELE9BQU8sa0JBQWtCLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsSUFBSSxjQUFjLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNoSCxDQUFDO0FBckJELDRCQXFCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCBjb3JlQ29uZmlnIGZyb20gJy4uL2NvbW1vbi9jb3JlLmNvbmZpZyc7XG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IGZ1bmNHZXRQcm92aWRlciBmcm9tICcuLi9jb21tb24vZnVuYy5nZXQtcHJvdmlkZXInO1xuaW1wb3J0IHsgaXNOZ0luamVjdGlvblRva2VuIH0gZnJvbSAnLi4vY29tbW9uL2Z1bmMuaXMtbmctaW5qZWN0aW9uLXRva2VuJztcbmltcG9ydCBuZ01vY2tzVW5pdmVyc2UgZnJvbSAnLi4vY29tbW9uL25nLW1vY2tzLXVuaXZlcnNlJztcblxuaW1wb3J0IGhlbHBlckRlZmluZVByb3BlcnR5RGVzY3JpcHRvciBmcm9tICcuL2hlbHBlci5kZWZpbmUtcHJvcGVydHktZGVzY3JpcHRvcic7XG5pbXBvcnQgaGVscGVyRXh0cmFjdFByb3BlcnR5RGVzY3JpcHRvciBmcm9tICcuL2hlbHBlci5leHRyYWN0LXByb3BlcnR5LWRlc2NyaXB0b3InO1xuaW1wb3J0IGhlbHBlclVzZUZhY3RvcnkgZnJvbSAnLi9oZWxwZXIudXNlLWZhY3RvcnknO1xuaW1wb3J0IHsgTW9ja1NlcnZpY2UgfSBmcm9tICcuL21vY2stc2VydmljZSc7XG5cbmNvbnN0IHsgbmV2ZXJNb2NrUHJvdmlkZWRGdW5jdGlvbiwgbmV2ZXJNb2NrVG9rZW4gfSA9IGNvcmVDb25maWc7XG5cbmNvbnN0IGFwcGx5TWlzc2luZ0NsYXNzUHJvcGVydGllcyA9IChpbnN0YW5jZTogYW55LCB1c2VDbGFzczogVHlwZTxhbnk+KSA9PiB7XG4gIGNvbnN0IGV4aXN0aW5nID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5zdGFuY2UpO1xuICBjb25zdCBjaGlsZCA9IE1vY2tTZXJ2aWNlKHVzZUNsYXNzKTtcblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hpbGQpKSB7XG4gICAgaWYgKGV4aXN0aW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gaGVscGVyRXh0cmFjdFByb3BlcnR5RGVzY3JpcHRvcihjaGlsZCwgbmFtZSk7XG4gICAgaGVscGVyRGVmaW5lUHJvcGVydHlEZXNjcmlwdG9yKGluc3RhbmNlLCBuYW1lLCBkZWYpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVGYWN0b3J5UHJvdmlkZXIgPSAocHJvdmlkZXI6IGFueSwgcHJvdmlkZTogYW55KSA9PlxuICBoZWxwZXJVc2VGYWN0b3J5KHByb3ZpZGUsICgpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IE1vY2tTZXJ2aWNlKHByb3ZpZGUpO1xuICAgIC8vIE1hZ2ljIGJlbG93IGFkZHMgbWlzc2VkIHByb3BlcnRpZXMgdG8gdGhlIGluc3RhbmNlIHRvXG4gICAgLy8gZnVsZmlsbCBtaXNzZWQgYWJzdHJhY3QgbWV0aG9kcy5cbiAgICBpZiAocHJvdmlkZSAhPT0gcHJvdmlkZXIgJiYgT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZUNsYXNzJykgIT09IC0xKSB7XG4gICAgICBhcHBseU1pc3NpbmdDbGFzc1Byb3BlcnRpZXMoaW5zdGFuY2UsIHByb3ZpZGVyLnVzZUNsYXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0pO1xuXG5jb25zdCBub3JtYWxpemVQcmltaXRpdmVzTWFwOiBBcnJheTxbKHZhbHVlOiBhbnkpID0+IGJvb2xlYW4sIGFueV0+ID0gW1xuICBbdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsIGZhbHNlXSxcbiAgW3ZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsIDBdLFxuICBbdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJyddLFxuICBbdmFsdWUgPT4gdmFsdWUgPT09IG51bGwsIG51bGxdLFxuXTtcblxuY29uc3Qgbm9ybWFsaXplUHJpbWl0aXZlcyA9ICh2YWx1ZTogYW55KTogYW55ID0+IHtcbiAgZm9yIChjb25zdCBbY2hlY2ssIHJlc3VsdF0gb2Ygbm9ybWFsaXplUHJpbWl0aXZlc01hcCkge1xuICAgIGlmIChjaGVjayh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IGNyZWF0ZVZhbHVlUHJvdmlkZXIgPSAocHJvdmlkZXI6IGFueSwgcHJvdmlkZTogYW55KSA9PlxuICBoZWxwZXJVc2VGYWN0b3J5KHByb3ZpZGUsICgpID0+XG4gICAgcHJvdmlkZXIudXNlVmFsdWUgJiYgdHlwZW9mIHByb3ZpZGVyLnVzZVZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgPyBNb2NrU2VydmljZShwcm92aWRlci51c2VWYWx1ZSlcbiAgICAgIDogbm9ybWFsaXplUHJpbWl0aXZlcyhwcm92aWRlci51c2VWYWx1ZSksXG4gICk7XG5cbmNvbnN0IGNyZWF0ZUNsYXNzUHJvdmlkZXIgPSAocHJvdmlkZXI6IGFueSwgcHJvdmlkZTogYW55KSA9PlxuICBuZ01vY2tzVW5pdmVyc2UuYnVpbHRQcm92aWRlcnMuaGFzKHByb3ZpZGVyLnVzZUNsYXNzKSAmJlxuICBuZ01vY2tzVW5pdmVyc2UuYnVpbHRQcm92aWRlcnMuZ2V0KHByb3ZpZGVyLnVzZUNsYXNzKSA9PT0gcHJvdmlkZXIudXNlQ2xhc3NcbiAgICA/IHByb3ZpZGVyXG4gICAgOiBoZWxwZXJVc2VGYWN0b3J5KHByb3ZpZGUsICgpID0+IE1vY2tTZXJ2aWNlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG5cbmNvbnN0IGNyZWF0ZU1vY2tQcm92aWRlciA9IChwcm92aWRlcjogYW55LCBwcm92aWRlOiBhbnksIGNhY2hlUHJvdmlkZXJzPzogTWFwPGFueSwgYW55Pik6IFByb3ZpZGVyIHwgdW5kZWZpbmVkID0+IHtcbiAgbGV0IG1vY2tQcm92aWRlcjogUHJvdmlkZXIgfCB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vY2tQcm92aWRlciA9IGNyZWF0ZUZhY3RvcnlQcm92aWRlcihwcm92aWRlciwgcHJvdmlkZSk7XG4gIH1cbiAgaWYgKHByb3ZpZGUgPT09IHByb3ZpZGVyICYmIG1vY2tQcm92aWRlciAmJiBjYWNoZVByb3ZpZGVycykge1xuICAgIGNhY2hlUHJvdmlkZXJzLnNldChwcm92aWRlLCBtb2NrUHJvdmlkZXIpO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tQcm92aWRlcjtcbn07XG5cbi8vIFRva2VucyBhcmUgc3BlY2lhbCBzdWJqZWN0LCB3ZSBjYW4gc2tpcCBhZGRpbmcgdGhlbSBiZWNhdXNlIGluIGEgbW9jayBtb2R1bGUgdGhleSBhcmUgdXNlbGVzcy5cbi8vIFRoZSBtYWluIHByb2JsZW0gaXMgdGhhdCBwcm92aWRpbmcgdW5kZWZpbmVkIHRvIEhUVFBfSU5URVJDRVBUT1JTIGFuZCBvdGhlcnMgYnJlYWtzIHRoZWlyIGNvZGUuXG4vLyBJZiBhIHRlc3RpbmcgbW9kdWxlIC8gY29tcG9uZW50IHJlcXVpcmVzIG9taXR0ZWQgdG9rZW5zIHRoZW4gdGhleSBzaG91bGQgYmUgcHJvdmlkZWQgbWFudWFsbHlcbi8vIGR1cmluZyBjcmVhdGlvbiBvZiBUZXN0QmVkIG1vZHVsZS5cbmNvbnN0IGhhbmRsZVByb3ZpZGVyID0gKHByb3ZpZGVyOiBhbnksIHByb3ZpZGU6IGFueSwgdXNlRmFjdG9yeTogYm9vbGVhbikgPT4ge1xuICBpZiAocHJvdmlkZSA9PT0gcHJvdmlkZXIpIHtcbiAgICByZXR1cm4gdXNlRmFjdG9yeSA/IGhlbHBlclVzZUZhY3RvcnkocHJvdmlkZXIsICgpID0+IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByb3ZpZGVyLm11bHRpKSB7XG4gICAgbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5nZXQoJ25nTW9ja3NNdWx0aScpPy5hZGQocHJvdmlkZSk7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGV0IG1vY2tQcm92aWRlcjogYW55O1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICBpZiAoT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZVZhbHVlJykgIT09IC0xKSB7XG4gICAgbW9ja1Byb3ZpZGVyID0gY3JlYXRlVmFsdWVQcm92aWRlcihwcm92aWRlciwgcHJvdmlkZSk7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZUV4aXN0aW5nJykgIT09IC0xKSB7XG4gICAgbW9ja1Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZUNsYXNzJykgIT09IC0xKSB7XG4gICAgbW9ja1Byb3ZpZGVyID0gY3JlYXRlQ2xhc3NQcm92aWRlcihwcm92aWRlciwgcHJvdmlkZSk7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMocHJvdmlkZXIpLmluZGV4T2YoJ3VzZUZhY3RvcnknKSAhPT0gLTEpIHtcbiAgICBtb2NrUHJvdmlkZXIgPSBoZWxwZXJVc2VGYWN0b3J5KHByb3ZpZGUsICgpID0+ICh7fSkpO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tQcm92aWRlcjtcbn07XG5cbmNvbnN0IGlzTmV2ZXJNb2NrRnVuY3Rpb24gPSAocHJvdmlkZTogYW55KTogYm9vbGVhbiA9PlxuICB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXZlck1vY2tQcm92aWRlZEZ1bmN0aW9uLmluZGV4T2YocHJvdmlkZS5uYW1lKSAhPT0gLTE7XG5cbmNvbnN0IGlzTmV2ZXJNb2NrVG9rZW4gPSAocHJvdmlkZTogYW55KTogYm9vbGVhbiA9PlxuICBpc05nSW5qZWN0aW9uVG9rZW4ocHJvdmlkZSkgJiYgbmV2ZXJNb2NrVG9rZW4uaW5kZXhPZihwcm92aWRlLnRvU3RyaW5nKCkpICE9PSAtMTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHByb3ZpZGVyOiBhbnksIHVzZUZhY3RvcnkgPSBmYWxzZSk6IFByb3ZpZGVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcHJvdmlkZSA9IGZ1bmNHZXRQcm92aWRlcihwcm92aWRlcik7XG5cbiAgaWYgKG5nTW9ja3NVbml2ZXJzZS5nZXRSZXNvbHV0aW9uKHByb3ZpZGUpID09PSAnbW9jaycpIHtcbiAgICAvLyBub3RoaW5nIHRvIGRvXG4gIH0gZWxzZSBpZiAoaXNOZXZlck1vY2tGdW5jdGlvbihwcm92aWRlKSkge1xuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgYmVjYXVzZSB3ZSBtb2NrIEJyb3dzZXJNb2R1bGUgKi8gZWxzZSBpZiAoaXNOZXZlck1vY2tUb2tlbihwcm92aWRlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBPbmx5IHB1cmUgcHJvdmlkZXMgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCB0aGVpciBpbmZsdWVuY2Ugb25cbiAgLy8gYW5vdGhlciBkaWZmZXJlbnQgZGVjbGFyYXRpb25zLlxuICBjb25zdCBjYWNoZVByb3ZpZGVycyA9IG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ2NhY2hlUHJvdmlkZXInKVxuICAgID8gbmdNb2Nrc1VuaXZlcnNlLmNhY2hlUHJvdmlkZXJzXG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1bmRlZmluZWQ7XG4gIGlmIChwcm92aWRlID09PSBwcm92aWRlciAmJiBjYWNoZVByb3ZpZGVycyAmJiBjYWNoZVByb3ZpZGVycy5oYXMocHJvdmlkZSkpIHtcbiAgICByZXR1cm4gY2FjaGVQcm92aWRlcnMuZ2V0KHByb3ZpZGUpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU1vY2tQcm92aWRlcihwcm92aWRlciwgcHJvdmlkZSwgY2FjaGVQcm92aWRlcnMpIHx8IGhhbmRsZVByb3ZpZGVyKHByb3ZpZGVyLCBwcm92aWRlLCB1c2VGYWN0b3J5KTtcbn1cbiJdfQ==