"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockModule = void 0;
var core_1 = require("@angular/core");
var testing_1 = require("@angular/core/testing");
var core_config_1 = __importDefault(require("../common/core.config"));
var core_helpers_1 = require("../common/core.helpers");
var core_reflect_module_resolve_1 = __importDefault(require("../common/core.reflect.module-resolve"));
var decorate_mock_1 = __importDefault(require("../common/decorate.mock"));
var func_get_mocked_ng_def_of_1 = require("../common/func.get-mocked-ng-def-of");
var func_import_exists_1 = __importDefault(require("../common/func.import-exists"));
var func_is_mock_ng_def_1 = require("../common/func.is-mock-ng-def");
var func_is_ng_def_1 = require("../common/func.is-ng-def");
var func_is_ng_module_def_with_providers_1 = require("../common/func.is-ng-module-def-with-providers");
var mock_1 = require("../common/mock");
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var mock_ng_def_1 = __importDefault(require("./mock-ng-def"));
var flagMock = function (resolution) { return resolution === 'mock' && ng_mocks_universe_1.default.flags.has('skipMock'); };
var flagKeep = function (resolution) { return resolution === 'keep' && !ng_mocks_universe_1.default.flags.has('skipMock'); };
var flagReplace = function (resolution) {
    return resolution === 'replace' && !ng_mocks_universe_1.default.flags.has('skipMock');
};
var flagNever = function (ngModule) {
    return core_config_1.default.neverMockModule.indexOf(ngModule.name) !== -1 && !ng_mocks_universe_1.default.flags.has('skipMock');
};
var preprocessToggleFlag = function (ngModule) {
    var toggleSkipMockFlag = false;
    var resolution = ng_mocks_universe_1.default.getResolution(ngModule);
    if (flagMock(resolution)) {
        toggleSkipMockFlag = true;
        ng_mocks_universe_1.default.flags.delete('skipMock');
    }
    if (flagKeep(resolution) || flagReplace(resolution) || flagNever(ngModule)) {
        toggleSkipMockFlag = true;
        ng_mocks_universe_1.default.flags.add('skipMock');
    }
    return toggleSkipMockFlag;
};
var postprocessToggleFlag = function (toggleSkipMockFlag) {
    if (toggleSkipMockFlag && ng_mocks_universe_1.default.flags.has('skipMock')) {
        ng_mocks_universe_1.default.flags.delete('skipMock');
    }
    else if (toggleSkipMockFlag && !ng_mocks_universe_1.default.flags.has('skipMock')) {
        ng_mocks_universe_1.default.flags.add('skipMock');
    }
};
var extractModuleAndProviders = function (module) {
    var ngModule;
    var ngModuleProviders;
    if ((0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(module)) {
        ngModule = module.ngModule;
        if (module.providers) {
            ngModuleProviders = module.providers;
        }
    }
    else {
        ngModule = module;
    }
    return {
        ngModule: ngModule,
        ngModuleProviders: ngModuleProviders,
    };
};
var getExistingMockModule = function (ngModule) {
    if ((0, func_is_mock_ng_def_1.isMockNgDef)(ngModule, 'm')) {
        return ngModule;
    }
    // Every module should be replaced with its mock copy only once to avoid errors like:
    // Failed: Type ...Component is part of the declarations of 2 modules: ...Module and ...Module...
    if (ng_mocks_universe_1.default.flags.has('cacheModule') && ng_mocks_universe_1.default.cacheDeclarations.has(ngModule)) {
        return ng_mocks_universe_1.default.cacheDeclarations.get(ngModule);
    }
    // Now we check if we need to keep the original module or to replace it with some other.
    if (ng_mocks_universe_1.default.hasBuildDeclaration(ngModule)) {
        var instance = ng_mocks_universe_1.default.getBuildDeclaration(ngModule);
        if ((0, func_is_ng_def_1.isNgDef)(instance, 'm') && instance !== ngModule) {
            return instance;
        }
    }
    return undefined;
};
var getMockModuleDef = function (ngModule, mockModule) {
    if (!mockModule) {
        var meta = (0, core_reflect_module_resolve_1.default)(ngModule);
        var _a = __read((0, mock_ng_def_1.default)(meta, ngModule), 2), changed = _a[0], ngModuleDef = _a[1];
        if (changed) {
            return ngModuleDef;
        }
    }
    return undefined;
};
var detectMockModule = function (ngModule, mockModule) {
    var mockModuleDef = getMockModuleDef(ngModule, mockModule);
    if (mockModuleDef) {
        var parent_1 = ng_mocks_universe_1.default.flags.has('skipMock') ? ngModule : mock_1.Mock;
        var mock = (0, core_helpers_1.extendClass)(parent_1);
        // the last thing is to apply decorators.
        (0, core_1.NgModule)(mockModuleDef)(mock);
        (0, decorate_mock_1.default)(mock, ngModule);
        return mock;
    }
    return mockModule || ngModule;
};
var getMockProviders = function (ngModuleProviders) {
    if (ngModuleProviders) {
        var _a = __read((0, mock_ng_def_1.default)({ providers: ngModuleProviders }), 2), changed = _a[0], ngModuleDef = _a[1];
        return changed ? ngModuleDef.providers : ngModuleProviders;
    }
    return undefined;
};
var generateReturn = function (module, ngModule, ngModuleProviders, mockModule, mockModuleProviders) {
    return mockModule === ngModule && mockModuleProviders === ngModuleProviders
        ? module
        : (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(module)
            ? __assign({ ngModule: mockModule }, (mockModuleProviders ? { providers: mockModuleProviders } : {})) : mockModule;
};
function MockModule(module) {
    var _a;
    (0, func_import_exists_1.default)(module, 'MockModule');
    var _b = extractModuleAndProviders(module), ngModule = _b.ngModule, ngModuleProviders = _b.ngModuleProviders;
    // We are inside of an 'it'. It is fine to to return a mock copy.
    if (!ngModuleProviders && (0, testing_1.getTestBed)()._instantiated) {
        try {
            return (0, func_get_mocked_ng_def_of_1.getMockedNgDefOf)(ngModule, 'm');
        }
        catch (error) {
            // looks like an in-test mock.
        }
    }
    var toggleSkipMockFlag = preprocessToggleFlag(ngModule);
    var mockModule = detectMockModule(ngModule, getExistingMockModule(ngModule));
    // istanbul ignore else
    if (ng_mocks_universe_1.default.flags.has('cacheModule')) {
        ng_mocks_universe_1.default.cacheDeclarations.set(ngModule, mockModule);
    }
    if (ng_mocks_universe_1.default.flags.has('skipMock')) {
        (_a = ng_mocks_universe_1.default.config.get('ngMocksDepsSkip')) === null || _a === void 0 ? void 0 : _a.add(mockModule);
    }
    var mockModuleProviders = getMockProviders(ngModuleProviders);
    postprocessToggleFlag(toggleSkipMockFlag);
    return generateReturn(module, ngModule, ngModuleProviders, mockModule, mockModuleProviders);
}
exports.MockModule = MockModule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1tb2R1bGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1tb2R1bGUvbW9jay1tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0NBQW1EO0FBQ25ELGlEQUFtRDtBQUVuRCxzRUFBK0M7QUFDL0MsdURBQXFEO0FBQ3JELHNHQUE2RTtBQUU3RSwwRUFBbUQ7QUFDbkQsaUZBQXVFO0FBQ3ZFLG9GQUE0RDtBQUM1RCxxRUFBNEQ7QUFDNUQsMkRBQW1EO0FBQ25ELHVHQUFtSDtBQUNuSCx1Q0FBc0M7QUFDdEMsa0ZBQTBEO0FBRTFELDhEQUFzQztBQUV0QyxJQUFNLFFBQVEsR0FBRyxVQUFDLFVBQW1CLElBQWMsT0FBQSxVQUFVLEtBQUssTUFBTSxJQUFJLDJCQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBOUQsQ0FBOEQsQ0FBQztBQUVsSCxJQUFNLFFBQVEsR0FBRyxVQUFDLFVBQW1CLElBQWMsT0FBQSxVQUFVLEtBQUssTUFBTSxJQUFJLENBQUMsMkJBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUEvRCxDQUErRCxDQUFDO0FBRW5ILElBQU0sV0FBVyxHQUFHLFVBQUMsVUFBbUI7SUFDdEMsT0FBQSxVQUFVLEtBQUssU0FBUyxJQUFJLENBQUMsMkJBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztBQUFsRSxDQUFrRSxDQUFDO0FBRXJFLElBQU0sU0FBUyxHQUFHLFVBQUMsUUFBYztJQUMvQixPQUFBLHFCQUFVLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQywyQkFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFD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QUcsQ0FBQyxhQUFhLENBQUMsRUFBRTtRQUM1QywyQkFBZSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7S0FDN0Q7SUFDRCxJQUFJLDJCQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUN6QyxNQUFBLDJCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQywwQ0FBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDaEU7SUFDRCxJQUFNLG1CQUFtQixHQUFHLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDaEUscUJBQXFCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUUxQyxPQUFPLGNBQWMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0FBQzlGLENBQUM7QUExQkQsZ0NBMEJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUsIFByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRUZXN0QmVkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS90ZXN0aW5nJztcblxuaW1wb3J0IGNvcmVDb25maWcgZnJvbSAnLi4vY29tbW9uL2NvcmUuY29uZmlnJztcbmltcG9ydCB7IGV4dGVuZENsYXNzIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUuaGVscGVycyc7XG5pbXBvcnQgY29yZVJlZmxlY3RNb2R1bGVSZXNvbHZlIGZyb20gJy4uL2NvbW1vbi9jb3JlLnJlZmxlY3QubW9kdWxlLXJlc29sdmUnO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9jb3JlLnR5cGVzJztcbmltcG9ydCBkZWNvcmF0ZU1vY2sgZnJvbSAnLi4vY29tbW9uL2RlY29yYXRlLm1vY2snO1xuaW1wb3J0IHsgZ2V0TW9ja2VkTmdEZWZPZiB9IGZyb20gJy4uL2NvbW1vbi9mdW5jLmdldC1tb2NrZWQtbmctZGVmLW9mJztcbmltcG9ydCBmdW5jSW1wb3J0RXhpc3RzIGZyb20gJy4uL2NvbW1vbi9mdW5jLmltcG9ydC1leGlzdHMnO1xuaW1wb3J0IHsgaXNNb2NrTmdEZWYgfSBmcm9tICcuLi9jb21tb24vZnVuYy5pcy1tb2NrLW5nLWRlZic7XG5pbXBvcnQgeyBpc05nRGVmIH0gZnJvbSAnLi4vY29tbW9uL2Z1bmMuaXMtbmctZGVmJztcbmltcG9ydCB7IGlzTmdNb2R1bGVEZWZXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICcuLi9jb21tb24vZnVuYy5pcy1uZy1tb2R1bGUtZGVmLXdpdGgtcHJvdmlkZXJzJztcbmltcG9ydCB7IE1vY2sgfSBmcm9tICcuLi9jb21tb24vbW9jayc7XG5pbXBvcnQgbmdNb2Nrc1VuaXZlcnNlIGZyb20gJy4uL2NvbW1vbi9uZy1tb2Nrcy11bml2ZXJzZSc7XG5cbmltcG9ydCBtb2NrTmdEZWYgZnJvbSAnLi9tb2NrLW5nLWRlZic7XG5cbmNvbnN0IGZsYWdNb2NrID0gKHJlc29sdXRpb24/OiBzdHJpbmcpOiBib29sZWFuID0+IHJlc29sdXRpb24gPT09ICdtb2NrJyAmJiBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpO1xuXG5jb25zdCBmbGFnS2VlcCA9IChyZXNvbHV0aW9uPzogc3RyaW5nKTogYm9vbGVhbiA9PiByZXNvbHV0aW9uID09PSAna2VlcCcgJiYgIW5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJyk7XG5cbmNvbnN0IGZsYWdSZXBsYWNlID0gKHJlc29sdXRpb24/OiBzdHJpbmcpOiBib29sZWFuID0+XG4gIHJlc29sdXRpb24gPT09ICdyZXBsYWNlJyAmJiAhbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKTtcblxuY29uc3QgZmxhZ05ldmVyID0gKG5nTW9kdWxlPzogYW55KTogYm9vbGVhbiA9PlxuICBjb3JlQ29uZmlnLm5ldmVyTW9ja01vZHVsZS5pbmRleE9mKG5nTW9kdWxlLm5hbWUpICE9PSAtMSAmJiAhbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKTtcblxuY29uc3QgcHJlcHJvY2Vzc1RvZ2dsZUZsYWcgPSAobmdNb2R1bGU6IFR5cGU8YW55Pik6IGJvb2xlYW4gPT4ge1xuICBsZXQgdG9nZ2xlU2tpcE1vY2tGbGFnID0gZmFsc2U7XG5cbiAgY29uc3QgcmVzb2x1dGlvbiA9IG5nTW9ja3NVbml2ZXJzZS5nZXRSZXNvbHV0aW9uKG5nTW9kdWxlKTtcbiAgaWYgKGZsYWdNb2NrKHJlc29sdXRpb24pKSB7XG4gICAgdG9nZ2xlU2tpcE1vY2tGbGFnID0gdHJ1ZTtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuZGVsZXRlKCdza2lwTW9jaycpO1xuICB9XG4gIGlmIChmbGFnS2VlcChyZXNvbHV0aW9uKSB8fCBmbGFnUmVwbGFjZShyZXNvbHV0aW9uKSB8fCBmbGFnTmV2ZXIobmdNb2R1bGUpKSB7XG4gICAgdG9nZ2xlU2tpcE1vY2tGbGFnID0gdHJ1ZTtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuYWRkKCdza2lwTW9jaycpO1xuICB9XG5cbiAgcmV0dXJuIHRvZ2dsZVNraXBNb2NrRmxhZztcbn07XG5cbmNvbnN0IHBvc3Rwcm9jZXNzVG9nZ2xlRmxhZyA9ICh0b2dnbGVTa2lwTW9ja0ZsYWc6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgaWYgKHRvZ2dsZVNraXBNb2NrRmxhZyAmJiBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdza2lwTW9jaycpKSB7XG4gICAgbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmRlbGV0ZSgnc2tpcE1vY2snKTtcbiAgfSBlbHNlIGlmICh0b2dnbGVTa2lwTW9ja0ZsYWcgJiYgIW5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJykpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuYWRkKCdza2lwTW9jaycpO1xuICB9XG59O1xuXG5jb25zdCBleHRyYWN0TW9kdWxlQW5kUHJvdmlkZXJzID0gKFxuICBtb2R1bGU6IGFueSxcbik6IHtcbiAgbmdNb2R1bGU6IFR5cGU8YW55PjtcbiAgbmdNb2R1bGVQcm92aWRlcnM6IFByb3ZpZGVyW10gfCB1bmRlZmluZWQ7XG59ID0+IHtcbiAgbGV0IG5nTW9kdWxlOiBUeXBlPGFueT47XG4gIGxldCBuZ01vZHVsZVByb3ZpZGVyczogUHJvdmlkZXJbXSB8IHVuZGVmaW5lZDtcblxuICBpZiAoaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMobW9kdWxlKSkge1xuICAgIG5nTW9kdWxlID0gbW9kdWxlLm5nTW9kdWxlO1xuICAgIGlmIChtb2R1bGUucHJvdmlkZXJzKSB7XG4gICAgICBuZ01vZHVsZVByb3ZpZGVycyA9IG1vZHVsZS5wcm92aWRlcnM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5nTW9kdWxlID0gbW9kdWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZ01vZHVsZSxcbiAgICBuZ01vZHVsZVByb3ZpZGVycyxcbiAgfTtcbn07XG5cbmNvbnN0IGdldEV4aXN0aW5nTW9ja01vZHVsZSA9IChuZ01vZHVsZTogVHlwZTxhbnk+KTogVHlwZTxhbnk+IHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKGlzTW9ja05nRGVmKG5nTW9kdWxlLCAnbScpKSB7XG4gICAgcmV0dXJuIG5nTW9kdWxlO1xuICB9XG5cbiAgLy8gRXZlcnkgbW9kdWxlIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGl0cyBtb2NrIGNvcHkgb25seSBvbmNlIHRvIGF2b2lkIGVycm9ycyBsaWtlOlxuICAvLyBGYWlsZWQ6IFR5cGUgLi4uQ29tcG9uZW50IGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IC4uLk1vZHVsZSBhbmQgLi4uTW9kdWxlLi4uXG4gIGlmIChuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdjYWNoZU1vZHVsZScpICYmIG5nTW9ja3NVbml2ZXJzZS5jYWNoZURlY2xhcmF0aW9ucy5oYXMobmdNb2R1bGUpKSB7XG4gICAgcmV0dXJuIG5nTW9ja3NVbml2ZXJzZS5jYWNoZURlY2xhcmF0aW9ucy5nZXQobmdNb2R1bGUpO1xuICB9XG5cbiAgLy8gTm93IHdlIGNoZWNrIGlmIHdlIG5lZWQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgbW9kdWxlIG9yIHRvIHJlcGxhY2UgaXQgd2l0aCBzb21lIG90aGVyLlxuICBpZiAobmdNb2Nrc1VuaXZlcnNlLmhhc0J1aWxkRGVjbGFyYXRpb24obmdNb2R1bGUpKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZ01vY2tzVW5pdmVyc2UuZ2V0QnVpbGREZWNsYXJhdGlvbihuZ01vZHVsZSk7XG4gICAgaWYgKGlzTmdEZWYoaW5zdGFuY2UsICdtJykgJiYgaW5zdGFuY2UgIT09IG5nTW9kdWxlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IGdldE1vY2tNb2R1bGVEZWYgPSAobmdNb2R1bGU6IFR5cGU8YW55PiwgbW9ja01vZHVsZT86IFR5cGU8YW55Pik6IE5nTW9kdWxlIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKCFtb2NrTW9kdWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IGNvcmVSZWZsZWN0TW9kdWxlUmVzb2x2ZShuZ01vZHVsZSk7XG4gICAgY29uc3QgW2NoYW5nZWQsIG5nTW9kdWxlRGVmXSA9IG1vY2tOZ0RlZihtZXRhLCBuZ01vZHVsZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHJldHVybiBuZ01vZHVsZURlZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgZGV0ZWN0TW9ja01vZHVsZSA9IChuZ01vZHVsZTogVHlwZTxhbnk+LCBtb2NrTW9kdWxlPzogVHlwZTxhbnk+KTogVHlwZTxhbnk+ID0+IHtcbiAgY29uc3QgbW9ja01vZHVsZURlZiA9IGdldE1vY2tNb2R1bGVEZWYobmdNb2R1bGUsIG1vY2tNb2R1bGUpO1xuXG4gIGlmIChtb2NrTW9kdWxlRGVmKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKSA/IG5nTW9kdWxlIDogTW9jaztcbiAgICBjb25zdCBtb2NrID0gZXh0ZW5kQ2xhc3MocGFyZW50KTtcblxuICAgIC8vIHRoZSBsYXN0IHRoaW5nIGlzIHRvIGFwcGx5IGRlY29yYXRvcnMuXG4gICAgTmdNb2R1bGUobW9ja01vZHVsZURlZikobW9jayk7XG4gICAgZGVjb3JhdGVNb2NrKG1vY2ssIG5nTW9kdWxlKTtcblxuICAgIHJldHVybiBtb2NrO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tNb2R1bGUgfHwgbmdNb2R1bGU7XG59O1xuXG5jb25zdCBnZXRNb2NrUHJvdmlkZXJzID0gKG5nTW9kdWxlUHJvdmlkZXJzOiBQcm92aWRlcltdIHwgdW5kZWZpbmVkKTogUHJvdmlkZXJbXSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChuZ01vZHVsZVByb3ZpZGVycykge1xuICAgIGNvbnN0IFtjaGFuZ2VkLCBuZ01vZHVsZURlZl0gPSBtb2NrTmdEZWYoeyBwcm92aWRlcnM6IG5nTW9kdWxlUHJvdmlkZXJzIH0pO1xuXG4gICAgcmV0dXJuIGNoYW5nZWQgPyBuZ01vZHVsZURlZi5wcm92aWRlcnMgOiBuZ01vZHVsZVByb3ZpZGVycztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVJldHVybiA9IChcbiAgbW9kdWxlOiBhbnksXG4gIG5nTW9kdWxlOiBUeXBlPGFueT4sXG4gIG5nTW9kdWxlUHJvdmlkZXJzOiBQcm92aWRlcltdIHwgdW5kZWZpbmVkLFxuICBtb2NrTW9kdWxlOiBUeXBlPGFueT4sXG4gIG1vY2tNb2R1bGVQcm92aWRlcnM6IFByb3ZpZGVyW10gfCB1bmRlZmluZWQsXG4pOiBhbnkgPT5cbiAgbW9ja01vZHVsZSA9PT0gbmdNb2R1bGUgJiYgbW9ja01vZHVsZVByb3ZpZGVycyA9PT0gbmdNb2R1bGVQcm92aWRlcnNcbiAgICA/IG1vZHVsZVxuICAgIDogaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMobW9kdWxlKVxuICAgID8geyBuZ01vZHVsZTogbW9ja01vZHVsZSwgLi4uKG1vY2tNb2R1bGVQcm92aWRlcnMgPyB7IHByb3ZpZGVyczogbW9ja01vZHVsZVByb3ZpZGVycyB9IDoge30pIH1cbiAgICA6IG1vY2tNb2R1bGU7XG5cbi8qKlxuICogQHNlZSBodHRwczovL25nLW1vY2tzLnN1ZG8uZXUvYXBpL01vY2tNb2R1bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vY2tNb2R1bGU8VD4obW9kdWxlOiBUeXBlPFQ+KTogVHlwZTxUPjtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja01vZHVsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTW9ja01vZHVsZTxUPihtb2R1bGU6IE5nTW9kdWxlV2l0aFByb3ZpZGVyczxUPik6IE5nTW9kdWxlV2l0aFByb3ZpZGVyczxUPjtcblxuZXhwb3J0IGZ1bmN0aW9uIE1vY2tNb2R1bGUobW9kdWxlOiBhbnkpOiBhbnkge1xuICBmdW5jSW1wb3J0RXhpc3RzKG1vZHVsZSwgJ01vY2tNb2R1bGUnKTtcblxuICBjb25zdCB7IG5nTW9kdWxlLCBuZ01vZHVsZVByb3ZpZGVycyB9ID0gZXh0cmFjdE1vZHVsZUFuZFByb3ZpZGVycyhtb2R1bGUpO1xuXG4gIC8vIFdlIGFyZSBpbnNpZGUgb2YgYW4gJ2l0Jy4gSXQgaXMgZmluZSB0byB0byByZXR1cm4gYSBtb2NrIGNvcHkuXG4gIGlmICghbmdNb2R1bGVQcm92aWRlcnMgJiYgKGdldFRlc3RCZWQoKSBhcyBhbnkpLl9pbnN0YW50aWF0ZWQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdldE1vY2tlZE5nRGVmT2YobmdNb2R1bGUsICdtJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGxvb2tzIGxpa2UgYW4gaW4tdGVzdCBtb2NrLlxuICAgIH1cbiAgfVxuICBjb25zdCB0b2dnbGVTa2lwTW9ja0ZsYWcgPSBwcmVwcm9jZXNzVG9nZ2xlRmxhZyhuZ01vZHVsZSk7XG4gIGNvbnN0IG1vY2tNb2R1bGUgPSBkZXRlY3RNb2NrTW9kdWxlKG5nTW9kdWxlLCBnZXRFeGlzdGluZ01vY2tNb2R1bGUobmdNb2R1bGUpKTtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgaWYgKG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ2NhY2hlTW9kdWxlJykpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuY2FjaGVEZWNsYXJhdGlvbnMuc2V0KG5nTW9kdWxlLCBtb2NrTW9kdWxlKTtcbiAgfVxuICBpZiAobmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKSkge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWcuZ2V0KCduZ01vY2tzRGVwc1NraXAnKT8uYWRkKG1vY2tNb2R1bGUpO1xuICB9XG4gIGNvbnN0IG1vY2tNb2R1bGVQcm92aWRlcnMgPSBnZXRNb2NrUHJvdmlkZXJzKG5nTW9kdWxlUHJvdmlkZXJzKTtcbiAgcG9zdHByb2Nlc3NUb2dnbGVGbGFnKHRvZ2dsZVNraXBNb2NrRmxhZyk7XG5cbiAgcmV0dXJuIGdlbmVyYXRlUmV0dXJuKG1vZHVsZSwgbmdNb2R1bGUsIG5nTW9kdWxlUHJvdmlkZXJzLCBtb2NrTW9kdWxlLCBtb2NrTW9kdWxlUHJvdmlkZXJzKTtcbn1cbiJdfQ==