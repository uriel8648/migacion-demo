"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var func_is_ng_def_1 = require("../common/func.is-ng-def");
var func_is_ng_module_def_with_providers_1 = require("../common/func.is-ng-module-def-with-providers");
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var mock_component_1 = require("../mock-component/mock-component");
var mock_directive_1 = require("../mock-directive/mock-directive");
var mock_pipe_1 = require("../mock-pipe/mock-pipe");
var helper_mock_service_1 = __importDefault(require("../mock-service/helper.mock-service"));
var mock_module_1 = require("./mock-module");
// tslint:disable-next-line variable-name
var BrowserAnimationsModule;
// tslint:disable-next-line variable-name
var NoopAnimationsModule;
// istanbul ignore next
var replaceWithNoop = function () { return false; };
try {
    // tslint:disable-next-line no-require-imports no-var-requires
    var imports = require('@angular/platform-browser/animations');
    BrowserAnimationsModule = imports.BrowserAnimationsModule;
    NoopAnimationsModule = imports.NoopAnimationsModule;
    replaceWithNoop = function (def) {
        return def === BrowserAnimationsModule &&
            !!BrowserAnimationsModule &&
            !!NoopAnimationsModule &&
            !ng_mocks_universe_1.default.getResolution(def);
    };
}
catch (_a) {
    // nothing to do
}
var processDefMap = [
    ['c', mock_component_1.MockComponent],
    ['d', mock_directive_1.MockDirective],
    ['p', mock_pipe_1.MockPipe],
];
var processDef = function (def) {
    var e_1, _a;
    // BrowserAnimationsModule is a very special case.
    // If it is not resolved manually, we simply replace it with NoopAnimationsModule.
    if (replaceWithNoop(def)) {
        return NoopAnimationsModule;
    }
    if ((0, func_is_ng_def_1.isNgDef)(def, 'm') || (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(def)) {
        return (0, mock_module_1.MockModule)(def);
    }
    if (ng_mocks_universe_1.default.hasBuildDeclaration(def)) {
        return ng_mocks_universe_1.default.getBuildDeclaration(def);
    }
    if (ng_mocks_universe_1.default.flags.has('skipMock') && ng_mocks_universe_1.default.getResolution(def) !== 'mock') {
        return def;
    }
    try {
        for (var processDefMap_1 = __values(processDefMap), processDefMap_1_1 = processDefMap_1.next(); !processDefMap_1_1.done; processDefMap_1_1 = processDefMap_1.next()) {
            var _b = __read(processDefMap_1_1.value, 2), flag = _b[0], func = _b[1];
            if ((0, func_is_ng_def_1.isNgDef)(def, flag)) {
                return func(def);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (processDefMap_1_1 && !processDefMap_1_1.done && (_a = processDefMap_1.return)) _a.call(processDefMap_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
// resolveProvider is a special case because of the def structure.
var createResolveProvider = function (resolutions, change) {
    return function (def) {
        return helper_mock_service_1.default.resolveProvider(def, resolutions, change);
    };
};
var createResolveWithProviders = function (def, mockDef) {
    return mockDef && mockDef.ngModule && (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(def);
};
var createResolveExisting = function (def, resolutions, change) {
    var mockDef = resolutions.get(def);
    if (def !== mockDef) {
        change();
    }
    return mockDef;
};
var createResolveExcluded = function (def, resolutions, change) {
    resolutions.set(def, undefined);
    change();
};
var createResolve = function (resolutions, change) {
    return function (def) {
        var _a;
        if (resolutions.has(def)) {
            return createResolveExisting(def, resolutions, change);
        }
        var detectedDef = (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(def) ? def.ngModule : def;
        if (ng_mocks_universe_1.default.isExcludedDef(detectedDef)) {
            return createResolveExcluded(def, resolutions, change);
        }
        ng_mocks_universe_1.default.touches.add(detectedDef);
        var mockDef = processDef(def);
        if (createResolveWithProviders(def, mockDef)) {
            resolutions.set(def.ngModule, mockDef.ngModule);
        }
        if (ng_mocks_universe_1.default.flags.has('skipMock')) {
            (_a = ng_mocks_universe_1.default.config.get('ngMocksDepsSkip')) === null || _a === void 0 ? void 0 : _a.add(mockDef);
        }
        resolutions.set(def, mockDef);
        change(mockDef !== def);
        return mockDef;
    };
};
exports.default = (function (change, resolutions) {
    var resolve = createResolve(resolutions, change);
    var resolveProvider = createResolveProvider(resolutions, change);
    return {
        resolve: resolve,
        resolveProvider: resolveProvider,
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLXJlc29sdmVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9tb2NrLW1vZHVsZS9jcmVhdGUtcmVzb2x2ZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsMkRBQW1EO0FBQ25ELHVHQUE0RjtBQUM1RixrRkFBMEQ7QUFDMUQsbUVBQWlFO0FBQ2pFLG1FQUFpRTtBQUNqRSxvREFBa0Q7QUFDbEQsNEZBQW9FO0FBRXBFLDZDQUEyQztBQUUzQyx5Q0FBeUM7QUFDekMsSUFBSSx1QkFBNEIsQ0FBQztBQUNqQyx5Q0FBeUM7QUFDekMsSUFBSSxvQkFBeUIsQ0FBQztBQUM5Qix1QkFBdUI7QUFDdkIsSUFBSSxlQUFlLEdBQTBCLGNBQU0sT0FBQSxLQUFLLEVBQUwsQ0FBSyxDQUFDO0FBQ3pELElBQUk7SUFDRiw4REFBOEQ7SUFDOUQsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7SUFDaEUsdUJBQXVCLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0lBQzFELG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztJQUNwRCxlQUFlLEdBQUcsVUFBQyxHQUFRO1FBQ3pCLE9BQUEsR0FBRyxLQUFLLHVCQUF1QjtZQUMvQixDQUFDLENBQUMsdUJBQXVCO1lBQ3pCLENBQUMsQ0FBQyxvQkFBb0I7WUFDdEIsQ0FBQywyQkFBZSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUM7SUFIbkMsQ0FHbUMsQ0FBQztDQUN2QztBQUFDLFdBQU07SUFDTixnQkFBZ0I7Q0FDakI7QUFFRCxJQUFNLGFBQWEsR0FBc0I7SUFDdkMsQ0FBQyxHQUFHLEVBQUUsOEJBQWEsQ0FBQztJQUNwQixDQUFDLEdBQUcsRUFBRSw4QkFBYSxDQUFDO0lBQ3BCLENBQUMsR0FBRyxFQUFFLG9CQUFRLENBQUM7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O1FBRXpDLElBQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoQyxJQUFJLDBCQUEwQixDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsRUFBRTtZQUM1QyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsSUFBSSwyQkFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDekMsTUFBQSwyQkFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsMENBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDOUIsTUFBTSxDQUFDLE9BQU8sS0FBSyxHQUFHLENBQUMsQ0FBQztRQUV4QixPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0FBdEJELENBc0JDLENBQUM7QUFFSixtQkFBZSxVQUNiLE1BQWtCLEVBQ2xCLFdBQTBCO0lBSzFCLElBQU0sT0FBTyxHQUFHLGFBQWEsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDbkQsSUFBTSxlQUFlLEdBQUcscUJBQXFCLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRW5FLE9BQU87UUFDTCxPQUFPLFNBQUE7UUFDUCxlQUFlLGlCQUFBO0tBQ2hCLENBQUM7QUFDSixDQUFDLEVBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBpc05nRGVmIH0gZnJvbSAnLi4vY29tbW9uL2Z1bmMuaXMtbmctZGVmJztcbmltcG9ydCB7IGlzTmdNb2R1bGVEZWZXaXRoUHJvdmlkZXJzIH0gZnJvbSAnLi4vY29tbW9uL2Z1bmMuaXMtbmctbW9kdWxlLWRlZi13aXRoLXByb3ZpZGVycyc7XG5pbXBvcnQgbmdNb2Nrc1VuaXZlcnNlIGZyb20gJy4uL2NvbW1vbi9uZy1tb2Nrcy11bml2ZXJzZSc7XG5pbXBvcnQgeyBNb2NrQ29tcG9uZW50IH0gZnJvbSAnLi4vbW9jay1jb21wb25lbnQvbW9jay1jb21wb25lbnQnO1xuaW1wb3J0IHsgTW9ja0RpcmVjdGl2ZSB9IGZyb20gJy4uL21vY2stZGlyZWN0aXZlL21vY2stZGlyZWN0aXZlJztcbmltcG9ydCB7IE1vY2tQaXBlIH0gZnJvbSAnLi4vbW9jay1waXBlL21vY2stcGlwZSc7XG5pbXBvcnQgaGVscGVyTW9ja1NlcnZpY2UgZnJvbSAnLi4vbW9jay1zZXJ2aWNlL2hlbHBlci5tb2NrLXNlcnZpY2UnO1xuXG5pbXBvcnQgeyBNb2NrTW9kdWxlIH0gZnJvbSAnLi9tb2NrLW1vZHVsZSc7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSB2YXJpYWJsZS1uYW1lXG5sZXQgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGU6IGFueTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSB2YXJpYWJsZS1uYW1lXG5sZXQgTm9vcEFuaW1hdGlvbnNNb2R1bGU6IGFueTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5sZXQgcmVwbGFjZVdpdGhOb29wOiAoZGVmOiBhbnkpID0+IGJvb2xlYW4gPSAoKSA9PiBmYWxzZTtcbnRyeSB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1yZXF1aXJlLWltcG9ydHMgbm8tdmFyLXJlcXVpcmVzXG4gIGNvbnN0IGltcG9ydHMgPSByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnKTtcbiAgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUgPSBpbXBvcnRzLkJyb3dzZXJBbmltYXRpb25zTW9kdWxlO1xuICBOb29wQW5pbWF0aW9uc01vZHVsZSA9IGltcG9ydHMuTm9vcEFuaW1hdGlvbnNNb2R1bGU7XG4gIHJlcGxhY2VXaXRoTm9vcCA9IChkZWY6IGFueSkgPT5cbiAgICBkZWYgPT09IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlICYmXG4gICAgISFCcm93c2VyQW5pbWF0aW9uc01vZHVsZSAmJlxuICAgICEhTm9vcEFuaW1hdGlvbnNNb2R1bGUgJiZcbiAgICAhbmdNb2Nrc1VuaXZlcnNlLmdldFJlc29sdXRpb24oZGVmKTtcbn0gY2F0Y2gge1xuICAvLyBub3RoaW5nIHRvIGRvXG59XG5cbmNvbnN0IHByb2Nlc3NEZWZNYXA6IEFycmF5PFthbnksIGFueV0+ID0gW1xuICBbJ2MnLCBNb2NrQ29tcG9uZW50XSxcbiAgWydkJywgTW9ja0RpcmVjdGl2ZV0sXG4gIFsncCcsIE1vY2tQaXBlXSxcbl07XG5cbmNvbnN0IHByb2Nlc3NEZWYgPSAoZGVmOiBhbnkpID0+IHtcbiAgLy8gQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZS5cbiAgLy8gSWYgaXQgaXMgbm90IHJlc29sdmVkIG1hbnVhbGx5LCB3ZSBzaW1wbHkgcmVwbGFjZSBpdCB3aXRoIE5vb3BBbmltYXRpb25zTW9kdWxlLlxuICBpZiAocmVwbGFjZVdpdGhOb29wKGRlZikpIHtcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvbnNNb2R1bGU7XG4gIH1cblxuICBpZiAoaXNOZ0RlZihkZWYsICdtJykgfHwgaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMoZGVmKSkge1xuICAgIHJldHVybiBNb2NrTW9kdWxlKGRlZiBhcyBhbnkpO1xuICB9XG4gIGlmIChuZ01vY2tzVW5pdmVyc2UuaGFzQnVpbGREZWNsYXJhdGlvbihkZWYpKSB7XG4gICAgcmV0dXJuIG5nTW9ja3NVbml2ZXJzZS5nZXRCdWlsZERlY2xhcmF0aW9uKGRlZik7XG4gIH1cbiAgaWYgKG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJykgJiYgbmdNb2Nrc1VuaXZlcnNlLmdldFJlc29sdXRpb24oZGVmKSAhPT0gJ21vY2snKSB7XG4gICAgcmV0dXJuIGRlZjtcbiAgfVxuICBmb3IgKGNvbnN0IFtmbGFnLCBmdW5jXSBvZiBwcm9jZXNzRGVmTWFwKSB7XG4gICAgaWYgKGlzTmdEZWYoZGVmLCBmbGFnKSkge1xuICAgICAgcmV0dXJuIGZ1bmMoZGVmKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHJlc29sdmVQcm92aWRlciBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIG9mIHRoZSBkZWYgc3RydWN0dXJlLlxuY29uc3QgY3JlYXRlUmVzb2x2ZVByb3ZpZGVyID1cbiAgKHJlc29sdXRpb25zOiBNYXA8YW55LCBhbnk+LCBjaGFuZ2U6ICgpID0+IHZvaWQpOiAoKGRlZjogUHJvdmlkZXIpID0+IGFueSkgPT5cbiAgKGRlZjogUHJvdmlkZXIpID0+XG4gICAgaGVscGVyTW9ja1NlcnZpY2UucmVzb2x2ZVByb3ZpZGVyKGRlZiwgcmVzb2x1dGlvbnMsIGNoYW5nZSk7XG5cbmNvbnN0IGNyZWF0ZVJlc29sdmVXaXRoUHJvdmlkZXJzID0gKGRlZjogYW55LCBtb2NrRGVmOiBhbnkpOiBib29sZWFuID0+XG4gIG1vY2tEZWYgJiYgbW9ja0RlZi5uZ01vZHVsZSAmJiBpc05nTW9kdWxlRGVmV2l0aFByb3ZpZGVycyhkZWYpO1xuXG5jb25zdCBjcmVhdGVSZXNvbHZlRXhpc3RpbmcgPSAoZGVmOiBhbnksIHJlc29sdXRpb25zOiBNYXA8YW55LCBhbnk+LCBjaGFuZ2U6IChmbGFnPzogYm9vbGVhbikgPT4gdm9pZCk6IGFueSA9PiB7XG4gIGNvbnN0IG1vY2tEZWYgPSByZXNvbHV0aW9ucy5nZXQoZGVmKTtcbiAgaWYgKGRlZiAhPT0gbW9ja0RlZikge1xuICAgIGNoYW5nZSgpO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tEZWY7XG59O1xuXG5jb25zdCBjcmVhdGVSZXNvbHZlRXhjbHVkZWQgPSAoZGVmOiBhbnksIHJlc29sdXRpb25zOiBNYXA8YW55LCBhbnk+LCBjaGFuZ2U6IChmbGFnPzogYm9vbGVhbikgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICByZXNvbHV0aW9ucy5zZXQoZGVmLCB1bmRlZmluZWQpO1xuXG4gIGNoYW5nZSgpO1xufTtcblxuY29uc3QgY3JlYXRlUmVzb2x2ZSA9XG4gIChyZXNvbHV0aW9uczogTWFwPGFueSwgYW55PiwgY2hhbmdlOiAoZmxhZz86IGJvb2xlYW4pID0+IHZvaWQpOiAoKGRlZjogYW55KSA9PiBhbnkpID0+XG4gIChkZWY6IGFueSkgPT4ge1xuICAgIGlmIChyZXNvbHV0aW9ucy5oYXMoZGVmKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc29sdmVFeGlzdGluZyhkZWYsIHJlc29sdXRpb25zLCBjaGFuZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGRldGVjdGVkRGVmID0gaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMoZGVmKSA/IGRlZi5uZ01vZHVsZSA6IGRlZjtcbiAgICBpZiAobmdNb2Nrc1VuaXZlcnNlLmlzRXhjbHVkZWREZWYoZGV0ZWN0ZWREZWYpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVzb2x2ZUV4Y2x1ZGVkKGRlZiwgcmVzb2x1dGlvbnMsIGNoYW5nZSk7XG4gICAgfVxuICAgIG5nTW9ja3NVbml2ZXJzZS50b3VjaGVzLmFkZChkZXRlY3RlZERlZik7XG5cbiAgICBjb25zdCBtb2NrRGVmID0gcHJvY2Vzc0RlZihkZWYpO1xuICAgIGlmIChjcmVhdGVSZXNvbHZlV2l0aFByb3ZpZGVycyhkZWYsIG1vY2tEZWYpKSB7XG4gICAgICByZXNvbHV0aW9ucy5zZXQoZGVmLm5nTW9kdWxlLCBtb2NrRGVmLm5nTW9kdWxlKTtcbiAgICB9XG4gICAgaWYgKG5nTW9ja3NVbml2ZXJzZS5mbGFncy5oYXMoJ3NraXBNb2NrJykpIHtcbiAgICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWcuZ2V0KCduZ01vY2tzRGVwc1NraXAnKT8uYWRkKG1vY2tEZWYpO1xuICAgIH1cbiAgICByZXNvbHV0aW9ucy5zZXQoZGVmLCBtb2NrRGVmKTtcbiAgICBjaGFuZ2UobW9ja0RlZiAhPT0gZGVmKTtcblxuICAgIHJldHVybiBtb2NrRGVmO1xuICB9O1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGNoYW5nZTogKCkgPT4gdm9pZCxcbiAgcmVzb2x1dGlvbnM6IE1hcDxhbnksIGFueT4sXG4pOiB7XG4gIHJlc29sdmU6IChkZWY6IGFueSkgPT4gYW55O1xuICByZXNvbHZlUHJvdmlkZXI6IChkZWY6IFByb3ZpZGVyKSA9PiBhbnk7XG59ID0+IHtcbiAgY29uc3QgcmVzb2x2ZSA9IGNyZWF0ZVJlc29sdmUocmVzb2x1dGlvbnMsIGNoYW5nZSk7XG4gIGNvbnN0IHJlc29sdmVQcm92aWRlciA9IGNyZWF0ZVJlc29sdmVQcm92aWRlcihyZXNvbHV0aW9ucywgY2hhbmdlKTtcblxuICByZXR1cm4ge1xuICAgIHJlc29sdmUsXG4gICAgcmVzb2x2ZVByb3ZpZGVyLFxuICB9O1xufTtcbiJdfQ==