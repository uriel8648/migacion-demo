"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_helpers_1 = require("../common/core.helpers");
var func_is_ng_module_def_with_providers_1 = require("../common/func.is-ng-module-def-with-providers");
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var create_resolvers_1 = __importDefault(require("./create-resolvers"));
var mark_providers_1 = __importDefault(require("./mark-providers"));
var flatToExisting = function (data, callback) {
    return (0, core_helpers_1.flatten)(data)
        .map(callback)
        .filter(function (item) { return !!item; });
};
var configureProcessMetaKeys = function (resolve, resolveProvider) { return [
    ['declarations', resolve],
    ['entryComponents', resolve],
    ['bootstrap', resolve],
    ['providers', resolveProvider],
    ['imports', resolve],
    ['exports', resolve],
]; };
var processMeta = function (ngModule, resolve, resolveProvider) {
    var e_1, _a;
    var _b;
    var mockModuleDef = {};
    var keys = configureProcessMetaKeys(resolve, resolveProvider);
    var cachePipe = ng_mocks_universe_1.default.flags.has('cachePipe');
    if (!cachePipe) {
        ng_mocks_universe_1.default.flags.add('cachePipe');
    }
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var _c = __read(keys_1_1.value, 2), key = _c[0], callback = _c[1];
            if ((_b = ngModule[key]) === null || _b === void 0 ? void 0 : _b.length) {
                mockModuleDef[key] = flatToExisting(ngModule[key], callback);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    (0, mark_providers_1.default)(mockModuleDef.providers);
    if (!cachePipe) {
        ng_mocks_universe_1.default.flags.delete('cachePipe');
    }
    return mockModuleDef;
};
var resolveDefForExport = function (def, resolve, correctExports, ngModule) {
    var moduleConfig = ng_mocks_universe_1.default.config.get(ngModule) || {};
    var instance = (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(def) ? def.ngModule : def;
    var mockDef = resolve(instance);
    if (!mockDef) {
        return undefined;
    }
    // If we export a declaration, then we have to export its module too.
    var config = ng_mocks_universe_1.default.config.get(instance);
    if ((config === null || config === void 0 ? void 0 : config.export) && ngModule) {
        if (!moduleConfig.export) {
            ng_mocks_universe_1.default.config.set(ngModule, __assign(__assign({}, moduleConfig), { export: true }));
        }
    }
    if (correctExports && !moduleConfig.exportAll && !(config === null || config === void 0 ? void 0 : config.export)) {
        return undefined;
    }
    return mockDef;
};
var skipAddExports = function (mockDef, mockModuleDef) {
    return !mockDef || (!!mockModuleDef.exports && mockModuleDef.exports.indexOf(mockDef) !== -1);
};
// if we are in the skipMock mode we need to export only the default exports.
// if we are in the correctModuleExports mode we need to export only default exports.
var addExports = function (resolve, change, ngModuleDef, mockModuleDef, ngModule) {
    var e_2, _a;
    var correctExports = ng_mocks_universe_1.default.flags.has('skipMock') || ng_mocks_universe_1.default.flags.has('correctModuleExports');
    try {
        for (var _b = __values((0, core_helpers_1.flatten)([ngModuleDef.imports || [], ngModuleDef.declarations || []])), _c = _b.next(); !_c.done; _c = _b.next()) {
            var def = _c.value;
            var mockDef = resolveDefForExport(def, resolve, correctExports, ngModule);
            if (skipAddExports(mockDef, mockModuleDef)) {
                continue;
            }
            change();
            mockModuleDef.exports = mockModuleDef.exports || [];
            mockModuleDef.exports.push(mockDef);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
};
exports.default = (function (ngModuleDef, ngModule) {
    var hasResolver = ng_mocks_universe_1.default.config.has('mockNgDefResolver');
    if (!hasResolver) {
        ng_mocks_universe_1.default.config.set('mockNgDefResolver', new Map());
    }
    var changed = !ng_mocks_universe_1.default.flags.has('skipMock');
    var change = function (flag) {
        if (flag === void 0) { flag = true; }
        changed = changed || flag;
    };
    var _a = (0, create_resolvers_1.default)(change, ng_mocks_universe_1.default.config.get('mockNgDefResolver')), resolve = _a.resolve, resolveProvider = _a.resolveProvider;
    var mockModuleDef = processMeta(ngModuleDef, resolve, resolveProvider);
    addExports(resolve, change, ngModuleDef, mockModuleDef, ngModule);
    if (!hasResolver) {
        ng_mocks_universe_1.default.config.delete('mockNgDefResolver');
    }
    return [changed, mockModuleDef];
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1uZy1kZWYuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1tb2R1bGUvbW9jay1uZy1kZWYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHVEQUFpRDtBQUVqRCx1R0FBNEY7QUFDNUYsa0ZBQTBEO0FBRTFELHdFQUFpRDtBQUNqRCxvRUFBNkM7QUFFN0MsSUFBTSxjQUFjLEdBQUcsVUFBTyxJQUFhLEVBQUUsUUFBbUM7SUFDOUUsT0FBQSxJQUFBLHNCQUFPLEVBQUMsSUFBSSxDQUFDO1NBQ1YsR0FBRyxDQUFDLFFBQVEsQ0FBQztTQUNiLE1BQU0sQ0FBQyxVQUFDLElBQUksSUFBZ0IsT0FBQSxDQUFDLENBQUMsSUFBSSxFQUFOLENBQU0sQ0FBQztBQUZ0QyxDQUVzQyxDQUFDO0FBSXpDLElBQU0sd0JBQXdCLEdBQUcsVUFDL0IsT0FBMEIsRUFDMUIsZUFBdUMsSUFDSyxPQUFBO0lBQzVDLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQztJQUN6QixDQUFDLGlCQUFpQixFQUFFLE9BQU8sQ0FBQztJQUM1QixDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7SUFDdEIsQ0FBQyxXQUFXLEVBQUUsZUFBZSxDQUFDO0lBQzlCLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQztJQUNwQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUM7Q0FDckIsRUFQNkMsQ0FPN0MsQ0FBQztBQUVGLElBQU0sV0FBVyxHQUFHLFVBQ2xCLFFBQWtCLEVBQ2xCLE9BQTBCLEVBQzFCLGVBQXVDOzs7SUFFdkMsSUFBTSxhQUFhLEdBQWEsRUFBRSxDQUFDO0lBQ25DLElBQU0sSUFBSSxHQUFHLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztJQUVoRSxJQUFNLFNBQVMsR0FBRywyQkFBZSxDQUFDLEtB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RyxXQUFXLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztJQUN6RSxVQUFVLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRWxFLElBQUksQ0FBQyxXQUFXLEVBQUU7UUFDaEIsMkJBQWUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUM7S0FDcEQ7SUFFRCxPQUFPLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQ2xDLENBQUMsRUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlLCBQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUuaGVscGVycyc7XG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IHsgaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMgfSBmcm9tICcuLi9jb21tb24vZnVuYy5pcy1uZy1tb2R1bGUtZGVmLXdpdGgtcHJvdmlkZXJzJztcbmltcG9ydCBuZ01vY2tzVW5pdmVyc2UgZnJvbSAnLi4vY29tbW9uL25nLW1vY2tzLXVuaXZlcnNlJztcblxuaW1wb3J0IGNyZWF0ZVJlc29sdmVycyBmcm9tICcuL2NyZWF0ZS1yZXNvbHZlcnMnO1xuaW1wb3J0IG1hcmtQcm92aWRlcnMgZnJvbSAnLi9tYXJrLXByb3ZpZGVycyc7XG5cbmNvbnN0IGZsYXRUb0V4aXN0aW5nID0gPFQsIFI+KGRhdGE6IFQgfCBUW10sIGNhbGxiYWNrOiAoYXJnOiBUKSA9PiBSIHwgdW5kZWZpbmVkKTogUltdID0+XG4gIGZsYXR0ZW4oZGF0YSlcbiAgICAubWFwKGNhbGxiYWNrKVxuICAgIC5maWx0ZXIoKGl0ZW0pOiBpdGVtIGlzIFIgPT4gISFpdGVtKTtcblxudHlwZSBwcm9jZXNzTWV0YSA9ICdkZWNsYXJhdGlvbnMnIHwgJ2VudHJ5Q29tcG9uZW50cycgfCAnYm9vdHN0cmFwJyB8ICdwcm92aWRlcnMnIHwgJ2ltcG9ydHMnIHwgJ2V4cG9ydHMnO1xuXG5jb25zdCBjb25maWd1cmVQcm9jZXNzTWV0YUtleXMgPSAoXG4gIHJlc29sdmU6IChkZWY6IGFueSkgPT4gYW55LFxuICByZXNvbHZlUHJvdmlkZXI6IChkZWY6IFByb3ZpZGVyKSA9PiBhbnksXG4pOiBBcnJheTxbcHJvY2Vzc01ldGEsIChkZWY6IGFueSkgPT4gYW55XT4gPT4gW1xuICBbJ2RlY2xhcmF0aW9ucycsIHJlc29sdmVdLFxuICBbJ2VudHJ5Q29tcG9uZW50cycsIHJlc29sdmVdLFxuICBbJ2Jvb3RzdHJhcCcsIHJlc29sdmVdLFxuICBbJ3Byb3ZpZGVycycsIHJlc29sdmVQcm92aWRlcl0sXG4gIFsnaW1wb3J0cycsIHJlc29sdmVdLFxuICBbJ2V4cG9ydHMnLCByZXNvbHZlXSxcbl07XG5cbmNvbnN0IHByb2Nlc3NNZXRhID0gKFxuICBuZ01vZHVsZTogTmdNb2R1bGUsXG4gIHJlc29sdmU6IChkZWY6IGFueSkgPT4gYW55LFxuICByZXNvbHZlUHJvdmlkZXI6IChkZWY6IFByb3ZpZGVyKSA9PiBhbnksXG4pOiBOZ01vZHVsZSA9PiB7XG4gIGNvbnN0IG1vY2tNb2R1bGVEZWY6IE5nTW9kdWxlID0ge307XG4gIGNvbnN0IGtleXMgPSBjb25maWd1cmVQcm9jZXNzTWV0YUtleXMocmVzb2x2ZSwgcmVzb2x2ZVByb3ZpZGVyKTtcblxuICBjb25zdCBjYWNoZVBpcGUgPSBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdjYWNoZVBpcGUnKTtcbiAgaWYgKCFjYWNoZVBpcGUpIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuYWRkKCdjYWNoZVBpcGUnKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIGNhbGxiYWNrXSBvZiBrZXlzKSB7XG4gICAgaWYgKG5nTW9kdWxlW2tleV0/Lmxlbmd0aCkge1xuICAgICAgbW9ja01vZHVsZURlZltrZXldID0gZmxhdFRvRXhpc3RpbmcobmdNb2R1bGVba2V5XSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBtYXJrUHJvdmlkZXJzKG1vY2tNb2R1bGVEZWYucHJvdmlkZXJzKTtcblxuICBpZiAoIWNhY2hlUGlwZSkge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5mbGFncy5kZWxldGUoJ2NhY2hlUGlwZScpO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tNb2R1bGVEZWY7XG59O1xuXG5jb25zdCByZXNvbHZlRGVmRm9yRXhwb3J0ID0gKFxuICBkZWY6IGFueSxcbiAgcmVzb2x2ZTogKGRlZjogYW55KSA9PiBhbnksXG4gIGNvcnJlY3RFeHBvcnRzOiBib29sZWFuLFxuICBuZ01vZHVsZT86IFR5cGU8YW55Pixcbik6IFR5cGU8YW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IG1vZHVsZUNvbmZpZyA9IG5nTW9ja3NVbml2ZXJzZS5jb25maWcuZ2V0KG5nTW9kdWxlKSB8fCB7fTtcbiAgY29uc3QgaW5zdGFuY2UgPSBpc05nTW9kdWxlRGVmV2l0aFByb3ZpZGVycyhkZWYpID8gZGVmLm5nTW9kdWxlIDogZGVmO1xuICBjb25zdCBtb2NrRGVmID0gcmVzb2x2ZShpbnN0YW5jZSk7XG4gIGlmICghbW9ja0RlZikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJZiB3ZSBleHBvcnQgYSBkZWNsYXJhdGlvbiwgdGhlbiB3ZSBoYXZlIHRvIGV4cG9ydCBpdHMgbW9kdWxlIHRvby5cbiAgY29uc3QgY29uZmlnID0gbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5nZXQoaW5zdGFuY2UpO1xuICBpZiAoY29uZmlnPy5leHBvcnQgJiYgbmdNb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZUNvbmZpZy5leHBvcnQpIHtcbiAgICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWcuc2V0KG5nTW9kdWxlLCB7XG4gICAgICAgIC4uLm1vZHVsZUNvbmZpZyxcbiAgICAgICAgZXhwb3J0OiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvcnJlY3RFeHBvcnRzICYmICFtb2R1bGVDb25maWcuZXhwb3J0QWxsICYmICFjb25maWc/LmV4cG9ydCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gbW9ja0RlZjtcbn07XG5cbmNvbnN0IHNraXBBZGRFeHBvcnRzID0gKG1vY2tEZWY6IGFueSwgbW9ja01vZHVsZURlZjogTmdNb2R1bGUpOiBtb2NrRGVmIGlzIHVuZGVmaW5lZCA9PlxuICAhbW9ja0RlZiB8fCAoISFtb2NrTW9kdWxlRGVmLmV4cG9ydHMgJiYgbW9ja01vZHVsZURlZi5leHBvcnRzLmluZGV4T2YobW9ja0RlZikgIT09IC0xKTtcblxuLy8gaWYgd2UgYXJlIGluIHRoZSBza2lwTW9jayBtb2RlIHdlIG5lZWQgdG8gZXhwb3J0IG9ubHkgdGhlIGRlZmF1bHQgZXhwb3J0cy5cbi8vIGlmIHdlIGFyZSBpbiB0aGUgY29ycmVjdE1vZHVsZUV4cG9ydHMgbW9kZSB3ZSBuZWVkIHRvIGV4cG9ydCBvbmx5IGRlZmF1bHQgZXhwb3J0cy5cbmNvbnN0IGFkZEV4cG9ydHMgPSAoXG4gIHJlc29sdmU6IChkZWY6IGFueSkgPT4gYW55LFxuICBjaGFuZ2U6ICgpID0+IHZvaWQsXG4gIG5nTW9kdWxlRGVmOiBOZ01vZHVsZSxcbiAgbW9ja01vZHVsZURlZjogTmdNb2R1bGUsXG4gIG5nTW9kdWxlPzogVHlwZTxhbnk+LFxuKTogdm9pZCA9PiB7XG4gIGNvbnN0IGNvcnJlY3RFeHBvcnRzID0gbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKSB8fCBuZ01vY2tzVW5pdmVyc2UuZmxhZ3MuaGFzKCdjb3JyZWN0TW9kdWxlRXhwb3J0cycpO1xuICBmb3IgKGNvbnN0IGRlZiBvZiBmbGF0dGVuKFtuZ01vZHVsZURlZi5pbXBvcnRzIHx8IFtdLCBuZ01vZHVsZURlZi5kZWNsYXJhdGlvbnMgfHwgW11dKSkge1xuICAgIGNvbnN0IG1vY2tEZWYgPSByZXNvbHZlRGVmRm9yRXhwb3J0KGRlZiwgcmVzb2x2ZSwgY29ycmVjdEV4cG9ydHMsIG5nTW9kdWxlKTtcbiAgICBpZiAoc2tpcEFkZEV4cG9ydHMobW9ja0RlZiwgbW9ja01vZHVsZURlZikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNoYW5nZSgpO1xuICAgIG1vY2tNb2R1bGVEZWYuZXhwb3J0cyA9IG1vY2tNb2R1bGVEZWYuZXhwb3J0cyB8fCBbXTtcbiAgICBtb2NrTW9kdWxlRGVmLmV4cG9ydHMucHVzaChtb2NrRGVmKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKG5nTW9kdWxlRGVmOiBOZ01vZHVsZSwgbmdNb2R1bGU/OiBUeXBlPGFueT4pOiBbYm9vbGVhbiwgTmdNb2R1bGVdID0+IHtcbiAgY29uc3QgaGFzUmVzb2x2ZXIgPSBuZ01vY2tzVW5pdmVyc2UuY29uZmlnLmhhcygnbW9ja05nRGVmUmVzb2x2ZXInKTtcbiAgaWYgKCFoYXNSZXNvbHZlcikge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWcuc2V0KCdtb2NrTmdEZWZSZXNvbHZlcicsIG5ldyBNYXAoKSk7XG4gIH1cbiAgbGV0IGNoYW5nZWQgPSAhbmdNb2Nrc1VuaXZlcnNlLmZsYWdzLmhhcygnc2tpcE1vY2snKTtcbiAgY29uc3QgY2hhbmdlID0gKGZsYWcgPSB0cnVlKSA9PiB7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgZmxhZztcbiAgfTtcbiAgY29uc3QgeyByZXNvbHZlLCByZXNvbHZlUHJvdmlkZXIgfSA9IGNyZWF0ZVJlc29sdmVycyhjaGFuZ2UsIG5nTW9ja3NVbml2ZXJzZS5jb25maWcuZ2V0KCdtb2NrTmdEZWZSZXNvbHZlcicpKTtcbiAgY29uc3QgbW9ja01vZHVsZURlZiA9IHByb2Nlc3NNZXRhKG5nTW9kdWxlRGVmLCByZXNvbHZlLCByZXNvbHZlUHJvdmlkZXIpO1xuICBhZGRFeHBvcnRzKHJlc29sdmUsIGNoYW5nZSwgbmdNb2R1bGVEZWYsIG1vY2tNb2R1bGVEZWYsIG5nTW9kdWxlKTtcblxuICBpZiAoIWhhc1Jlc29sdmVyKSB7XG4gICAgbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5kZWxldGUoJ21vY2tOZ0RlZlJlc29sdmVyJyk7XG4gIH1cblxuICByZXR1cm4gW2NoYW5nZWQsIG1vY2tNb2R1bGVEZWZdO1xufTtcbiJdfQ==