"use strict";
// tslint:disable max-file-line-count
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockReset = exports.MockInstance = void 0;
var func_import_exists_1 = __importDefault(require("../common/func.import-exists"));
var ng_mocks_stack_1 = __importDefault(require("../common/ng-mocks-stack"));
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var mock_instance_forgot_reset_1 = __importDefault(require("./mock-instance-forgot-reset"));
var currentStack;
ng_mocks_stack_1.default.subscribePush(function (state) {
    currentStack = state;
});
ng_mocks_stack_1.default.subscribePop(function (state, stack) {
    var e_1, _a;
    try {
        for (var _b = __values(state.mockInstance || /* istanbul ignore next */ []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var declaration = _c.value;
            if (ng_mocks_universe_1.default.configInstance.has(declaration)) {
                var universeConfig = ng_mocks_universe_1.default.configInstance.get(declaration);
                universeConfig.overloads.pop();
                ng_mocks_universe_1.default.configInstance.set(declaration, __assign({}, universeConfig));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    currentStack = stack[stack.length - 1];
});
ng_mocks_stack_1.default.subscribePush(function () {
    // On start we have to flush any caches,
    // they are not from this spec.
    var set = ng_mocks_universe_1.default.getLocalMocks();
    set.splice(0, set.length);
});
ng_mocks_stack_1.default.subscribePop(function () {
    var set = ng_mocks_universe_1.default.getLocalMocks();
    while (set.length) {
        var _a = __read(set.pop() || /* istanbul ignore next */ [], 2), declaration = _a[0], config = _a[1];
        var universeConfig = ng_mocks_universe_1.default.configInstance.has(declaration)
            ? ng_mocks_universe_1.default.configInstance.get(declaration)
            : /* istanbul ignore next */ {};
        ng_mocks_universe_1.default.configInstance.set(declaration, __assign(__assign({}, universeConfig), config));
    }
});
var restore = function (declaration, config) {
    ng_mocks_universe_1.default.getLocalMocks().push([declaration, config]);
};
var parseMockInstanceArgs = function (args) {
    var set = {};
    if (typeof args[0] === 'string') {
        set.key = args[0];
        set.value = args[1];
        set.accessor = args[2];
    }
    else {
        set.data = args[0];
    }
    return set;
};
var checkReset = [];
var checkCollect = false;
// istanbul ignore else: maybe a different runner is used
// tslint:disable-next-line strict-type-predicates
if (typeof beforeEach !== 'undefined') {
    beforeEach(function () { return (checkCollect = true); });
    beforeEach(function () { return (0, mock_instance_forgot_reset_1.default)(checkReset); });
    afterEach(function () { return (checkCollect = false); });
}
var mockInstanceConfig = function (declaration, data) {
    var config = typeof data === 'function' ? { init: data } : data;
    var universeConfig = ng_mocks_universe_1.default.configInstance.has(declaration)
        ? ng_mocks_universe_1.default.configInstance.get(declaration)
        : {};
    restore(declaration, universeConfig);
    if (config) {
        ng_mocks_universe_1.default.configInstance.set(declaration, __assign(__assign({}, universeConfig), config));
    }
    else {
        ng_mocks_universe_1.default.configInstance.set(declaration, __assign(__assign({}, universeConfig), { init: undefined, overloads: [] }));
    }
    if (!config) {
        // When we are calling MockInstance without a config we need to reset it from the checks too.
        for (var i = checkReset.length - 1; i >= 0; i -= 1) {
            if (checkReset[i][0] === declaration && checkReset[i][2] === currentStack) {
                checkReset.splice(i, 1);
            }
        }
    }
    else if (checkCollect) {
        checkReset.push([declaration, ng_mocks_universe_1.default.configInstance.get(declaration), currentStack]);
    }
};
var mockInstanceMember = function (declaration, name, stub, encapsulation) {
    var _a;
    var config = ng_mocks_universe_1.default.configInstance.has(declaration) ? ng_mocks_universe_1.default.configInstance.get(declaration) : {};
    var overloads = config.overloads || [];
    overloads.push([name, stub, encapsulation]);
    config.overloads = overloads;
    ng_mocks_universe_1.default.configInstance.set(declaration, __assign({}, config));
    var mockInstances = (_a = currentStack.mockInstance) !== null && _a !== void 0 ? _a : [];
    mockInstances.push(declaration);
    currentStack.mockInstance = mockInstances;
    if (checkCollect) {
        checkReset.push([declaration, ng_mocks_universe_1.default.configInstance.get(declaration), currentStack]);
    }
    return stub;
};
function MockInstance(declaration) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    (0, func_import_exists_1.default)(declaration, 'MockInstance');
    var _a = parseMockInstanceArgs(args), key = _a.key, value = _a.value, accessor = _a.accessor, data = _a.data;
    if (key) {
        return mockInstanceMember(declaration, key, value, accessor);
    }
    mockInstanceConfig(declaration, data);
}
exports.MockInstance = MockInstance;
/**
 * @see https://ng-mocks.sudo.eu/api/MockInstance#remember
 */
MockInstance.remember = function () { return ng_mocks_stack_1.default.stackPush(); };
/**
 * @see https://ng-mocks.sudo.eu/api/MockInstance#restore
 */
MockInstance.restore = function () { return ng_mocks_stack_1.default.stackPop(); };
/**
 * @see https://ng-mocks.sudo.eu/api/MockInstance#scope
 */
MockInstance.scope = function (scope) {
    if (scope === void 0) { scope = 'case'; }
    if (scope === 'all' || scope === 'suite') {
        beforeAll(MockInstance.remember);
        afterAll(MockInstance.restore);
    }
    if (scope === 'all' || scope === 'case') {
        beforeEach(MockInstance.remember);
        afterEach(MockInstance.restore);
    }
};
function MockReset() {
    ng_mocks_universe_1.default.configInstance.clear();
}
exports.MockReset = MockReset;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1pbnN0YW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9tb2NrLWluc3RhbmNlL21vY2staW5zdGFuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHFDQUFxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLckMsb0ZBQTREO0FBQzVELDRFQUFzRTtBQUN0RSxrRkFBMEQ7QUFFMUQsNEZBQW1FO0FBRW5FLElBQUksWUFBMEIsQ0FBQztBQUMvQix3QkFBWSxDQUFDLGFBQWEsQ0FBQyxVQUFBLEtBQUs7SUFDOUIsWUFBWSxHQUFHLEtBQUssQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQztBQUNILHdCQUFZLENBQUMsWUFBWSxDQUFDLFVBQUMsS0FBSyxFQUFFLEtBQUs7OztRQUNyQyxLQUEwQixJQUFBLEtBQUEsU0FBQSxLQUFLLENBQUMsWUFBWSxJQUFJLDBCQUEwQixDQUFDLEVBQUUsQ0FBQSxnQkFBQSw0QkFBRTtZQUExRSxJQUFNLFdBQVcsV0FBQTtZQUNwQixJQUFJLDJCQUFlLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDbkQsSUFBTSxjQUFjLEdBQUcsMkJBQWUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUN2RSxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUMvQiwyQkFBZSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsV0FBVyxlQUN6QyxjQUFjLEVBQ2pCLENBQUM7YUFDSjtTQUNGOzs7Ozs7Ozs7SUFDRCxZQUFZLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDekMsQ0FBQyxDQUFDLENBQUM7QUFFSCx3QkFBWSxDQUFDLGFBQWEsQ0FBQztJQUN6Qix3Q0FBd0M7SUFD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RUc7QUFDSCxZQUFZLENBQUMsUUFBUSxHQUFHLGNBQU0sT0FBQSx3QkFBWSxDQUFDLFNBQVMsRUFBRSxFQUF4QixDQUF3QixDQUFDO0FBRXZEOztHQUVHO0FBQ0gsWUFBWSxDQUFDLE9BQU8sR0FBRyxjQUFNLE9BQUEsd0JBQVksQ0FBQyxRQUFRLEVBQUUsRUFBdkIsQ0FBdUIsQ0FBQztBQUVyRDs7R0FFRztBQUNILFlBQVksQ0FBQyxLQUFLLEdBQUcsVUFBQyxLQUF3QztJQUF4QyxzQkFBQSxFQUFBLGNBQXdDO0lBQzVELElBQUksS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFO1FBQ3hDLFNBQVMsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakMsUUFBUSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNoQztJQUNELElBQUksS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUssTUFBTSxFQUFFO1FBQ3ZDLFVBQVUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEMsU0FBUyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNqQztBQUNILENBQUMsQ0FBQztBQUVGLFNBQWdCLFNBQVM7SUFDdkIsMkJBQWUsQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDekMsQ0FBQztBQUZELDhCQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGUgbWF4LWZpbGUtbGluZS1jb3VudFxuXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RUeXBlLCBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IGZ1bmNJbXBvcnRFeGlzdHMgZnJvbSAnLi4vY29tbW9uL2Z1bmMuaW1wb3J0LWV4aXN0cyc7XG5pbXBvcnQgbmdNb2Nrc1N0YWNrLCB7IE5nTW9ja3NTdGFjayB9IGZyb20gJy4uL2NvbW1vbi9uZy1tb2Nrcy1zdGFjayc7XG5pbXBvcnQgbmdNb2Nrc1VuaXZlcnNlIGZyb20gJy4uL2NvbW1vbi9uZy1tb2Nrcy11bml2ZXJzZSc7XG5cbmltcG9ydCBtb2NrSW5zdGFuY2VGb3Jnb3RSZXNldCBmcm9tICcuL21vY2staW5zdGFuY2UtZm9yZ290LXJlc2V0JztcblxubGV0IGN1cnJlbnRTdGFjazogTmdNb2Nrc1N0YWNrO1xubmdNb2Nrc1N0YWNrLnN1YnNjcmliZVB1c2goc3RhdGUgPT4ge1xuICBjdXJyZW50U3RhY2sgPSBzdGF0ZTtcbn0pO1xubmdNb2Nrc1N0YWNrLnN1YnNjcmliZVBvcCgoc3RhdGUsIHN0YWNrKSA9PiB7XG4gIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2Ygc3RhdGUubW9ja0luc3RhbmNlIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdKSB7XG4gICAgaWYgKG5nTW9ja3NVbml2ZXJzZS5jb25maWdJbnN0YW5jZS5oYXMoZGVjbGFyYXRpb24pKSB7XG4gICAgICBjb25zdCB1bml2ZXJzZUNvbmZpZyA9IG5nTW9ja3NVbml2ZXJzZS5jb25maWdJbnN0YW5jZS5nZXQoZGVjbGFyYXRpb24pO1xuICAgICAgdW5pdmVyc2VDb25maWcub3ZlcmxvYWRzLnBvcCgpO1xuICAgICAgbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZ0luc3RhbmNlLnNldChkZWNsYXJhdGlvbiwge1xuICAgICAgICAuLi51bml2ZXJzZUNvbmZpZyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjdXJyZW50U3RhY2sgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbn0pO1xuXG5uZ01vY2tzU3RhY2suc3Vic2NyaWJlUHVzaCgoKSA9PiB7XG4gIC8vIE9uIHN0YXJ0IHdlIGhhdmUgdG8gZmx1c2ggYW55IGNhY2hlcyxcbiAgLy8gdGhleSBhcmUgbm90IGZyb20gdGhpcyBzcGVjLlxuICBjb25zdCBzZXQgPSBuZ01vY2tzVW5pdmVyc2UuZ2V0TG9jYWxNb2NrcygpO1xuICBzZXQuc3BsaWNlKDAsIHNldC5sZW5ndGgpO1xufSk7XG5uZ01vY2tzU3RhY2suc3Vic2NyaWJlUG9wKCgpID0+IHtcbiAgY29uc3Qgc2V0ID0gbmdNb2Nrc1VuaXZlcnNlLmdldExvY2FsTW9ja3MoKTtcbiAgd2hpbGUgKHNldC5sZW5ndGgpIHtcbiAgICBjb25zdCBbZGVjbGFyYXRpb24sIGNvbmZpZ10gPSBzZXQucG9wKCkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107XG4gICAgY29uc3QgdW5pdmVyc2VDb25maWcgPSBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2UuaGFzKGRlY2xhcmF0aW9uKVxuICAgICAgPyBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2UuZ2V0KGRlY2xhcmF0aW9uKVxuICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTtcbiAgICBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2Uuc2V0KGRlY2xhcmF0aW9uLCB7XG4gICAgICAuLi51bml2ZXJzZUNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9KTtcbiAgfVxufSk7XG5cbmNvbnN0IHJlc3RvcmUgPSAoZGVjbGFyYXRpb246IGFueSwgY29uZmlnOiBhbnkpOiB2b2lkID0+IHtcbiAgbmdNb2Nrc1VuaXZlcnNlLmdldExvY2FsTW9ja3MoKS5wdXNoKFtkZWNsYXJhdGlvbiwgY29uZmlnXSk7XG59O1xuXG5pbnRlcmZhY2UgTW9ja0luc3RhbmNlQXJncyB7XG4gIGFjY2Vzc29yPzogJ2dldCcgfCAnc2V0JztcbiAgZGF0YT86IGFueTtcbiAga2V5Pzogc3RyaW5nO1xuICB2YWx1ZT86IGFueTtcbn1cblxuY29uc3QgcGFyc2VNb2NrSW5zdGFuY2VBcmdzID0gKGFyZ3M6IGFueVtdKTogTW9ja0luc3RhbmNlQXJncyA9PiB7XG4gIGNvbnN0IHNldDogTW9ja0luc3RhbmNlQXJncyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXQua2V5ID0gYXJnc1swXTtcbiAgICBzZXQudmFsdWUgPSBhcmdzWzFdO1xuICAgIHNldC5hY2Nlc3NvciA9IGFyZ3NbMl07XG4gIH0gZWxzZSB7XG4gICAgc2V0LmRhdGEgPSBhcmdzWzBdO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn07XG5cbmNvbnN0IGNoZWNrUmVzZXQ6IEFycmF5PFthbnksIGFueSwgYW55P10+ID0gW107XG5sZXQgY2hlY2tDb2xsZWN0ID0gZmFsc2U7XG5cbi8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBtYXliZSBhIGRpZmZlcmVudCBydW5uZXIgaXMgdXNlZFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHN0cmljdC10eXBlLXByZWRpY2F0ZXNcbmlmICh0eXBlb2YgYmVmb3JlRWFjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmVmb3JlRWFjaCgoKSA9PiAoY2hlY2tDb2xsZWN0ID0gdHJ1ZSkpO1xuICBiZWZvcmVFYWNoKCgpID0+IG1vY2tJbnN0YW5jZUZvcmdvdFJlc2V0KGNoZWNrUmVzZXQpKTtcbiAgYWZ0ZXJFYWNoKCgpID0+IChjaGVja0NvbGxlY3QgPSBmYWxzZSkpO1xufVxuXG5jb25zdCBtb2NrSW5zdGFuY2VDb25maWcgPSA8VD4oZGVjbGFyYXRpb246IFR5cGU8VD4gfCBBYnN0cmFjdFR5cGU8VD4gfCBJbmplY3Rpb25Ub2tlbjxUPiwgZGF0YT86IGFueSk6IHZvaWQgPT4ge1xuICBjb25zdCBjb25maWcgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgaW5pdDogZGF0YSB9IDogZGF0YTtcbiAgY29uc3QgdW5pdmVyc2VDb25maWcgPSBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2UuaGFzKGRlY2xhcmF0aW9uKVxuICAgID8gbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZ0luc3RhbmNlLmdldChkZWNsYXJhdGlvbilcbiAgICA6IHt9O1xuICByZXN0b3JlKGRlY2xhcmF0aW9uLCB1bml2ZXJzZUNvbmZpZyk7XG5cbiAgaWYgKGNvbmZpZykge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWdJbnN0YW5jZS5zZXQoZGVjbGFyYXRpb24sIHtcbiAgICAgIC4uLnVuaXZlcnNlQ29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG5nTW9ja3NVbml2ZXJzZS5jb25maWdJbnN0YW5jZS5zZXQoZGVjbGFyYXRpb24sIHtcbiAgICAgIC4uLnVuaXZlcnNlQ29uZmlnLFxuICAgICAgaW5pdDogdW5kZWZpbmVkLFxuICAgICAgb3ZlcmxvYWRzOiBbXSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghY29uZmlnKSB7XG4gICAgLy8gV2hlbiB3ZSBhcmUgY2FsbGluZyBNb2NrSW5zdGFuY2Ugd2l0aG91dCBhIGNvbmZpZyB3ZSBuZWVkIHRvIHJlc2V0IGl0IGZyb20gdGhlIGNoZWNrcyB0b28uXG4gICAgZm9yIChsZXQgaSA9IGNoZWNrUmVzZXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChjaGVja1Jlc2V0W2ldWzBdID09PSBkZWNsYXJhdGlvbiAmJiBjaGVja1Jlc2V0W2ldWzJdID09PSBjdXJyZW50U3RhY2spIHtcbiAgICAgICAgY2hlY2tSZXNldC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoZWNrQ29sbGVjdCkge1xuICAgIGNoZWNrUmVzZXQucHVzaChbZGVjbGFyYXRpb24sIG5nTW9ja3NVbml2ZXJzZS5jb25maWdJbnN0YW5jZS5nZXQoZGVjbGFyYXRpb24pLCBjdXJyZW50U3RhY2tdKTtcbiAgfVxufTtcblxuY29uc3QgbW9ja0luc3RhbmNlTWVtYmVyID0gPFQ+KFxuICBkZWNsYXJhdGlvbjogVHlwZTxUPiB8IEFic3RyYWN0VHlwZTxUPiB8IEluamVjdGlvblRva2VuPFQ+LFxuICBuYW1lOiBzdHJpbmcsXG4gIHN0dWI6IGFueSxcbiAgZW5jYXBzdWxhdGlvbj86ICdnZXQnIHwgJ3NldCcsXG4pID0+IHtcbiAgY29uc3QgY29uZmlnID0gbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZ0luc3RhbmNlLmhhcyhkZWNsYXJhdGlvbikgPyBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2UuZ2V0KGRlY2xhcmF0aW9uKSA6IHt9O1xuICBjb25zdCBvdmVybG9hZHMgPSBjb25maWcub3ZlcmxvYWRzIHx8IFtdO1xuICBvdmVybG9hZHMucHVzaChbbmFtZSwgc3R1YiwgZW5jYXBzdWxhdGlvbl0pO1xuICBjb25maWcub3ZlcmxvYWRzID0gb3ZlcmxvYWRzO1xuICBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2Uuc2V0KGRlY2xhcmF0aW9uLCB7XG4gICAgLi4uY29uZmlnLFxuICB9KTtcbiAgY29uc3QgbW9ja0luc3RhbmNlcyA9IGN1cnJlbnRTdGFjay5tb2NrSW5zdGFuY2UgPz8gW107XG4gIG1vY2tJbnN0YW5jZXMucHVzaChkZWNsYXJhdGlvbik7XG4gIGN1cnJlbnRTdGFjay5tb2NrSW5zdGFuY2UgPSBtb2NrSW5zdGFuY2VzO1xuXG4gIGlmIChjaGVja0NvbGxlY3QpIHtcbiAgICBjaGVja1Jlc2V0LnB1c2goW2RlY2xhcmF0aW9uLCBuZ01vY2tzVW5pdmVyc2UuY29uZmlnSW5zdGFuY2UuZ2V0KGRlY2xhcmF0aW9uKSwgY3VycmVudFN0YWNrXSk7XG4gIH1cblxuICByZXR1cm4gc3R1Yjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9ja0luc3RhbmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBidWNrZXQgd2hpY2ggcmVtZW1iZXJzIGFsbCBmdXR1cmUgY2hhbmdlcy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL25nLW1vY2tzLnN1ZG8uZXUvYXBpL01vY2tJbnN0YW5jZSNyZW1lbWJlclxuICAgKi9cbiAgcmVtZW1iZXIoKTogdm9pZDtcblxuICAvKipcbiAgICogUmVzZXRzIGFsbCBjaGFuZ2VzIGZvciBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL25nLW1vY2tzLnN1ZG8uZXUvYXBpL01vY2tJbnN0YW5jZSNyZXN0b3JlXG4gICAqL1xuICByZXN0b3JlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsb2NhbCBzY29wZSBpbiBgYmVmb3JlQWxsYCBhbmQgYGFmdGVyQWxsYC5cbiAgICogSWYgYGVhY2hgIGhhcyBiZWVuIHBhc3NlZCwgdGhlbiBgYmVmb3JlRWFjaGAgYW5kIGBhZnRlckVhY2hgIGFyZSB1c2VkLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja0luc3RhbmNlI3Njb3BlXG4gICAqL1xuICBzY29wZShzY29wZT86ICdhbGwnKTogdm9pZDtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja0luc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNb2NrSW5zdGFuY2U8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQsIFMgZXh0ZW5kcyAoKSA9PiBUW0tdPihcbiAgaW5zdGFuY2U6IFR5cGU8VD4gfCBBYnN0cmFjdFR5cGU8VD4sXG4gIG5hbWU6IEssXG4gIHN0dWI6IFMsXG4gIGVuY2Fwc3VsYXRpb246ICdnZXQnLFxuKTogUztcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja0luc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNb2NrSW5zdGFuY2U8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQsIFMgZXh0ZW5kcyAodmFsdWU6IFRbS10pID0+IHZvaWQ+KFxuICBpbnN0YW5jZTogVHlwZTxUPiB8IEFic3RyYWN0VHlwZTxUPixcbiAgbmFtZTogSyxcbiAgc3R1YjogUyxcbiAgZW5jYXBzdWxhdGlvbjogJ3NldCcsXG4pOiBTO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9uZy1tb2Nrcy5zdWRvLmV1L2FwaS9Nb2NrSW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vY2tJbnN0YW5jZTxUIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgVCwgUyBleHRlbmRzIFRbS10+KFxuICBpbnN0YW5jZTogVHlwZTxUPiB8IEFic3RyYWN0VHlwZTxUPixcbiAgbmFtZTogSyxcbiAgc3R1YjogUyxcbik6IFM7XG5cbi8qKlxuICogQHNlZSBodHRwczovL25nLW1vY2tzLnN1ZG8uZXUvYXBpL01vY2tJbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTW9ja0luc3RhbmNlPFQ+KFxuICBkZWNsYXJhdGlvbjogSW5qZWN0aW9uVG9rZW48VD4sXG4gIGluaXQ/OiAoaW5zdGFuY2U6IFQgfCB1bmRlZmluZWQsIGluamVjdG9yOiBJbmplY3RvciB8IHVuZGVmaW5lZCkgPT4gUGFydGlhbDxUPixcbik6IHZvaWQ7XG5cbi8qKlxuICogQHNlZSBodHRwczovL25nLW1vY2tzLnN1ZG8uZXUvYXBpL01vY2tJbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTW9ja0luc3RhbmNlPFQ+KFxuICBkZWNsYXJhdGlvbjogSW5qZWN0aW9uVG9rZW48VD4sXG4gIGNvbmZpZz86IHtcbiAgICBpbml0PzogKGluc3RhbmNlOiBUIHwgdW5kZWZpbmVkLCBpbmplY3RvcjogSW5qZWN0b3IgfCB1bmRlZmluZWQpID0+IFBhcnRpYWw8VD47XG4gIH0sXG4pOiB2b2lkO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9uZy1tb2Nrcy5zdWRvLmV1L2FwaS9Nb2NrSW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vY2tJbnN0YW5jZTxUPihcbiAgZGVjbGFyYXRpb246IFR5cGU8VD4gfCBBYnN0cmFjdFR5cGU8VD4sXG4gIGluaXQ/OiAoaW5zdGFuY2U6IFQsIGluamVjdG9yOiBJbmplY3RvciB8IHVuZGVmaW5lZCkgPT4gdm9pZCB8IFBhcnRpYWw8VD4sXG4pOiB2b2lkO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9uZy1tb2Nrcy5zdWRvLmV1L2FwaS9Nb2NrSW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1vY2tJbnN0YW5jZTxUPihcbiAgZGVjbGFyYXRpb246IFR5cGU8VD4gfCBBYnN0cmFjdFR5cGU8VD4sXG4gIGNvbmZpZz86IHtcbiAgICBpbml0PzogKGluc3RhbmNlOiBULCBpbmplY3RvcjogSW5qZWN0b3IgfCB1bmRlZmluZWQpID0+IHZvaWQgfCBQYXJ0aWFsPFQ+O1xuICB9LFxuKTogdm9pZDtcblxuZXhwb3J0IGZ1bmN0aW9uIE1vY2tJbnN0YW5jZTxUPihkZWNsYXJhdGlvbjogVHlwZTxUPiB8IEFic3RyYWN0VHlwZTxUPiB8IEluamVjdGlvblRva2VuPFQ+LCAuLi5hcmdzOiBhbnlbXSkge1xuICBmdW5jSW1wb3J0RXhpc3RzKGRlY2xhcmF0aW9uLCAnTW9ja0luc3RhbmNlJyk7XG5cbiAgY29uc3QgeyBrZXksIHZhbHVlLCBhY2Nlc3NvciwgZGF0YSB9ID0gcGFyc2VNb2NrSW5zdGFuY2VBcmdzKGFyZ3MpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIG1vY2tJbnN0YW5jZU1lbWJlcihkZWNsYXJhdGlvbiwga2V5LCB2YWx1ZSwgYWNjZXNzb3IpO1xuICB9XG5cbiAgbW9ja0luc3RhbmNlQ29uZmlnKGRlY2xhcmF0aW9uLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja0luc3RhbmNlI3JlbWVtYmVyXG4gKi9cbk1vY2tJbnN0YW5jZS5yZW1lbWJlciA9ICgpID0+IG5nTW9ja3NTdGFjay5zdGFja1B1c2goKTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja0luc3RhbmNlI3Jlc3RvcmVcbiAqL1xuTW9ja0luc3RhbmNlLnJlc3RvcmUgPSAoKSA9PiBuZ01vY2tzU3RhY2suc3RhY2tQb3AoKTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmctbW9ja3Muc3Vkby5ldS9hcGkvTW9ja0luc3RhbmNlI3Njb3BlXG4gKi9cbk1vY2tJbnN0YW5jZS5zY29wZSA9IChzY29wZTogJ2FsbCcgfCAnc3VpdGUnIHwgJ2Nhc2UnID0gJ2Nhc2UnKSA9PiB7XG4gIGlmIChzY29wZSA9PT0gJ2FsbCcgfHwgc2NvcGUgPT09ICdzdWl0ZScpIHtcbiAgICBiZWZvcmVBbGwoTW9ja0luc3RhbmNlLnJlbWVtYmVyKTtcbiAgICBhZnRlckFsbChNb2NrSW5zdGFuY2UucmVzdG9yZSk7XG4gIH1cbiAgaWYgKHNjb3BlID09PSAnYWxsJyB8fCBzY29wZSA9PT0gJ2Nhc2UnKSB7XG4gICAgYmVmb3JlRWFjaChNb2NrSW5zdGFuY2UucmVtZW1iZXIpO1xuICAgIGFmdGVyRWFjaChNb2NrSW5zdGFuY2UucmVzdG9yZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBNb2NrUmVzZXQoKSB7XG4gIG5nTW9ja3NVbml2ZXJzZS5jb25maWdJbnN0YW5jZS5jbGVhcigpO1xufVxuIl19