"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var core_config_1 = __importDefault(require("../common/core.config"));
var core_define_property_1 = __importDefault(require("../common/core.define-property"));
var ng_mocks_universe_1 = __importDefault(require("../common/ng-mocks-universe"));
var helper_define_property_descriptor_1 = __importDefault(require("../mock-service/helper.define-property-descriptor"));
var func_generate_template_1 = __importDefault(require("./func.generate-template"));
var generateWrapperOutput = function (instance) {
    return function (prop, event) {
        if (typeof instance[prop] === 'function') {
            return instance[prop](event);
        }
        if (instance[prop] && typeof instance[prop] === 'object' && typeof instance[prop].emit === 'function') {
            return instance[prop].emit(event);
        }
        if (instance[prop] && typeof instance[prop] === 'object' && typeof instance[prop].next === 'function') {
            return instance[prop].next(event);
        }
        instance[prop] = event;
    };
};
var generateWrapper = function (_a) {
    var bindings = _a.bindings, options = _a.options, inputs = _a.inputs;
    var MockRenderComponent = /** @class */ (function () {
        function MockRenderComponent() {
            var e_1, _a;
            (0, core_define_property_1.default)(this, '__ngMocksOutput', generateWrapperOutput(this));
            if (!bindings) {
                var _loop_1 = function (input) {
                    var value = null;
                    (0, helper_define_property_descriptor_1.default)(this_1, input, {
                        get: function () { return value; },
                        set: function (newValue) { return (value = newValue); },
                    });
                };
                var this_1 = this;
                try {
                    for (var _b = __values(inputs || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var input = _c.value;
                        _loop_1(input);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
        return MockRenderComponent;
    }());
    (0, core_1.Component)(options)(MockRenderComponent);
    return MockRenderComponent;
};
var getCache = function () {
    var _a;
    var caches = (_a = ng_mocks_universe_1.default.config.get('MockRenderCaches')) !== null && _a !== void 0 ? _a : [];
    if (caches.length === 0) {
        ng_mocks_universe_1.default.config.set('MockRenderCaches', caches);
    }
    return caches;
};
var checkCache = function (caches, cacheKey) {
    var e_2, _a;
    try {
        for (var caches_1 = __values(caches), caches_1_1 = caches_1.next(); !caches_1_1.done; caches_1_1 = caches_1.next()) {
            var cache = caches_1_1.value;
            if (cache.cacheKey.length !== cacheKey.length) {
                continue;
            }
            var isValid = true;
            for (var i = 0; i < cacheKey.length; i += 1) {
                if (cache.cacheKey[i] !== cacheKey[i]) {
                    isValid = false;
                    break;
                }
            }
            if (isValid) {
                return cache;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (caches_1_1 && !caches_1_1.done && (_a = caches_1.return)) _a.call(caches_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return undefined;
};
exports.default = (function (template, meta, bindings, flags) {
    var _a, _b;
    var caches = getCache();
    // nulls help to detect defaults
    var cacheKey = __spreadArray(__spreadArray([template], __read((bindings !== null && bindings !== void 0 ? bindings : [null])), false), __read(((_a = flags.providers) !== null && _a !== void 0 ? _a : [null])), false);
    var ctor = checkCache(caches, cacheKey);
    if (ctor) {
        return ctor;
    }
    var mockTemplate = (0, func_generate_template_1.default)(template, __assign(__assign({}, meta), { bindings: bindings }));
    var options = {
        providers: flags.providers,
        selector: 'mock-render',
        template: mockTemplate,
    };
    ctor = generateWrapper(__assign(__assign({}, meta), { bindings: bindings, options: options }));
    (0, core_define_property_1.default)(ctor, 'cacheKey', cacheKey, false);
    caches.unshift(ctor);
    caches.splice((_b = ng_mocks_universe_1.default.global.get('mockRenderCacheSize')) !== null && _b !== void 0 ? _b : core_config_1.default.mockRenderCacheSize);
    return ctor;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuYy5jcmVhdGUtd3JhcHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9tb2NrLXJlbmRlci9mdW5jLmNyZWF0ZS13cmFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzQ0FBcUQ7QUFFckQsc0VBQStDO0FBQy9DLHdGQUFnRTtBQUVoRSxrRkFBMEQ7QUFDMUQsd0hBQStGO0FBRS9GLG9GQUE0RDtBQUU1RCxJQUFNLHFCQUFxQixHQUN6QixVQUFDLFFBQWE7SUFDZCxPQUFBLFVBQUMsSUFBZSxFQUFFLEtBQVU7UUFDMUIsSUFBSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7WUFDeEMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDOUI7UUFDRCxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLElBQUksT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtZQUNyRyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbkM7UUFDRCxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLElBQUksT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtZQUNyRyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbkM7UUFFRCxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3pCLENBQUM7QUFaRCxDQVlDLENBQUM7QUFFSixJQUFNLGVBQWUsR0FBRyxVQUFDLEVBQWtDO1FBQWhDLFFBQVEsY0FBQSxFQUFFLE9BQU8sYUFBQSxFQUFFLE1BQU0sWUFBQTtJQUNsRDtRQUNFOztZQUNFLElBQUEsOEJBQWtCLEVBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFFLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFFekUsSUFBSSxDQUFDLFFBQVEsRUFBRTt3Q0FDRixLQUFLO29CQUNkLElBQUksS0FBSyxHQUFRLElBQUksQ0FBQztvQkFDdEIsSUFBQSwyQ0FBOEIsVUFBTyxLQUFLLEVBQUU7d0JBQzFDLEdBQUcsRUFBRSxjQUFNLE9BQUEsS0FBSyxFQUFMLENBQUs7d0JBQ2hCLEdBQUcsRUFBRSxVQUFDLFFBQWEsSUFBSyxPQUFBLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxFQUFsQixDQUFrQjtxQkFDM0MsQ0FBQyxDQUFDOzs7O29CQUxMLEtBQW9CLElBQUEsS0FBQSxTQUFBLE1BQU0sSUFBSSxFQUFFLENBQUEsZ0JBQUE7d0JBQTNCLElBQU0sS0FBSyxXQUFBO2dDQUFMLEtBQUs7cUJBTWY7Ozs7Ozs7OzthQUNGO1FBQ0gsQ0FBQztRQUNILDBCQUFDO0lBQUQsQ0FBQyxBQWRELElBY0M7SUFDRCxJQUFBLGdCQUFTLEVBQUMsT0FBTyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUV4QyxPQUFPLG1CQUFtQixDQUFDO0FBQzdCLENBQUMsQ0FBQztBQUVGLElBQU0sUUFBUSxHQUFHOztJQUNmLElBQU0sTUFBTSxHQUFpRCxNQUFBLDJCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxtQ0FBSSxFQUFFLENBQUM7SUFDbEgsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN2QiwyQkFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDeEQ7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDLENBQUM7QUFFRixJQUFNLFVBQVUsR0FBRyxVQUFDLE1BQW9ELEVBQUUsUUFBZTs7O1FBQ3ZGLEtBQW9CLElBQUEsV0FBQSxTQUFBLE1BQU0sQ0FBQSw4QkFBQSxrREFBRTtZQUF2QixJQUFNLEtBQUssbUJBQUE7WUFDZCxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxNQUFNLEVBQUU7Z0JBQzdDLFNBQVM7YUFDVjtZQUNELElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztZQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMzQyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUNyQyxPQUFPLEdBQUcsS0FBSyxDQUFDO29CQUNoQixNQUFNO2lCQUNQO2FBQ0Y7WUFDRCxJQUFJLE9BQU8sRUFBRTtnQkFDWCxPQUFPLEtBQUssQ0FBQzthQUNkO1NBQ0Y7Ozs7Ozs7OztJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMsQ0FBQztBQUVGLG1CQUFlLFVBQ2IsUUFBYSxFQUNiLElBQWUsRUFDZixRQUFrQyxFQUNsQyxLQUE2Qjs7SUFFN0IsSUFBTSxNQUFNLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFFMUIsZ0NBQWdDO0lBQ2hDLElBQU0sUUFBUSxnQ0FBSSxRQUFRLFVBQUssQ0FBQyxRQUFRLGFBQVIsUUFBUSxjQUFSLFFBQVEsR0FBSSxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFLLENBQUMsTUFBQSxLQUFLLENBQUMsU0FBUyxtQ0FBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQUMsQ0FBQztJQUNyRixJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hDLElBQUksSUFBSSxFQUFFO1FBQ1IsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQU0sWUFBWSxHQUFHLElBQUEsZ0NBQW9CLEVBQUMsUUFBUSx3QkFBTyxJQUFJLEtBQUUsUUFBUSxVQUFBLElBQUcsQ0FBQztJQUMzRSxJQUFNLE9BQU8sR0FBYztRQUN6QixTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7UUFDMUIsUUFBUSxFQUFFLGFBQWE7UUFDdkIsUUFBUSxFQUFFLFlBQVk7S0FDdkIsQ0FBQztJQUVGLElBQUksR0FBRyxlQUFlLHVCQUFNLElBQUksS0FBRSxRQUFRLFVBQUEsRUFBRSxPQUFPLFNBQUEsSUFBRyxDQUFDO0lBQ3ZELElBQUEsOEJBQWtCLEVBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFXLENBQUMsQ0FBQztJQUM1QixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQUEsMkJBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLG1DQUFJLHFCQUFVLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUVuRyxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsRUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCBjb3JlQ29uZmlnIGZyb20gJy4uL2NvbW1vbi9jb3JlLmNvbmZpZyc7XG5pbXBvcnQgY29yZURlZmluZVByb3BlcnR5IGZyb20gJy4uL2NvbW1vbi9jb3JlLmRlZmluZS1wcm9wZXJ0eSc7XG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IG5nTW9ja3NVbml2ZXJzZSBmcm9tICcuLi9jb21tb24vbmctbW9ja3MtdW5pdmVyc2UnO1xuaW1wb3J0IGhlbHBlckRlZmluZVByb3BlcnR5RGVzY3JpcHRvciBmcm9tICcuLi9tb2NrLXNlcnZpY2UvaGVscGVyLmRlZmluZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJztcblxuaW1wb3J0IGZ1bmNHZW5lcmF0ZVRlbXBsYXRlIGZyb20gJy4vZnVuYy5nZW5lcmF0ZS10ZW1wbGF0ZSc7XG5cbmNvbnN0IGdlbmVyYXRlV3JhcHBlck91dHB1dCA9XG4gIChpbnN0YW5jZTogYW55KSA9PlxuICAocHJvcDoga2V5b2YgYW55LCBldmVudDogYW55KTogdm9pZCA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGluc3RhbmNlW3Byb3BdKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlW3Byb3BdICYmIHR5cGVvZiBpbnN0YW5jZVtwcm9wXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGluc3RhbmNlW3Byb3BdLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZVtwcm9wXS5lbWl0KGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlW3Byb3BdICYmIHR5cGVvZiBpbnN0YW5jZVtwcm9wXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGluc3RhbmNlW3Byb3BdLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZVtwcm9wXS5uZXh0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wXSA9IGV2ZW50O1xuICB9O1xuXG5jb25zdCBnZW5lcmF0ZVdyYXBwZXIgPSAoeyBiaW5kaW5ncywgb3B0aW9ucywgaW5wdXRzIH06IGFueSkgPT4ge1xuICBjbGFzcyBNb2NrUmVuZGVyQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICBjb3JlRGVmaW5lUHJvcGVydHkodGhpcywgJ19fbmdNb2Nrc091dHB1dCcsIGdlbmVyYXRlV3JhcHBlck91dHB1dCh0aGlzKSk7XG5cbiAgICAgIGlmICghYmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMgfHwgW10pIHtcbiAgICAgICAgICBsZXQgdmFsdWU6IGFueSA9IG51bGw7XG4gICAgICAgICAgaGVscGVyRGVmaW5lUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIGlucHV0LCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHZhbHVlLFxuICAgICAgICAgICAgc2V0OiAobmV3VmFsdWU6IGFueSkgPT4gKHZhbHVlID0gbmV3VmFsdWUpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIENvbXBvbmVudChvcHRpb25zKShNb2NrUmVuZGVyQ29tcG9uZW50KTtcblxuICByZXR1cm4gTW9ja1JlbmRlckNvbXBvbmVudDtcbn07XG5cbmNvbnN0IGdldENhY2hlID0gKCkgPT4ge1xuICBjb25zdCBjYWNoZXM6IEFycmF5PFR5cGU8YW55PiAmIFJlY29yZDwnY2FjaGVLZXknLCBhbnlbXT4+ID0gbmdNb2Nrc1VuaXZlcnNlLmNvbmZpZy5nZXQoJ01vY2tSZW5kZXJDYWNoZXMnKSA/PyBbXTtcbiAgaWYgKGNhY2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuY29uZmlnLnNldCgnTW9ja1JlbmRlckNhY2hlcycsIGNhY2hlcyk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVzO1xufTtcblxuY29uc3QgY2hlY2tDYWNoZSA9IChjYWNoZXM6IEFycmF5PFR5cGU8YW55PiAmIFJlY29yZDwnY2FjaGVLZXknLCBhbnlbXT4+LCBjYWNoZUtleTogYW55W10pOiB1bmRlZmluZWQgfCBUeXBlPGFueT4gPT4ge1xuICBmb3IgKGNvbnN0IGNhY2hlIG9mIGNhY2hlcykge1xuICAgIGlmIChjYWNoZS5jYWNoZUtleS5sZW5ndGggIT09IGNhY2hlS2V5Lmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlS2V5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2FjaGUuY2FjaGVLZXlbaV0gIT09IGNhY2hlS2V5W2ldKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChcbiAgdGVtcGxhdGU6IGFueSxcbiAgbWV0YTogRGlyZWN0aXZlLFxuICBiaW5kaW5nczogdW5kZWZpbmVkIHwgbnVsbCB8IGFueVtdLFxuICBmbGFnczogUmVjb3JkPGtleW9mIGFueSwgYW55Pixcbik6IFR5cGU8YW55PiA9PiB7XG4gIGNvbnN0IGNhY2hlcyA9IGdldENhY2hlKCk7XG5cbiAgLy8gbnVsbHMgaGVscCB0byBkZXRlY3QgZGVmYXVsdHNcbiAgY29uc3QgY2FjaGVLZXkgPSBbdGVtcGxhdGUsIC4uLihiaW5kaW5ncyA/PyBbbnVsbF0pLCAuLi4oZmxhZ3MucHJvdmlkZXJzID8/IFtudWxsXSldO1xuICBsZXQgY3RvciA9IGNoZWNrQ2FjaGUoY2FjaGVzLCBjYWNoZUtleSk7XG4gIGlmIChjdG9yKSB7XG4gICAgcmV0dXJuIGN0b3I7XG4gIH1cblxuICBjb25zdCBtb2NrVGVtcGxhdGUgPSBmdW5jR2VuZXJhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSwgeyAuLi5tZXRhLCBiaW5kaW5ncyB9KTtcbiAgY29uc3Qgb3B0aW9uczogQ29tcG9uZW50ID0ge1xuICAgIHByb3ZpZGVyczogZmxhZ3MucHJvdmlkZXJzLFxuICAgIHNlbGVjdG9yOiAnbW9jay1yZW5kZXInLFxuICAgIHRlbXBsYXRlOiBtb2NrVGVtcGxhdGUsXG4gIH07XG5cbiAgY3RvciA9IGdlbmVyYXRlV3JhcHBlcih7IC4uLm1ldGEsIGJpbmRpbmdzLCBvcHRpb25zIH0pO1xuICBjb3JlRGVmaW5lUHJvcGVydHkoY3RvciwgJ2NhY2hlS2V5JywgY2FjaGVLZXksIGZhbHNlKTtcbiAgY2FjaGVzLnVuc2hpZnQoY3RvciBhcyBhbnkpO1xuICBjYWNoZXMuc3BsaWNlKG5nTW9ja3NVbml2ZXJzZS5nbG9iYWwuZ2V0KCdtb2NrUmVuZGVyQ2FjaGVTaXplJykgPz8gY29yZUNvbmZpZy5tb2NrUmVuZGVyQ2FjaGVTaXplKTtcblxuICByZXR1cm4gY3Rvcjtcbn07XG4iXX0=