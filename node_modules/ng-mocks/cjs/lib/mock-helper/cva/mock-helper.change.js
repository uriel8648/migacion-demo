"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_form_1 = __importDefault(require("../../common/core.form"));
var func_is_mock_control_value_accessor_1 = require("../../common/func.is-mock-control-value-accessor");
var helper_define_property_descriptor_1 = __importDefault(require("../../mock-service/helper.define-property-descriptor"));
var mock_helper_trigger_1 = __importDefault(require("../events/mock-helper.trigger"));
var mock_helper_find_1 = __importDefault(require("../find/mock-helper.find"));
var func_get_last_fixture_1 = __importDefault(require("../func.get-last-fixture"));
var func_parse_find_args_name_1 = __importDefault(require("../func.parse-find-args-name"));
var mock_helper_stub_member_1 = __importDefault(require("../mock-helper.stub-member"));
var func_get_vca_1 = __importDefault(require("./func.get-vca"));
// default html behavior
var triggerInput = function (el, value) {
    (0, mock_helper_trigger_1.default)(el, 'focus');
    var descriptor = Object.getOwnPropertyDescriptor(el.nativeElement, 'value');
    (0, mock_helper_stub_member_1.default)(el.nativeElement, 'value', value);
    (0, mock_helper_trigger_1.default)(el, 'input');
    (0, mock_helper_trigger_1.default)(el, 'change');
    if (descriptor) {
        (0, helper_define_property_descriptor_1.default)(el.nativeElement, 'value', descriptor);
        el.nativeElement.value = value;
    }
    (0, mock_helper_trigger_1.default)(el, 'blur');
};
var handleKnown = function (valueAccessor, value) {
    if (core_form_1.default && valueAccessor instanceof core_form_1.default.AbstractControl) {
        valueAccessor.setValue(value);
        return true;
    }
    if (core_form_1.default && valueAccessor instanceof core_form_1.default.NgModel) {
        valueAccessor.update.emit(value);
        return true;
    }
    if ((0, func_is_mock_control_value_accessor_1.isMockControlValueAccessor)(valueAccessor.instance)) {
        valueAccessor.instance.__simulateChange(value);
        return true;
    }
    return false;
};
var hasListener = function (el) {
    return el.listeners.filter(function (listener) { return listener.name === 'input' || listener.name === 'change'; }).length > 0;
};
var keys = ['onChange', '_onChange', 'changeFn', '_onChangeCallback', 'onModelChange'];
exports.default = (function (selector, value) {
    var e_1, _a;
    var el = (0, mock_helper_find_1.default)((0, func_get_last_fixture_1.default)(), selector, undefined);
    if (!el) {
        throw new Error("Cannot find an element via ngMocks.change(" + (0, func_parse_find_args_name_1.default)(selector) + ")");
    }
    var valueAccessor = (0, func_get_vca_1.default)(el);
    if (handleKnown(valueAccessor, value) || hasListener(el)) {
        triggerInput(el, value);
        return;
    }
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            if (typeof valueAccessor[key] === 'function') {
                valueAccessor.writeValue(value);
                valueAccessor[key](value);
                return;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    throw new Error('Unsupported type of ControlValueAccessor');
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1oZWxwZXIuY2hhbmdlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZy1tb2Nrcy9zcmMvbGliL21vY2staGVscGVyL2N2YS9tb2NrLWhlbHBlci5jaGFuZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHFFQUE4QztBQUU5Qyx3R0FBOEY7QUFDOUYsMkhBQWtHO0FBQ2xHLHNGQUE4RDtBQUM5RCw4RUFBc0Q7QUFDdEQsbUZBQTBEO0FBQzFELDJGQUFpRTtBQUNqRSx1RkFBOEQ7QUFFOUQsZ0VBQXdDO0FBRXhDLHdCQUF3QjtBQUN4QixJQUFNLFlBQVksR0FBRyxVQUFDLEVBQWdCLEVBQUUsS0FBVTtJQUNoRCxJQUFBLDZCQUFpQixFQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUUvQixJQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM5RSxJQUFBLGlDQUFvQixFQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3ZELElBQUEsNkJBQWlCLEVBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQy9CLElBQUEsNkJBQWlCLEVBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLElBQUksVUFBVSxFQUFFO1FBQ2QsSUFBQSwyQ0FBOEIsRUFBQyxFQUFFLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUN0RSxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7S0FDaEM7SUFFRCxJQUFBLDZCQUFpQixFQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNoQyxDQUFDLENBQUM7QUFFRixJQUFNLFdBQVcsR0FBRyxVQUFDLGFBQWtCLEVBQUUsS0FBVTtJQUNqRCxJQUFJLG1CQUFRLElBQUksYUFBYSxZQUFZLG1CQUFRLENBQUMsZUFBZSxFQUFFO1FBQ2pFLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFOUIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksbUJBQVEsSUFBSSxhQUFhLFlBQVksbUJBQVEsQ0FBQyxPQUFPLEVBQUU7UUFDekQsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFakMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksSUFBQSxnRUFBMEIsRUFBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDdEQsYUFBYSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUvQyxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUM7QUFFRixJQUFNLFdBQVcsR0FBRyxVQUFDLEVBQWdCO0lBQ25DLE9BQUEsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBQSxRQUFRLElBQUksT0FBQSxRQUFRLENBQUMsSUFBSSxLQUFLLE9BQU8sSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBdkQsQ0FBdUQsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDO0FBQW5HLENBQW1HLENBQUM7QUFFdEcsSUFBTSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsRUFBRSxlQUFlLENBQUMsQ0FBQztBQUV6RixtQkFBZSxVQUFDLFFBQTJCLEVBQUUsS0FBVTs7SUFDckQsSUFBTSxFQUFFLEdBQUcsSUFBQSwwQkFBYyxFQUFDLElBQUEsK0JBQWtCLEdBQUUsRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDckUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQTZDLElBQUEsbUNBQXFCLEVBQUMsUUFBUSxDQUFDLE1BQUcsQ0FBQyxDQUFDO0tBQ2xHO0lBRUQsSUFBTSxhQUFhLEdBQUcsSUFBQSxzQkFBVSxFQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLElBQUksV0FBVyxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDeEQsWUFBWSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV4QixPQUFPO0tBQ1I7O1FBRUQsS0FBa0IsSUFBQSxTQUFBLFNBQUEsSUFBSSxDQUFBLDBCQUFBLDRDQUFFO1lBQW5CLElBQU0sR0FBRyxpQkFBQTtZQUNaLElBQUksT0FBTyxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssVUFBVSxFQUFFO2dCQUM1QyxhQUFhLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBRTFCLE9BQU87YUFDUjtTQUNGOzs7Ozs7Ozs7SUFFRCxNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7QUFDOUQsQ0FBQyxFQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWdFbGVtZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCBjb3JlRm9ybSBmcm9tICcuLi8uLi9jb21tb24vY29yZS5mb3JtJztcbmltcG9ydCB7IERlYnVnTm9kZVNlbGVjdG9yIH0gZnJvbSAnLi4vLi4vY29tbW9uL2NvcmUudHlwZXMnO1xuaW1wb3J0IHsgaXNNb2NrQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICcuLi8uLi9jb21tb24vZnVuYy5pcy1tb2NrLWNvbnRyb2wtdmFsdWUtYWNjZXNzb3InO1xuaW1wb3J0IGhlbHBlckRlZmluZVByb3BlcnR5RGVzY3JpcHRvciBmcm9tICcuLi8uLi9tb2NrLXNlcnZpY2UvaGVscGVyLmRlZmluZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJztcbmltcG9ydCBtb2NrSGVscGVyVHJpZ2dlciBmcm9tICcuLi9ldmVudHMvbW9jay1oZWxwZXIudHJpZ2dlcic7XG5pbXBvcnQgbW9ja0hlbHBlckZpbmQgZnJvbSAnLi4vZmluZC9tb2NrLWhlbHBlci5maW5kJztcbmltcG9ydCBmdW5jR2V0TGFzdEZpeHR1cmUgZnJvbSAnLi4vZnVuYy5nZXQtbGFzdC1maXh0dXJlJztcbmltcG9ydCBmdW5jUGFyc2VGaW5kQXJnc05hbWUgZnJvbSAnLi4vZnVuYy5wYXJzZS1maW5kLWFyZ3MtbmFtZSc7XG5pbXBvcnQgbW9ja0hlbHBlclN0dWJNZW1iZXIgZnJvbSAnLi4vbW9jay1oZWxwZXIuc3R1Yi1tZW1iZXInO1xuXG5pbXBvcnQgZnVuY0dldFZjYSBmcm9tICcuL2Z1bmMuZ2V0LXZjYSc7XG5cbi8vIGRlZmF1bHQgaHRtbCBiZWhhdmlvclxuY29uc3QgdHJpZ2dlcklucHV0ID0gKGVsOiBEZWJ1Z0VsZW1lbnQsIHZhbHVlOiBhbnkpOiB2b2lkID0+IHtcbiAgbW9ja0hlbHBlclRyaWdnZXIoZWwsICdmb2N1cycpO1xuXG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVsLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScpO1xuICBtb2NrSGVscGVyU3R1Yk1lbWJlcihlbC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gIG1vY2tIZWxwZXJUcmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgbW9ja0hlbHBlclRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICBoZWxwZXJEZWZpbmVQcm9wZXJ0eURlc2NyaXB0b3IoZWwubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgZGVzY3JpcHRvcik7XG4gICAgZWwubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgbW9ja0hlbHBlclRyaWdnZXIoZWwsICdibHVyJyk7XG59O1xuXG5jb25zdCBoYW5kbGVLbm93biA9ICh2YWx1ZUFjY2Vzc29yOiBhbnksIHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgaWYgKGNvcmVGb3JtICYmIHZhbHVlQWNjZXNzb3IgaW5zdGFuY2VvZiBjb3JlRm9ybS5BYnN0cmFjdENvbnRyb2wpIHtcbiAgICB2YWx1ZUFjY2Vzc29yLnNldFZhbHVlKHZhbHVlKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGNvcmVGb3JtICYmIHZhbHVlQWNjZXNzb3IgaW5zdGFuY2VvZiBjb3JlRm9ybS5OZ01vZGVsKSB7XG4gICAgdmFsdWVBY2Nlc3Nvci51cGRhdGUuZW1pdCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc01vY2tDb250cm9sVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yLmluc3RhbmNlKSkge1xuICAgIHZhbHVlQWNjZXNzb3IuaW5zdGFuY2UuX19zaW11bGF0ZUNoYW5nZSh2YWx1ZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGhhc0xpc3RlbmVyID0gKGVsOiBEZWJ1Z0VsZW1lbnQpOiBib29sZWFuID0+XG4gIGVsLmxpc3RlbmVycy5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIubmFtZSA9PT0gJ2lucHV0JyB8fCBsaXN0ZW5lci5uYW1lID09PSAnY2hhbmdlJykubGVuZ3RoID4gMDtcblxuY29uc3Qga2V5cyA9IFsnb25DaGFuZ2UnLCAnX29uQ2hhbmdlJywgJ2NoYW5nZUZuJywgJ19vbkNoYW5nZUNhbGxiYWNrJywgJ29uTW9kZWxDaGFuZ2UnXTtcblxuZXhwb3J0IGRlZmF1bHQgKHNlbGVjdG9yOiBEZWJ1Z05vZGVTZWxlY3RvciwgdmFsdWU6IGFueSk6IHZvaWQgPT4ge1xuICBjb25zdCBlbCA9IG1vY2tIZWxwZXJGaW5kKGZ1bmNHZXRMYXN0Rml4dHVyZSgpLCBzZWxlY3RvciwgdW5kZWZpbmVkKTtcbiAgaWYgKCFlbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW4gZWxlbWVudCB2aWEgbmdNb2Nrcy5jaGFuZ2UoJHtmdW5jUGFyc2VGaW5kQXJnc05hbWUoc2VsZWN0b3IpfSlgKTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlQWNjZXNzb3IgPSBmdW5jR2V0VmNhKGVsKTtcbiAgaWYgKGhhbmRsZUtub3duKHZhbHVlQWNjZXNzb3IsIHZhbHVlKSB8fCBoYXNMaXN0ZW5lcihlbCkpIHtcbiAgICB0cmlnZ2VySW5wdXQoZWwsIHZhbHVlKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlQWNjZXNzb3Jba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICAgIHZhbHVlQWNjZXNzb3Jba2V5XSh2YWx1ZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3InKTtcbn07XG4iXX0=