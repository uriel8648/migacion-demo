"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_debug_node_1 = __importDefault(require("../format/is-debug-node"));
var func_parse_find_args_name_1 = __importDefault(require("../func.parse-find-args-name"));
var func_parse_find_args_1 = __importDefault(require("./func.parse-find-args"));
var func_parse_find_term_1 = __importDefault(require("./func.parse-find-term"));
var defaultNotFoundValue = {}; // simulating Symbol
exports.default = (function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var _a = __read((0, func_parse_find_args_1.default)(args, defaultNotFoundValue), 3), el = _a[0], sel = _a[1], notFoundValue = _a[2];
    var result = (0, is_debug_node_1.default)(sel) ? sel : el === null || el === void 0 ? void 0 : el.query((0, func_parse_find_term_1.default)(sel));
    if (result) {
        return result;
    }
    if (notFoundValue !== defaultNotFoundValue) {
        return notFoundValue;
    }
    throw new Error("Cannot find an element via ngMocks.find(" + (0, func_parse_find_args_name_1.default)(sel) + ")");
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1oZWxwZXIuZmluZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9tb2NrLWhlbHBlci9maW5kL21vY2staGVscGVyLmZpbmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsMEVBQWtEO0FBQ2xELDJGQUFpRTtBQUVqRSxnRkFBdUQ7QUFDdkQsZ0ZBQXVEO0FBRXZELElBQU0sb0JBQW9CLEdBQUcsRUFBRSxDQUFDLENBQUMsb0JBQW9CO0FBRXJELG1CQUFlO0lBQUMsY0FBYztTQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7UUFBZCx5QkFBYzs7SUFDdEIsSUFBQSxLQUFBLE9BQTJCLElBQUEsOEJBQWlCLEVBQUMsSUFBSSxFQUFFLG9CQUFvQixDQUFDLElBQUEsRUFBdkUsRUFBRSxRQUFBLEVBQUUsR0FBRyxRQUFBLEVBQUUsYUFBYSxRQUFpRCxDQUFDO0lBQy9FLElBQU0sTUFBTSxHQUFHLElBQUEsdUJBQVcsRUFBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQUYsRUFBRSx1QkFBRixFQUFFLENBQUUsS0FBSyxDQUFDLElBQUEsOEJBQWlCLEVBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMxRSxJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFDRCxJQUFJLGFBQWEsS0FBSyxvQkFBb0IsRUFBRTtRQUMxQyxPQUFPLGFBQWEsQ0FBQztLQUN0QjtJQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTJDLElBQUEsbUNBQXFCLEVBQUMsR0FBRyxDQUFDLE1BQUcsQ0FBQyxDQUFDO0FBQzVGLENBQUMsRUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlYnVnRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgaXNEZWJ1Z05vZGUgZnJvbSAnLi4vZm9ybWF0L2lzLWRlYnVnLW5vZGUnO1xuaW1wb3J0IGZ1bmNQYXJzZUZpbmRBcmdzTmFtZSBmcm9tICcuLi9mdW5jLnBhcnNlLWZpbmQtYXJncy1uYW1lJztcblxuaW1wb3J0IGZ1bmNQYXJzZUZpbmRBcmdzIGZyb20gJy4vZnVuYy5wYXJzZS1maW5kLWFyZ3MnO1xuaW1wb3J0IGZ1bmNQYXJzZUZpbmRUZXJtIGZyb20gJy4vZnVuYy5wYXJzZS1maW5kLXRlcm0nO1xuXG5jb25zdCBkZWZhdWx0Tm90Rm91bmRWYWx1ZSA9IHt9OyAvLyBzaW11bGF0aW5nIFN5bWJvbFxuXG5leHBvcnQgZGVmYXVsdCAoLi4uYXJnczogYW55W10pOiBEZWJ1Z0VsZW1lbnQgPT4ge1xuICBjb25zdCBbZWwsIHNlbCwgbm90Rm91bmRWYWx1ZV0gPSBmdW5jUGFyc2VGaW5kQXJncyhhcmdzLCBkZWZhdWx0Tm90Rm91bmRWYWx1ZSk7XG4gIGNvbnN0IHJlc3VsdCA9IGlzRGVidWdOb2RlKHNlbCkgPyBzZWwgOiBlbD8ucXVlcnkoZnVuY1BhcnNlRmluZFRlcm0oc2VsKSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChub3RGb3VuZFZhbHVlICE9PSBkZWZhdWx0Tm90Rm91bmRWYWx1ZSkge1xuICAgIHJldHVybiBub3RGb3VuZFZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW4gZWxlbWVudCB2aWEgbmdNb2Nrcy5maW5kKCR7ZnVuY1BhcnNlRmluZEFyZ3NOYW1lKHNlbCl9KWApO1xufTtcbiJdfQ==