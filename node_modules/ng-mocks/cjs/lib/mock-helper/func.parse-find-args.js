"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_debug_node_1 = __importDefault(require("./format/is-debug-node"));
var is_fixture_1 = __importDefault(require("./format/is-fixture"));
var func_get_last_fixture_1 = __importDefault(require("./func.get-last-fixture"));
var isSelector = function (value) {
    if (typeof value === 'string') {
        return true;
    }
    if (Array.isArray(value) && typeof value[0] === 'string') {
        return true;
    }
    if ((0, is_fixture_1.default)(value)) {
        return true;
    }
    if ((0, is_debug_node_1.default)(value)) {
        return true;
    }
    return true;
};
exports.default = (function (args, isValidValue, defaultNotFoundValue) {
    var _a, _b, _c, _d;
    var el;
    var sel;
    var notFoundValue = defaultNotFoundValue;
    if (args.length === 3) {
        _a = __read(args, 3), el = _a[0], sel = _a[1], notFoundValue = _a[2];
    }
    else if (args.length === 1) {
        el = (0, func_get_last_fixture_1.default)();
        _b = __read(args, 1), sel = _b[0];
    }
    else if (isValidValue(args[1]) && isSelector(args[0])) {
        _c = __read(args, 2), el = _c[0], sel = _c[1];
    }
    else {
        el = (0, func_get_last_fixture_1.default)();
        _d = __read(args, 2), sel = _d[0], notFoundValue = _d[1];
    }
    return [el, sel, notFoundValue];
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuYy5wYXJzZS1maW5kLWFyZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1oZWxwZXIvZnVuYy5wYXJzZS1maW5kLWFyZ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUVBQWlEO0FBQ2pELG1FQUE0QztBQUM1QyxrRkFBeUQ7QUFFekQsSUFBTSxVQUFVLEdBQUcsVUFBQyxLQUFVO0lBQzVCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFO1FBQ3hELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLElBQUEsb0JBQVMsRUFBQyxLQUFLLENBQUMsRUFBRTtRQUNwQixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsSUFBSSxJQUFBLHVCQUFXLEVBQUMsS0FBSyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxDQUFDO0FBRUYsbUJBQWUsVUFBQyxJQUFXLEVBQUUsWUFBcUMsRUFBRSxvQkFBMEI7O0lBQzVGLElBQUksRUFBRSxDQUFDO0lBQ1AsSUFBSSxHQUFHLENBQUM7SUFDUixJQUFJLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQztJQUN6QyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLEtBQUEsT0FBMkIsSUFBSSxJQUFBLEVBQTlCLEVBQUUsUUFBQSxFQUFFLEdBQUcsUUFBQSxFQUFFLGFBQWEsUUFBQSxDQUFTO0tBQ2pDO1NBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM1QixFQUFFLEdBQUcsSUFBQSwrQkFBa0IsR0FBRSxDQUFDO1FBQzFCLEtBQUEsT0FBUSxJQUFJLElBQUEsRUFBWCxHQUFHLFFBQUEsQ0FBUztLQUNkO1NBQU0sSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3ZELEtBQUEsT0FBWSxJQUFJLElBQUEsRUFBZixFQUFFLFFBQUEsRUFBRSxHQUFHLFFBQUEsQ0FBUztLQUNsQjtTQUFNO1FBQ0wsRUFBRSxHQUFHLElBQUEsK0JBQWtCLEdBQUUsQ0FBQztRQUMxQixLQUFBLE9BQXVCLElBQUksSUFBQSxFQUExQixHQUFHLFFBQUEsRUFBRSxhQUFhLFFBQUEsQ0FBUztLQUM3QjtJQUVELE9BQU8sQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQ2xDLENBQUMsRUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc0RlYnVnTm9kZSBmcm9tICcuL2Zvcm1hdC9pcy1kZWJ1Zy1ub2RlJztcbmltcG9ydCBpc0ZpeHR1cmUgZnJvbSAnLi9mb3JtYXQvaXMtZml4dHVyZSc7XG5pbXBvcnQgZnVuY0dldExhc3RGaXh0dXJlIGZyb20gJy4vZnVuYy5nZXQtbGFzdC1maXh0dXJlJztcblxuY29uc3QgaXNTZWxlY3RvciA9ICh2YWx1ZTogYW55KTogYm9vbGVhbiA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNGaXh0dXJlKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0RlYnVnTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKGFyZ3M6IGFueVtdLCBpc1ZhbGlkVmFsdWU6ICh2YWx1ZTogYW55KSA9PiBib29sZWFuLCBkZWZhdWx0Tm90Rm91bmRWYWx1ZT86IGFueSk6IFthbnksIGFueSwgYW55XSA9PiB7XG4gIGxldCBlbDtcbiAgbGV0IHNlbDtcbiAgbGV0IG5vdEZvdW5kVmFsdWUgPSBkZWZhdWx0Tm90Rm91bmRWYWx1ZTtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgW2VsLCBzZWwsIG5vdEZvdW5kVmFsdWVdID0gYXJncztcbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIGVsID0gZnVuY0dldExhc3RGaXh0dXJlKCk7XG4gICAgW3NlbF0gPSBhcmdzO1xuICB9IGVsc2UgaWYgKGlzVmFsaWRWYWx1ZShhcmdzWzFdKSAmJiBpc1NlbGVjdG9yKGFyZ3NbMF0pKSB7XG4gICAgW2VsLCBzZWxdID0gYXJncztcbiAgfSBlbHNlIHtcbiAgICBlbCA9IGZ1bmNHZXRMYXN0Rml4dHVyZSgpO1xuICAgIFtzZWwsIG5vdEZvdW5kVmFsdWVdID0gYXJncztcbiAgfVxuXG4gIHJldHVybiBbZWwsIHNlbCwgbm90Rm91bmRWYWx1ZV07XG59O1xuIl19