"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var detect_text_node_1 = __importDefault(require("./detect-text-node"));
var el_def_compare_1 = __importDefault(require("./el-def-compare"));
var el_def_get_node_1 = __importDefault(require("./el-def-get-node"));
var el_def_get_parent_1 = __importDefault(require("./el-def-get-parent"));
var nested_check_children_1 = __importDefault(require("./nested-check-children"));
var detectParent = function (node, parent) {
    var e_1, _a;
    var _b;
    if (parent) {
        return parent;
    }
    var expected = (0, el_def_get_parent_1.default)(node);
    var currentParent = node.parent ? (0, el_def_get_node_1.default)(node.parent) : undefined;
    if (node.parent && (0, el_def_compare_1.default)(expected, currentParent)) {
        return node.parent;
    }
    try {
        for (var _c = __values(((_b = node.parent) === null || _b === void 0 ? void 0 : _b.childNodes) || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var childNode = _d.value;
            var childElDef = (0, el_def_get_node_1.default)(childNode);
            if ((0, el_def_compare_1.default)(expected, childElDef)) {
                return childNode;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
};
var nestedCheck = function (node, parent, check, includeTextNode) {
    var e_2, _a;
    if (includeTextNode === void 0) { includeTextNode = false; }
    if (!node) {
        return false;
    }
    if (!includeTextNode && (0, detect_text_node_1.default)(node)) {
        return false;
    }
    if (check(node, detectParent(node, parent))) {
        return true;
    }
    try {
        for (var _b = __values((0, nested_check_children_1.default)(node)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var childNode = _c.value;
            if (nestedCheck(childNode, node, check, includeTextNode)) {
                return true;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return false;
};
exports.default = (function () { return nestedCheck; })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdGVkLWNoZWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZy1tb2Nrcy9zcmMvbGliL21vY2staGVscGVyL2NyYXdsL25lc3RlZC1jaGVjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsd0VBQWdEO0FBQ2hELG9FQUE0QztBQUM1QyxzRUFBNkM7QUFDN0MsMEVBQWlEO0FBQ2pELGtGQUEwRDtBQUUxRCxJQUFNLFlBQVksR0FBRyxVQUFDLElBQXFCLEVBQUUsTUFBbUM7OztJQUM5RSxJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFFRCxJQUFNLFFBQVEsR0FBRyxJQUFBLDJCQUFjLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEMsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBQSx5QkFBWSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzFFLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFBLHdCQUFZLEVBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQyxFQUFFO1FBQ3hELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjs7UUFDRCxLQUF3QixJQUFBLEtBQUEsU0FBQSxDQUFBLE1BQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsVUFBVSxLQUFJLEVBQUUsQ0FBQSxnQkFBQSw0QkFBRTtZQUFsRCxJQUFNLFNBQVMsV0FBQTtZQUNsQixJQUFNLFVBQVUsR0FBRyxJQUFBLHlCQUFZLEVBQUMsU0FBUyxDQUFDLENBQUM7WUFDM0MsSUFBSSxJQUFBLHdCQUFZLEVBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxFQUFFO2dCQUN0QyxPQUFPLFNBQVMsQ0FBQzthQUNsQjtTQUNGOzs7Ozs7Ozs7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFRixJQUFNLFdBQVcsR0FBRyxVQUNsQixJQUF3QyxFQUN4QyxNQUFtQyxFQUNuQyxLQUEwRSxFQUMxRSxlQUF1Qjs7SUFBdkIsZ0NBQUEsRUFBQSx1QkFBdUI7SUFFdkIsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUEsMEJBQWMsRUFBQyxJQUFJLENBQUMsRUFBRTtRQUM1QyxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRTtRQUMzQyxPQUFPLElBQUksQ0FBQztLQUNiOztRQUVELEtBQXdCLElBQUEsS0FBQSxTQUFBLElBQUEsK0JBQW1CLEVBQUMsSUFBSSxDQUFDLENBQUEsZ0JBQUEsNEJBQUU7WUFBOUMsSUFBTSxTQUFTLFdBQUE7WUFDbEIsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsZUFBZSxDQUFDLEVBQUU7Z0JBQ3hELE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjs7Ozs7Ozs7O0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUM7QUFFRixrQkFBZSxDQUFDLGNBQTBCLE9BQUEsV0FBVyxFQUFYLENBQVcsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb2NrZWREZWJ1Z05vZGUgfSBmcm9tICcuLi8uLi9tb2NrLXJlbmRlci90eXBlcyc7XG5cbmltcG9ydCBkZXRlY3RUZXh0Tm9kZSBmcm9tICcuL2RldGVjdC10ZXh0LW5vZGUnO1xuaW1wb3J0IGVsRGVmQ29tcGFyZSBmcm9tICcuL2VsLWRlZi1jb21wYXJlJztcbmltcG9ydCBlbERlZkdldE5vZGUgZnJvbSAnLi9lbC1kZWYtZ2V0LW5vZGUnO1xuaW1wb3J0IGVsRGVmR2V0UGFyZW50IGZyb20gJy4vZWwtZGVmLWdldC1wYXJlbnQnO1xuaW1wb3J0IG5lc3RlZENoZWNrQ2hpbGRyZW4gZnJvbSAnLi9uZXN0ZWQtY2hlY2stY2hpbGRyZW4nO1xuXG5jb25zdCBkZXRlY3RQYXJlbnQgPSAobm9kZTogTW9ja2VkRGVidWdOb2RlLCBwYXJlbnQ6IE1vY2tlZERlYnVnTm9kZSB8IHVuZGVmaW5lZCk6IE1vY2tlZERlYnVnTm9kZSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgY29uc3QgZXhwZWN0ZWQgPSBlbERlZkdldFBhcmVudChub2RlKTtcbiAgY29uc3QgY3VycmVudFBhcmVudCA9IG5vZGUucGFyZW50ID8gZWxEZWZHZXROb2RlKG5vZGUucGFyZW50KSA6IHVuZGVmaW5lZDtcbiAgaWYgKG5vZGUucGFyZW50ICYmIGVsRGVmQ29tcGFyZShleHBlY3RlZCwgY3VycmVudFBhcmVudCkpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnQ7XG4gIH1cbiAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2Ygbm9kZS5wYXJlbnQ/LmNoaWxkTm9kZXMgfHwgW10pIHtcbiAgICBjb25zdCBjaGlsZEVsRGVmID0gZWxEZWZHZXROb2RlKGNoaWxkTm9kZSk7XG4gICAgaWYgKGVsRGVmQ29tcGFyZShleHBlY3RlZCwgY2hpbGRFbERlZikpIHtcbiAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IG5lc3RlZENoZWNrID0gKFxuICBub2RlOiBNb2NrZWREZWJ1Z05vZGUgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBwYXJlbnQ6IE1vY2tlZERlYnVnTm9kZSB8IHVuZGVmaW5lZCxcbiAgY2hlY2s6IChub2RlOiBNb2NrZWREZWJ1Z05vZGUsIHBhcmVudD86IE1vY2tlZERlYnVnTm9kZSkgPT4gdm9pZCB8IGJvb2xlYW4sXG4gIGluY2x1ZGVUZXh0Tm9kZSA9IGZhbHNlLFxuKTogYm9vbGVhbiA9PiB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWluY2x1ZGVUZXh0Tm9kZSAmJiBkZXRlY3RUZXh0Tm9kZShub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY2hlY2sobm9kZSwgZGV0ZWN0UGFyZW50KG5vZGUsIHBhcmVudCkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBuZXN0ZWRDaGVja0NoaWxkcmVuKG5vZGUpKSB7XG4gICAgaWYgKG5lc3RlZENoZWNrKGNoaWxkTm9kZSwgbm9kZSwgY2hlY2ssIGluY2x1ZGVUZXh0Tm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0ICgoKTogdHlwZW9mIG5lc3RlZENoZWNrID0+IG5lc3RlZENoZWNrKSgpO1xuIl19