"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var func_get_public_provider_keys_1 = __importDefault(require("./func.get-public-provider-keys"));
var func_parse_inputs_and_requires_attributes_1 = __importDefault(require("./func.parse-inputs-and-requires-attributes"));
var detectInClassic = function (node, attribute, value) {
    var e_1, _a, e_2, _b;
    try {
        for (var _c = __values((0, func_get_public_provider_keys_1.default)(node)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var key = _d.value;
            var _e = __read((0, func_parse_inputs_and_requires_attributes_1.default)(node, key), 3), inputs = _e[0], expectedAttributes = _e[1], nodeIndex = _e[2];
            try {
                for (var inputs_1 = (e_2 = void 0, __values(inputs)), inputs_1_1 = inputs_1.next(); !inputs_1_1.done; inputs_1_1 = inputs_1.next()) {
                    var input = inputs_1_1.value;
                    var _f = __read(input.split(': '), 2), prop = _f[0], alias = _f[1];
                    if (attribute !== (alias || prop) || expectedAttributes.indexOf(prop) === -1) {
                        continue;
                    }
                    if (value === node.injector.view.nodes[nodeIndex].instance[prop]) {
                        return true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (inputs_1_1 && !inputs_1_1.done && (_b = inputs_1.return)) _b.call(inputs_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
};
var detectInIvy = function (node, attribute, value) {
    var _a, _b, _c;
    var attrs = ((_a = node.injector._tNode) === null || _a === void 0 ? void 0 : _a.attrs) || [];
    var step = 2;
    for (var index = 0; index < attrs.length; index += step) {
        // 3 is a divider between static and dynamic bindings
        if (typeof attrs[index] === 'number') {
            step = 1;
            continue;
        }
        var attr = attrs[index];
        if (attr !== attribute || !((_b = node.injector._tNode.inputs) === null || _b === void 0 ? void 0 : _b[attr])) {
            continue;
        }
        var _d = __read(node.injector._tNode.inputs[attr], 2), attrIndex = _d[0], attrProp = _d[1];
        if (value === ((_c = node.injector._lView) === null || _c === void 0 ? void 0 : _c[attrIndex][attrProp])) {
            return true;
        }
    }
    return false;
};
exports.default = (function (attribute, value) {
    return function (node) {
        if (detectInClassic(node, attribute, value)) {
            return true;
        }
        return detectInIvy(node, attribute, value);
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3Jhd2wtYnktYXR0cmlidXRlLXZhbHVlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZy1tb2Nrcy9zcmMvbGliL21vY2staGVscGVyL2NyYXdsL2NyYXdsLWJ5LWF0dHJpYnV0ZS12YWx1ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLGtHQUF3RTtBQUN4RSwwSEFBK0Y7QUFFL0YsSUFBTSxlQUFlLEdBQUcsVUFBQyxJQUFxQixFQUFFLFNBQWlCLEVBQUUsS0FBVTs7O1FBQzNFLEtBQWtCLElBQUEsS0FBQSxTQUFBLElBQUEsdUNBQXlCLEVBQUMsSUFBSSxDQUFDLENBQUEsZ0JBQUEsNEJBQUU7WUFBOUMsSUFBTSxHQUFHLFdBQUE7WUFDTixJQUFBLEtBQUEsT0FBMEMsSUFBQSxtREFBb0MsRUFBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUEsRUFBeEYsTUFBTSxRQUFBLEVBQUUsa0JBQWtCLFFBQUEsRUFBRSxTQUFTLFFBQW1ELENBQUM7O2dCQUNoRyxLQUFvQixJQUFBLDBCQUFBLFNBQUEsTUFBTSxDQUFBLENBQUEsOEJBQUEsa0RBQUU7b0JBQXZCLElBQU0sS0FBSyxtQkFBQTtvQkFDUixJQUFBLEtBQUEsT0FBZ0IsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBQSxFQUFoQyxJQUFJLFFBQUEsRUFBRSxLQUFLLFFBQXFCLENBQUM7b0JBQ3hDLElBQUksU0FBUyxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTt3QkFDNUUsU0FBUztxQkFDVjtvQkFDRCxJQUFJLEtBQUssS0FBTSxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDekUsT0FBTyxJQUFJLENBQUM7cUJBQ2I7aUJBQ0Y7Ozs7Ozs7OztTQUNGOzs7Ozs7Ozs7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMsQ0FBQztBQUVGLElBQU0sV0FBVyxHQUFHLFVBQUMsSUFBcUIsRUFBRSxTQUFpQixFQUFFLEtBQVU7O0lBQ3ZFLElBQU0sS0FBSyxHQUFHLENBQUEsTUFBQyxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxNQUFNLDBDQUFFLEtBQUssS0FBSSxFQUFFLENBQUM7SUFDekQsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ2IsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxJQUFJLElBQUksRUFBRTtRQUN2RCxxREFBcUQ7UUFDckQsSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDcEMsSUFBSSxHQUFHLENBQUMsQ0FBQztZQUNULFNBQVM7U0FDVjtRQUNELElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQixJQUFJLElBQUksS0FBSyxTQUFTLElBQUksQ0FBQyxDQUFBLE1BQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sMENBQUcsSUFBSSxDQUFDLENBQUEsRUFBRTtZQUN2RSxTQUFTO1NBQ1Y7UUFDSyxJQUFBLEtBQUEsT0FBeUIsSUFBSSxDQUFDLFFBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBQSxFQUFqRSxTQUFTLFFBQUEsRUFBRSxRQUFRLFFBQThDLENBQUM7UUFFekUsSUFBSSxLQUFLLE1BQUssTUFBQyxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxNQUFNLDBDQUFHLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQSxFQUFFO1lBQ2xFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7S0FDRjtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBRUYsbUJBQWUsVUFBQyxTQUFpQixFQUFFLEtBQVU7SUFDM0MsT0FBQSxVQUFBLElBQUk7UUFDRixJQUFJLGVBQWUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQzNDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLFdBQVcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzdDLENBQUM7QUFORCxDQU1DLEVBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb2NrZWREZWJ1Z05vZGUgfSBmcm9tICcuLi8uLi9tb2NrLXJlbmRlci90eXBlcyc7XG5cbmltcG9ydCBmdW5jR2V0UHVibGljUHJvdmlkZXJLZXlzIGZyb20gJy4vZnVuYy5nZXQtcHVibGljLXByb3ZpZGVyLWtleXMnO1xuaW1wb3J0IGZ1bmNQYXJzZUlucHV0c0FuZFJlcXVpcmVzQXR0cmlidXRlcyBmcm9tICcuL2Z1bmMucGFyc2UtaW5wdXRzLWFuZC1yZXF1aXJlcy1hdHRyaWJ1dGVzJztcblxuY29uc3QgZGV0ZWN0SW5DbGFzc2ljID0gKG5vZGU6IE1vY2tlZERlYnVnTm9kZSwgYXR0cmlidXRlOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgZm9yIChjb25zdCBrZXkgb2YgZnVuY0dldFB1YmxpY1Byb3ZpZGVyS2V5cyhub2RlKSkge1xuICAgIGNvbnN0IFtpbnB1dHMsIGV4cGVjdGVkQXR0cmlidXRlcywgbm9kZUluZGV4XSA9IGZ1bmNQYXJzZUlucHV0c0FuZFJlcXVpcmVzQXR0cmlidXRlcyhub2RlLCBrZXkpO1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBjb25zdCBbcHJvcCwgYWxpYXNdID0gaW5wdXQuc3BsaXQoJzogJyk7XG4gICAgICBpZiAoYXR0cmlidXRlICE9PSAoYWxpYXMgfHwgcHJvcCkgfHwgZXhwZWN0ZWRBdHRyaWJ1dGVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAobm9kZS5pbmplY3RvciBhcyBhbnkpLnZpZXcubm9kZXNbbm9kZUluZGV4XS5pbnN0YW5jZVtwcm9wXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBkZXRlY3RJbkl2eSA9IChub2RlOiBNb2NrZWREZWJ1Z05vZGUsIGF0dHJpYnV0ZTogc3RyaW5nLCB2YWx1ZTogYW55KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGF0dHJzID0gKG5vZGUuaW5qZWN0b3IgYXMgYW55KS5fdE5vZGU/LmF0dHJzIHx8IFtdO1xuICBsZXQgc3RlcCA9IDI7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRycy5sZW5ndGg7IGluZGV4ICs9IHN0ZXApIHtcbiAgICAvLyAzIGlzIGEgZGl2aWRlciBiZXR3ZWVuIHN0YXRpYyBhbmQgZHluYW1pYyBiaW5kaW5nc1xuICAgIGlmICh0eXBlb2YgYXR0cnNbaW5kZXhdID09PSAnbnVtYmVyJykge1xuICAgICAgc3RlcCA9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYXR0ciA9IGF0dHJzW2luZGV4XTtcbiAgICBpZiAoYXR0ciAhPT0gYXR0cmlidXRlIHx8ICEobm9kZS5pbmplY3RvciBhcyBhbnkpLl90Tm9kZS5pbnB1dHM/LlthdHRyXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IFthdHRySW5kZXgsIGF0dHJQcm9wXSA9IChub2RlLmluamVjdG9yIGFzIGFueSkuX3ROb2RlLmlucHV0c1thdHRyXTtcblxuICAgIGlmICh2YWx1ZSA9PT0gKG5vZGUuaW5qZWN0b3IgYXMgYW55KS5fbFZpZXc/LlthdHRySW5kZXhdW2F0dHJQcm9wXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKGF0dHJpYnV0ZTogc3RyaW5nLCB2YWx1ZTogYW55KTogKChub2RlOiBNb2NrZWREZWJ1Z05vZGUpID0+IGJvb2xlYW4pID0+XG4gIG5vZGUgPT4ge1xuICAgIGlmIChkZXRlY3RJbkNsYXNzaWMobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZXRlY3RJbkl2eShub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgfTtcbiJdfQ==