"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var func_parse_provider_tokens_directives_1 = __importDefault(require("../func.parse-provider-tokens-directives"));
var func_get_public_provider_keys_1 = __importDefault(require("./func.get-public-provider-keys"));
var func_parse_inputs_and_requires_attributes_1 = __importDefault(require("./func.parse-inputs-and-requires-attributes"));
var collectSelectors = function (node) {
    var e_1, _a;
    var selectors = [];
    try {
        for (var _b = __values(node.providerTokens), _c = _b.next(); !_c.done; _c = _b.next()) {
            var token = _c.value;
            var meta = (0, func_parse_provider_tokens_directives_1.default)(node, token);
            if ((meta === null || meta === void 0 ? void 0 : meta.selector) && selectors.indexOf(meta.selector) === -1) {
                selectors.push(meta.selector);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return selectors;
};
var collectAttributesClassic = function (node) {
    var e_2, _a, e_3, _b;
    var result = [];
    try {
        for (var _c = __values((0, func_get_public_provider_keys_1.default)(node)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var key = _d.value;
            var _e = __read((0, func_parse_inputs_and_requires_attributes_1.default)(node, key), 2), inputs = _e[0], expectedAttributes = _e[1];
            try {
                for (var inputs_1 = (e_3 = void 0, __values(inputs)), inputs_1_1 = inputs_1.next(); !inputs_1_1.done; inputs_1_1 = inputs_1.next()) {
                    var input = inputs_1_1.value;
                    var _f = __read(input.split(': '), 2), prop = _f[0], alias = _f[1];
                    var attr = alias || prop;
                    if (expectedAttributes.indexOf(prop) !== -1 && result.indexOf(attr) === -1) {
                        result.push(attr);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (inputs_1_1 && !inputs_1_1.done && (_b = inputs_1.return)) _b.call(inputs_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return result;
};
var collectAttributesIvy = function (node) {
    var _a, _b;
    var result = [];
    var attrs = ((_a = node.injector._tNode) === null || _a === void 0 ? void 0 : _a.attrs) || [];
    var step = 2;
    for (var index = 0; index < attrs.length; index += step) {
        // 3 is a divider between static and dynamic bindings
        if (typeof attrs[index] === 'number') {
            step = 1;
            continue;
        }
        var attr = attrs[index];
        if (((_b = node.injector._tNode.inputs) === null || _b === void 0 ? void 0 : _b[attr]) && result.indexOf(attr) === -1) {
            result.push(attr);
        }
    }
    return result;
};
exports.default = (function (node) {
    var selectors = collectSelectors(node);
    var attributes = __spreadArray(__spreadArray([], __read(collectAttributesClassic(node)), false), __read(collectAttributesIvy(node)), false);
    return [selectors, attributes];
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV0ZWN0LXNlbGVjdG9ycy1mcm9tLW5vZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1oZWxwZXIvY3Jhd2wvZGV0ZWN0LXNlbGVjdG9ycy1mcm9tLW5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxtSEFBeUY7QUFFekYsa0dBQXdFO0FBQ3hFLDBIQUErRjtBQUUvRixJQUFNLGdCQUFnQixHQUFHLFVBQUMsSUFBcUI7O0lBQzdDLElBQU0sU0FBUyxHQUFhLEVBQUUsQ0FBQzs7UUFFL0IsS0FBb0IsSUFBQSxLQUFBLFNBQUEsSUFBSSxDQUFDLGNBQWMsQ0FBQSxnQkFBQSw0QkFBRTtZQUFwQyxJQUFNLEtBQUssV0FBQTtZQUNkLElBQU0sSUFBSSxHQUFHLElBQUEsK0NBQWlDLEVBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzVELElBQUksQ0FBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsUUFBUSxLQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUM3RCxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMvQjtTQUNGOzs7Ozs7Ozs7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFRixJQUFNLHdCQUF3QixHQUFHLFVBQUMsSUFBcUI7O0lBQ3JELElBQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQzs7UUFFNUIsS0FBa0IsSUFBQSxLQUFBLFNBQUEsSUFBQSx1Q0FBeUIsRUFBQyxJQUFJLENBQUMsQ0FBQSxnQkFBQSw0QkFBRTtZQUE5QyxJQUFNLEdBQUcsV0FBQTtZQUNOLElBQUEsS0FBQSxPQUErQixJQUFBLG1EQUFvQyxFQUFDLElBQUksRUFBRSxHQUFHLENBQUMsSUFBQSxFQUE3RSxNQUFNLFFBQUEsRUFBRSxrQkFBa0IsUUFBbUQsQ0FBQzs7Z0JBQ3JGLEtBQW9CLElBQUEsMEJBQUEsU0FBQSxNQUFNLENBQUEsQ0FBQSw4QkFBQSxrREFBRTtvQkFBdkIsSUFBTSxLQUFLLG1CQUFBO29CQUNSLElBQUEsS0FBQSxPQUFnQixLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFBLEVBQWhDLElBQUksUUFBQSxFQUFFLEtBQUssUUFBcUIsQ0FBQztvQkFDeEMsSUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQztvQkFDM0IsSUFBSSxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTt3QkFDMUUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDbkI7aUJBQ0Y7Ozs7Ozs7OztTQUNGOzs7Ozs7Ozs7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDLENBQUM7QUFFRixJQUFNLG9CQUFvQixHQUFHLFVBQUMsSUFBcUI7O0lBQ2pELElBQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztJQUU1QixJQUFNLEtBQUssR0FBRyxDQUFBLE1BQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsTUFBTSwwQ0FBRSxLQUFLLEtBQUksRUFBRSxDQUFDO0lBQ3pELElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLEtBQUssSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssSUFBSSxJQUFJLEVBQUU7UUFDdkQscURBQXFEO1FBQ3JELElBQUksT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxFQUFFO1lBQ3BDLElBQUksR0FBRyxDQUFDLENBQUM7WUFDVCxTQUFTO1NBQ1Y7UUFDRCxJQUFNLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFBLE1BQUMsSUFBSSxDQUFDLFFBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sMENBQUcsSUFBSSxDQUFDLEtBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUMvRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25CO0tBQ0Y7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDLENBQUM7QUFFRixtQkFBZSxVQUFDLElBQXFCO0lBQ25DLElBQU0sU0FBUyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pDLElBQU0sVUFBVSwwQ0FBTyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsa0JBQUssb0JBQW9CLENBQUMsSUFBSSxDQUFDLFNBQUMsQ0FBQztJQUV0RixPQUFPLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ2pDLENBQUMsRUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1vY2tlZERlYnVnTm9kZSB9IGZyb20gJy4uLy4uL21vY2stcmVuZGVyL3R5cGVzJztcbmltcG9ydCBmdW5jUGFyc2VQcm92aWRlclRva2Vuc0RpcmVjdGl2ZXMgZnJvbSAnLi4vZnVuYy5wYXJzZS1wcm92aWRlci10b2tlbnMtZGlyZWN0aXZlcyc7XG5cbmltcG9ydCBmdW5jR2V0UHVibGljUHJvdmlkZXJLZXlzIGZyb20gJy4vZnVuYy5nZXQtcHVibGljLXByb3ZpZGVyLWtleXMnO1xuaW1wb3J0IGZ1bmNQYXJzZUlucHV0c0FuZFJlcXVpcmVzQXR0cmlidXRlcyBmcm9tICcuL2Z1bmMucGFyc2UtaW5wdXRzLWFuZC1yZXF1aXJlcy1hdHRyaWJ1dGVzJztcblxuY29uc3QgY29sbGVjdFNlbGVjdG9ycyA9IChub2RlOiBNb2NrZWREZWJ1Z05vZGUpOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IHNlbGVjdG9yczogc3RyaW5nW10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHRva2VuIG9mIG5vZGUucHJvdmlkZXJUb2tlbnMpIHtcbiAgICBjb25zdCBtZXRhID0gZnVuY1BhcnNlUHJvdmlkZXJUb2tlbnNEaXJlY3RpdmVzKG5vZGUsIHRva2VuKTtcbiAgICBpZiAobWV0YT8uc2VsZWN0b3IgJiYgc2VsZWN0b3JzLmluZGV4T2YobWV0YS5zZWxlY3RvcikgPT09IC0xKSB7XG4gICAgICBzZWxlY3RvcnMucHVzaChtZXRhLnNlbGVjdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZWN0b3JzO1xufTtcblxuY29uc3QgY29sbGVjdEF0dHJpYnV0ZXNDbGFzc2ljID0gKG5vZGU6IE1vY2tlZERlYnVnTm9kZSk6IHN0cmluZ1tdID0+IHtcbiAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGZ1bmNHZXRQdWJsaWNQcm92aWRlcktleXMobm9kZSkpIHtcbiAgICBjb25zdCBbaW5wdXRzLCBleHBlY3RlZEF0dHJpYnV0ZXNdID0gZnVuY1BhcnNlSW5wdXRzQW5kUmVxdWlyZXNBdHRyaWJ1dGVzKG5vZGUsIGtleSk7XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGNvbnN0IFtwcm9wLCBhbGlhc10gPSBpbnB1dC5zcGxpdCgnOiAnKTtcbiAgICAgIGNvbnN0IGF0dHIgPSBhbGlhcyB8fCBwcm9wO1xuICAgICAgaWYgKGV4cGVjdGVkQXR0cmlidXRlcy5pbmRleE9mKHByb3ApICE9PSAtMSAmJiByZXN1bHQuaW5kZXhPZihhdHRyKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGNvbGxlY3RBdHRyaWJ1dGVzSXZ5ID0gKG5vZGU6IE1vY2tlZERlYnVnTm9kZSk6IHN0cmluZ1tdID0+IHtcbiAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0IGF0dHJzID0gKG5vZGUuaW5qZWN0b3IgYXMgYW55KS5fdE5vZGU/LmF0dHJzIHx8IFtdO1xuICBsZXQgc3RlcCA9IDI7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRycy5sZW5ndGg7IGluZGV4ICs9IHN0ZXApIHtcbiAgICAvLyAzIGlzIGEgZGl2aWRlciBiZXR3ZWVuIHN0YXRpYyBhbmQgZHluYW1pYyBiaW5kaW5nc1xuICAgIGlmICh0eXBlb2YgYXR0cnNbaW5kZXhdID09PSAnbnVtYmVyJykge1xuICAgICAgc3RlcCA9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYXR0ciA9IGF0dHJzW2luZGV4XTtcbiAgICBpZiAoKG5vZGUuaW5qZWN0b3IgYXMgYW55KS5fdE5vZGUuaW5wdXRzPy5bYXR0cl0gJiYgcmVzdWx0LmluZGV4T2YoYXR0cikgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKG5vZGU6IE1vY2tlZERlYnVnTm9kZSk6IFtzdHJpbmdbXSwgc3RyaW5nW11dID0+IHtcbiAgY29uc3Qgc2VsZWN0b3JzID0gY29sbGVjdFNlbGVjdG9ycyhub2RlKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IFsuLi5jb2xsZWN0QXR0cmlidXRlc0NsYXNzaWMobm9kZSksIC4uLmNvbGxlY3RBdHRyaWJ1dGVzSXZ5KG5vZGUpXTtcblxuICByZXR1cm4gW3NlbGVjdG9ycywgYXR0cmlidXRlc107XG59O1xuIl19