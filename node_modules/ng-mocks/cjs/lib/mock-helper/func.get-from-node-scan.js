"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var detectGatherFlag = function (gather, el, node) {
    // LContainer should stop the scan.
    if (Array.isArray(node)) {
        return false;
    }
    if (!el || !node.nodeName) {
        return gather;
    }
    // checking if a textNode belongs to the current element.
    if (node.nodeName === '#text') {
        return node.parentNode === el.nativeNode;
    }
    return false;
};
var isNotObject = function (node) { return !node || typeof node !== 'object'; };
var shouldBeScanned = function (scanned, node) { return scanned.indexOf(node) === -1 && Array.isArray(node); };
var scan = function (_a, gatherDefault, scanned) {
    var e_1, _b;
    var result = _a.result, el = _a.el, nodes = _a.nodes, normalize = _a.normalize, proto = _a.proto;
    if (scanned === void 0) { scanned = []; }
    scanned.push(nodes);
    var gather = gatherDefault;
    try {
        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
            var raw = nodes_1_1.value;
            var node = normalize(raw);
            if (isNotObject(node)) {
                continue;
            }
            if (shouldBeScanned(scanned, node)) {
                scan({ result: result, el: el, nodes: node, normalize: normalize, proto: proto }, gather, scanned);
            }
            gather = detectGatherFlag(gather, el, node);
            if (!gather) {
                continue;
            }
            if (result.indexOf(node) === -1 && node instanceof proto) {
                result.push(node);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (nodes_1_1 && !nodes_1_1.done && (_b = nodes_1.return)) _b.call(nodes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
exports.default = (function () { return scan; })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuYy5nZXQtZnJvbS1ub2RlLXNjYW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL25nLW1vY2tzL3NyYy9saWIvbW9jay1oZWxwZXIvZnVuYy5nZXQtZnJvbS1ub2RlLXNjYW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUlBLElBQU0sZ0JBQWdCLEdBQUcsVUFBQyxNQUFlLEVBQUUsRUFBb0IsRUFBRSxJQUFTO0lBQ3hFLG1DQUFtQztJQUNuQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdkIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1FBQ3pCLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFFRCx5REFBeUQ7SUFDekQsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQyxVQUFVLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQztLQUMxQztJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBRUYsSUFBTSxXQUFXLEdBQUcsVUFBQyxJQUFTLElBQWMsT0FBQSxDQUFDLElBQUksSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQWpDLENBQWlDLENBQUM7QUFFOUUsSUFBTSxlQUFlLEdBQUcsVUFBQyxPQUFjLEVBQUUsSUFBUyxJQUFjLE9BQUEsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFuRCxDQUFtRCxDQUFDO0FBRXBILElBQU0sSUFBSSxHQUFHLFVBQ1gsRUFZQyxFQUNELGFBQXNCLEVBQ3RCLE9BQW1COztRQWJqQixNQUFNLFlBQUEsRUFDTixFQUFFLFFBQUEsRUFDRixLQUFLLFdBQUEsRUFDTCxTQUFTLGVBQUEsRUFDVCxLQUFLLFdBQUE7SUFTUCx3QkFBQSxFQUFBLFlBQW1CO0lBRW5CLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEIsSUFBSSxNQUFNLEdBQUcsYUFBYSxDQUFDOztRQUUzQixLQUFrQixJQUFBLFVBQUEsU0FBQSxLQUFLLENBQUEsNEJBQUEsK0NBQUU7WUFBcEIsSUFBTSxHQUFHLGtCQUFBO1lBQ1osSUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzVCLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNyQixTQUFTO2FBQ1Y7WUFFRCxJQUFJLGVBQWUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxFQUFFLE1BQU0sUUFBQSxFQUFFLEVBQUUsSUFBQSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsU0FBUyxXQUFBLEVBQUUsS0FBSyxPQUFBLEVBQUUsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDdEU7WUFFRCxNQUFNLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM1QyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNYLFNBQVM7YUFDVjtZQUVELElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLFlBQVksS0FBSyxFQUFFO2dCQUN4RCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ25CO1NBQ0Y7Ozs7Ozs7OztBQUNILENBQUMsQ0FBQztBQUVGLGtCQUFlLENBQUMsY0FBTSxPQUFBLElBQUksRUFBSixDQUFJLENBQUMsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWdOb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFR5cGUgfSBmcm9tICcuLi9jb21tb24vY29yZS50eXBlcyc7XG5cbmNvbnN0IGRldGVjdEdhdGhlckZsYWcgPSAoZ2F0aGVyOiBib29sZWFuLCBlbDogRGVidWdOb2RlIHwgbnVsbCwgbm9kZTogYW55KTogYm9vbGVhbiA9PiB7XG4gIC8vIExDb250YWluZXIgc2hvdWxkIHN0b3AgdGhlIHNjYW4uXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFlbCB8fCAhbm9kZS5ub2RlTmFtZSkge1xuICAgIHJldHVybiBnYXRoZXI7XG4gIH1cblxuICAvLyBjaGVja2luZyBpZiBhIHRleHROb2RlIGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlID09PSBlbC5uYXRpdmVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNOb3RPYmplY3QgPSAobm9kZTogYW55KTogYm9vbGVhbiA9PiAhbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCc7XG5cbmNvbnN0IHNob3VsZEJlU2Nhbm5lZCA9IChzY2FubmVkOiBhbnlbXSwgbm9kZTogYW55KTogYm9vbGVhbiA9PiBzY2FubmVkLmluZGV4T2Yobm9kZSkgPT09IC0xICYmIEFycmF5LmlzQXJyYXkobm9kZSk7XG5cbmNvbnN0IHNjYW4gPSA8VD4oXG4gIHtcbiAgICByZXN1bHQsXG4gICAgZWwsXG4gICAgbm9kZXMsXG4gICAgbm9ybWFsaXplLFxuICAgIHByb3RvLFxuICB9OiB7XG4gICAgZWw6IERlYnVnTm9kZSB8IG51bGw7XG4gICAgbm9kZXM6IGFueVtdO1xuICAgIG5vcm1hbGl6ZTogKGl0ZW06IGFueSkgPT4gYW55O1xuICAgIHByb3RvOiBUeXBlPFQ+O1xuICAgIHJlc3VsdDogVFtdO1xuICB9LFxuICBnYXRoZXJEZWZhdWx0OiBib29sZWFuLFxuICBzY2FubmVkOiBhbnlbXSA9IFtdLFxuKTogdm9pZCA9PiB7XG4gIHNjYW5uZWQucHVzaChub2Rlcyk7XG4gIGxldCBnYXRoZXIgPSBnYXRoZXJEZWZhdWx0O1xuXG4gIGZvciAoY29uc3QgcmF3IG9mIG5vZGVzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vcm1hbGl6ZShyYXcpO1xuICAgIGlmIChpc05vdE9iamVjdChub2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZEJlU2Nhbm5lZChzY2FubmVkLCBub2RlKSkge1xuICAgICAgc2Nhbih7IHJlc3VsdCwgZWwsIG5vZGVzOiBub2RlLCBub3JtYWxpemUsIHByb3RvIH0sIGdhdGhlciwgc2Nhbm5lZCk7XG4gICAgfVxuXG4gICAgZ2F0aGVyID0gZGV0ZWN0R2F0aGVyRmxhZyhnYXRoZXIsIGVsLCBub2RlKTtcbiAgICBpZiAoIWdhdGhlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5pbmRleE9mKG5vZGUpID09PSAtMSAmJiBub2RlIGluc3RhbmNlb2YgcHJvdG8pIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKCgpID0+IHNjYW4pKCk7XG4iXX0=