"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_form_1 = __importDefault(require("../common/core.form"));
var core_helpers_1 = require("../common/core.helpers");
var func_get_provider_1 = __importDefault(require("../common/func.get-provider"));
var mock_control_value_accessor_proxy_1 = require("../common/mock-control-value-accessor-proxy");
var helper_mock_service_1 = __importDefault(require("../mock-service/helper.mock-service"));
var to_existing_provider_1 = __importDefault(require("./to-existing-provider"));
var to_factory_provider_1 = __importDefault(require("./to-factory-provider"));
var processTokens = function (mockType, provider) {
    var provide = (0, func_get_provider_1.default)(provider);
    if (core_form_1.default.NG_VALIDATORS && provide === core_form_1.default.NG_VALIDATORS) {
        return (0, to_factory_provider_1.default)(provide, function () { return new mock_control_value_accessor_proxy_1.MockValidatorProxy(mockType); });
    }
    if (core_form_1.default.NG_ASYNC_VALIDATORS && provide === core_form_1.default.NG_ASYNC_VALIDATORS) {
        return (0, to_factory_provider_1.default)(provide, function () { return new mock_control_value_accessor_proxy_1.MockAsyncValidatorProxy(mockType); });
    }
    if (core_form_1.default.NG_VALUE_ACCESSOR && provide === core_form_1.default.NG_VALUE_ACCESSOR) {
        return (0, to_factory_provider_1.default)(provide, function () { return new mock_control_value_accessor_proxy_1.MockControlValueAccessorProxy(mockType); });
    }
    return undefined;
};
var processOwnUseExisting = function (sourceType, mockType, provider) {
    var provide = (0, func_get_provider_1.default)(provider);
    // Check tests/issue-302/test.spec.ts
    if (provide === core_form_1.default.NgControl || provide === core_form_1.default.FormControlDirective) {
        return undefined;
    }
    if (provider !== provide && provider.useExisting === sourceType) {
        return (0, to_existing_provider_1.default)(provide, mockType);
    }
    if (provider !== provide &&
        provider.useExisting &&
        provider.useExisting.__forward_ref__ &&
        provider.useExisting() === sourceType) {
        return (0, to_existing_provider_1.default)(provide, mockType);
    }
    return undefined;
};
var processProvider = function (sourceType, mockType, provider, resolutions) {
    var token = processTokens(mockType, provider);
    if (token) {
        return token;
    }
    var ownUseExisting = processOwnUseExisting(sourceType, mockType, provider);
    if (ownUseExisting) {
        return ownUseExisting;
    }
    return helper_mock_service_1.default.resolveProvider(provider, resolutions);
};
exports.default = (function (sourceType, mockType, providers) {
    var e_1, _a;
    var result = [];
    var setControlValueAccessor;
    var resolutions = new Map();
    try {
        for (var _b = __values((0, core_helpers_1.flatten)(providers || /* istanbul ignore next */ [])), _c = _b.next(); !_c.done; _c = _b.next()) {
            var provider = _c.value;
            var provide = (0, func_get_provider_1.default)(provider);
            if (provide === core_form_1.default.NG_VALUE_ACCESSOR) {
                setControlValueAccessor = false;
            }
            var mock = processProvider(sourceType, mockType, provider, resolutions);
            if (mock) {
                result.push(mock);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        providers: result,
        setControlValueAccessor: setControlValueAccessor,
    };
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvbmUtcHJvdmlkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZy1tb2Nrcy9zcmMvbGliL21vY2svY2xvbmUtcHJvdmlkZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxrRUFBMkM7QUFDM0MsdURBQWlEO0FBRWpELGtGQUEwRDtBQUMxRCxpR0FJcUQ7QUFDckQsNEZBQW9FO0FBRXBFLGdGQUF3RDtBQUN4RCw4RUFBc0Q7QUFFdEQsSUFBTSxhQUFhLEdBQUcsVUFBQyxRQUFzQixFQUFFLFFBQWE7SUFDMUQsSUFBTSxPQUFPLEdBQUcsSUFBQSwyQkFBZSxFQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFDLElBQUksbUJBQVEsQ0FBQyxhQUFhLElBQUksT0FBTyxLQUFLLG1CQUFRLENBQUMsYUFBYSxFQUFFO1FBQ2hFLE9BQU8sSUFBQSw2QkFBaUIsRUFBQyxPQUFPLEVBQUUsY0FBTSxPQUFBLElBQUksc0RBQWtCLENBQUMsUUFBUSxDQUFDLEVBQWhDLENBQWdDLENBQUMsQ0FBQztLQUMzRTtJQUNELElBQUksbUJBQVEsQ0FBQyxtQkFBbUIsSUFBSSxPQUFPLEtBQUssbUJBQVEsQ0FBQyxtQkFBbUIsRUFBRTtRQUM1RSxPQUFPLElBQUEsNkJBQWlCLEVBQUMsT0FBTyxFQUFFLGNBQU0sT0FBQSxJQUFJLDJEQUF1QixDQUFDLFFBQVEsQ0FBQyxFQUFyQyxDQUFxQyxDQUFDLENBQUM7S0FDaEY7SUFDRCxJQUFJLG1CQUFRLENBQUMsaUJBQWlCLElBQUksT0FBTyxLQUFLLG1CQUFRLENBQUMsaUJBQWlCLEVBQUU7UUFDeEUsT0FBTyxJQUFBLDZCQUFpQixFQUFDLE9BQU8sRUFBRSxjQUFNLE9BQUEsSUFBSSxpRUFBNkIsQ0FBQyxRQUFRLENBQUMsRUFBM0MsQ0FBMkMsQ0FBQyxDQUFDO0tBQ3RGO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyxDQUFDO0FBRUYsSUFBTSxxQkFBcUIsR0FBRyxVQUFDLFVBQXdCLEVBQUUsUUFBc0IsRUFBRSxRQUFhO0lBQzVGLElBQU0sT0FBTyxHQUFHLElBQUEsMkJBQWUsRUFBQyxRQUFRLENBQUMsQ0FBQztJQUUxQyxxQ0FBcUM7SUFDckMsSUFBSSxPQUFPLEtBQUssbUJBQVEsQ0FBQyxTQUFTLElBQUksT0FBTyxLQUFLLG1CQUFRLENBQUMsb0JBQW9CLEVBQUU7UUFDL0UsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxJQUFJLFFBQVEsS0FBSyxPQUFPLElBQUksUUFBUSxDQUFDLFdBQVcsS0FBSyxVQUFVLEVBQUU7UUFDL0QsT0FBTyxJQUFBLDhCQUFrQixFQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztLQUM5QztJQUNELElBQ0UsUUFBUSxLQUFLLE9BQU87UUFDcEIsUUFBUSxDQUFDLFdBQVc7UUFDcEIsUUFBUSxDQUFDLFdBQVcsQ0FBQyxlQUFlO1FBQ3BDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsS0FBSyxVQUFVLEVBQ3JDO1FBQ0EsT0FBTyxJQUFBLDhCQUFrQixFQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztLQUM5QztJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMsQ0FBQztBQUVGLElBQU0sZUFBZSxHQUFHLFVBQ3RCLFVBQXdCLEVBQ3hCLFFBQXNCLEVBQ3RCLFFBQWEsRUFDYixXQUEwQjtJQUUxQixJQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2hELElBQUksS0FBSyxFQUFFO1FBQ1QsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQU0sY0FBYyxHQUFHLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDN0UsSUFBSSxjQUFjLEVBQUU7UUFDbEIsT0FBTyxjQUFjLENBQUM7S0FDdkI7SUFFRCxPQUFPLDZCQUFpQixDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDbEUsQ0FBQyxDQUFDO0FBRUYsbUJBQWUsVUFDYixVQUF3QixFQUN4QixRQUFzQixFQUN0QixTQUFpQjs7SUFLakIsSUFBTSxNQUFNLEdBQWUsRUFBRSxDQUFDO0lBQzlCLElBQUksdUJBQTRDLENBQUM7SUFDakQsSUFBTSxXQUFXLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7UUFFOUIsS0FBdUIsSUFBQSxLQUFBLFNBQUEsSUFBQSxzQkFBTyxFQUFDLFNBQVMsSUFBSSwwQkFBMEIsQ0FBQyxFQUFFLENBQUMsQ0FBQSxnQkFBQSw0QkFBRTtZQUF2RSxJQUFNLFFBQVEsV0FBQTtZQUNqQixJQUFNLE9BQU8sR0FBRyxJQUFBLDJCQUFlLEVBQUMsUUFBUSxDQUFDLENBQUM7WUFDMUMsSUFBSSxPQUFPLEtBQUssbUJBQVEsQ0FBQyxpQkFBaUIsRUFBRTtnQkFDMUMsdUJBQXVCLEdBQUcsS0FBSyxDQUFDO2FBQ2pDO1lBQ0QsSUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQzFFLElBQUksSUFBSSxFQUFFO2dCQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbkI7U0FDRjs7Ozs7Ozs7O0lBRUQsT0FBTztRQUNMLFNBQVMsRUFBRSxNQUFNO1FBQ2pCLHVCQUF1Qix5QkFBQTtLQUN4QixDQUFDO0FBQ0osQ0FBQyxFQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IGNvcmVGb3JtIGZyb20gJy4uL2NvbW1vbi9jb3JlLmZvcm0nO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uL2NvbW1vbi9jb3JlLmhlbHBlcnMnO1xuaW1wb3J0IHsgQW55VHlwZSB9IGZyb20gJy4uL2NvbW1vbi9jb3JlLnR5cGVzJztcbmltcG9ydCBmdW5jR2V0UHJvdmlkZXIgZnJvbSAnLi4vY29tbW9uL2Z1bmMuZ2V0LXByb3ZpZGVyJztcbmltcG9ydCB7XG4gIE1vY2tBc3luY1ZhbGlkYXRvclByb3h5LFxuICBNb2NrQ29udHJvbFZhbHVlQWNjZXNzb3JQcm94eSxcbiAgTW9ja1ZhbGlkYXRvclByb3h5LFxufSBmcm9tICcuLi9jb21tb24vbW9jay1jb250cm9sLXZhbHVlLWFjY2Vzc29yLXByb3h5JztcbmltcG9ydCBoZWxwZXJNb2NrU2VydmljZSBmcm9tICcuLi9tb2NrLXNlcnZpY2UvaGVscGVyLm1vY2stc2VydmljZSc7XG5cbmltcG9ydCB0b0V4aXN0aW5nUHJvdmlkZXIgZnJvbSAnLi90by1leGlzdGluZy1wcm92aWRlcic7XG5pbXBvcnQgdG9GYWN0b3J5UHJvdmlkZXIgZnJvbSAnLi90by1mYWN0b3J5LXByb3ZpZGVyJztcblxuY29uc3QgcHJvY2Vzc1Rva2VucyA9IChtb2NrVHlwZTogQW55VHlwZTxhbnk+LCBwcm92aWRlcjogYW55KSA9PiB7XG4gIGNvbnN0IHByb3ZpZGUgPSBmdW5jR2V0UHJvdmlkZXIocHJvdmlkZXIpO1xuICBpZiAoY29yZUZvcm0uTkdfVkFMSURBVE9SUyAmJiBwcm92aWRlID09PSBjb3JlRm9ybS5OR19WQUxJREFUT1JTKSB7XG4gICAgcmV0dXJuIHRvRmFjdG9yeVByb3ZpZGVyKHByb3ZpZGUsICgpID0+IG5ldyBNb2NrVmFsaWRhdG9yUHJveHkobW9ja1R5cGUpKTtcbiAgfVxuICBpZiAoY29yZUZvcm0uTkdfQVNZTkNfVkFMSURBVE9SUyAmJiBwcm92aWRlID09PSBjb3JlRm9ybS5OR19BU1lOQ19WQUxJREFUT1JTKSB7XG4gICAgcmV0dXJuIHRvRmFjdG9yeVByb3ZpZGVyKHByb3ZpZGUsICgpID0+IG5ldyBNb2NrQXN5bmNWYWxpZGF0b3JQcm94eShtb2NrVHlwZSkpO1xuICB9XG4gIGlmIChjb3JlRm9ybS5OR19WQUxVRV9BQ0NFU1NPUiAmJiBwcm92aWRlID09PSBjb3JlRm9ybS5OR19WQUxVRV9BQ0NFU1NPUikge1xuICAgIHJldHVybiB0b0ZhY3RvcnlQcm92aWRlcihwcm92aWRlLCAoKSA9PiBuZXcgTW9ja0NvbnRyb2xWYWx1ZUFjY2Vzc29yUHJveHkobW9ja1R5cGUpKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBwcm9jZXNzT3duVXNlRXhpc3RpbmcgPSAoc291cmNlVHlwZTogQW55VHlwZTxhbnk+LCBtb2NrVHlwZTogQW55VHlwZTxhbnk+LCBwcm92aWRlcjogYW55KSA9PiB7XG4gIGNvbnN0IHByb3ZpZGUgPSBmdW5jR2V0UHJvdmlkZXIocHJvdmlkZXIpO1xuXG4gIC8vIENoZWNrIHRlc3RzL2lzc3VlLTMwMi90ZXN0LnNwZWMudHNcbiAgaWYgKHByb3ZpZGUgPT09IGNvcmVGb3JtLk5nQ29udHJvbCB8fCBwcm92aWRlID09PSBjb3JlRm9ybS5Gb3JtQ29udHJvbERpcmVjdGl2ZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocHJvdmlkZXIgIT09IHByb3ZpZGUgJiYgcHJvdmlkZXIudXNlRXhpc3RpbmcgPT09IHNvdXJjZVR5cGUpIHtcbiAgICByZXR1cm4gdG9FeGlzdGluZ1Byb3ZpZGVyKHByb3ZpZGUsIG1vY2tUeXBlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvdmlkZXIgIT09IHByb3ZpZGUgJiZcbiAgICBwcm92aWRlci51c2VFeGlzdGluZyAmJlxuICAgIHByb3ZpZGVyLnVzZUV4aXN0aW5nLl9fZm9yd2FyZF9yZWZfXyAmJlxuICAgIHByb3ZpZGVyLnVzZUV4aXN0aW5nKCkgPT09IHNvdXJjZVR5cGVcbiAgKSB7XG4gICAgcmV0dXJuIHRvRXhpc3RpbmdQcm92aWRlcihwcm92aWRlLCBtb2NrVHlwZSk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgcHJvY2Vzc1Byb3ZpZGVyID0gKFxuICBzb3VyY2VUeXBlOiBBbnlUeXBlPGFueT4sXG4gIG1vY2tUeXBlOiBBbnlUeXBlPGFueT4sXG4gIHByb3ZpZGVyOiBhbnksXG4gIHJlc29sdXRpb25zOiBNYXA8YW55LCBhbnk+LFxuKTogYW55ID0+IHtcbiAgY29uc3QgdG9rZW4gPSBwcm9jZXNzVG9rZW5zKG1vY2tUeXBlLCBwcm92aWRlcik7XG4gIGlmICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGNvbnN0IG93blVzZUV4aXN0aW5nID0gcHJvY2Vzc093blVzZUV4aXN0aW5nKHNvdXJjZVR5cGUsIG1vY2tUeXBlLCBwcm92aWRlcik7XG4gIGlmIChvd25Vc2VFeGlzdGluZykge1xuICAgIHJldHVybiBvd25Vc2VFeGlzdGluZztcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJNb2NrU2VydmljZS5yZXNvbHZlUHJvdmlkZXIocHJvdmlkZXIsIHJlc29sdXRpb25zKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChcbiAgc291cmNlVHlwZTogQW55VHlwZTxhbnk+LFxuICBtb2NrVHlwZTogQW55VHlwZTxhbnk+LFxuICBwcm92aWRlcnM/OiBhbnlbXSxcbik6IHtcbiAgcHJvdmlkZXJzOiBQcm92aWRlcltdO1xuICBzZXRDb250cm9sVmFsdWVBY2Nlc3Nvcj86IGJvb2xlYW47XG59ID0+IHtcbiAgY29uc3QgcmVzdWx0OiBQcm92aWRlcltdID0gW107XG4gIGxldCBzZXRDb250cm9sVmFsdWVBY2Nlc3NvcjogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBwcm92aWRlciBvZiBmbGF0dGVuKHByb3ZpZGVycyB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXSkpIHtcbiAgICBjb25zdCBwcm92aWRlID0gZnVuY0dldFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICBpZiAocHJvdmlkZSA9PT0gY29yZUZvcm0uTkdfVkFMVUVfQUNDRVNTT1IpIHtcbiAgICAgIHNldENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vY2sgPSBwcm9jZXNzUHJvdmlkZXIoc291cmNlVHlwZSwgbW9ja1R5cGUsIHByb3ZpZGVyLCByZXNvbHV0aW9ucyk7XG4gICAgaWYgKG1vY2spIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vY2spO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvdmlkZXJzOiByZXN1bHQsXG4gICAgc2V0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIH07XG59O1xuIl19