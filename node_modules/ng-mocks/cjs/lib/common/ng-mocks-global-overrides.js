"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var testing_1 = require("@angular/core/testing");
var func_extract_tokens_1 = __importDefault(require("../mock-builder/func.extract-tokens"));
var get_override_def_1 = __importDefault(require("../mock-builder/promise/get-override-def"));
var mock_helper_1 = require("../mock-helper/mock-helper");
var mock_helper_faster_install_1 = __importDefault(require("../mock-helper/mock-helper.faster-install"));
var mock_provider_1 = require("../mock-provider/mock-provider");
var core_define_property_1 = __importDefault(require("./core.define-property"));
var core_helpers_1 = require("./core.helpers");
var core_reflect_meta_1 = __importDefault(require("./core.reflect.meta"));
var core_reflect_module_resolve_1 = __importDefault(require("./core.reflect.module-resolve"));
var core_reflect_provided_in_1 = __importDefault(require("./core.reflect.provided-in"));
var core_tokens_1 = require("./core.tokens");
var func_get_provider_1 = __importDefault(require("./func.get-provider"));
var func_is_ng_def_1 = require("./func.is-ng-def");
var func_is_ng_module_def_with_providers_1 = require("./func.is-ng-module-def-with-providers");
var ng_mocks_universe_1 = __importDefault(require("./ng-mocks-universe"));
var applyOverride = function (def, override) {
    if ((0, func_is_ng_def_1.isNgDef)(def, 'c')) {
        testing_1.TestBed.overrideComponent(def, override);
    }
    else if ((0, func_is_ng_def_1.isNgDef)(def, 'd')) {
        testing_1.TestBed.overrideDirective(def, override);
    }
    else if ((0, func_is_ng_def_1.isNgDef)(def, 'm')) {
        testing_1.TestBed.overrideModule(def, override);
    }
    if ((0, func_is_ng_def_1.isNgDef)(def, 't')) {
        testing_1.TestBed.overrideProvider(def, override);
    }
    else if ((0, func_is_ng_def_1.isNgDef)(def, 'i')) {
        testing_1.TestBed.overrideProvider(def, override);
    }
};
var applyOverrides = function (overrides) {
    var e_1, _a;
    try {
        for (var _b = __values((0, core_helpers_1.mapEntries)(overrides)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), def = _d[0], _e = __read(_d[1], 2), override = _e[0], original = _e[1];
            testing_1.TestBed.ngMocksOverrides.set(def, original);
            applyOverride(def, override);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
// Thanks Ivy and its TestBed.override - it does not clean up leftovers.
var applyNgMocksOverrides = function (testBed) {
    var e_2, _a;
    if (testBed.ngMocksOverrides) {
        mock_helper_1.ngMocks.flushTestBed();
        try {
            for (var _b = __values((0, core_helpers_1.mapEntries)(testBed.ngMocksOverrides)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), def = _d[0], original = _d[1];
                applyOverride(def, original);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        testBed.ngMocksOverrides = undefined;
    }
};
var initTestBed = function () {
    if (!testing_1.TestBed.ngMocksSelectors) {
        (0, core_define_property_1.default)(testing_1.TestBed, 'ngMocksSelectors', new Map());
    }
    // istanbul ignore else
    if (!testing_1.TestBed.ngMocksOverrides) {
        (0, core_define_property_1.default)(testing_1.TestBed, 'ngMocksOverrides', new Map());
    }
};
var generateTouchesKey = [
    'bootstrap',
    'declarations',
    'entryComponents',
    'exports',
    'imports',
    'providers',
    'viewProviders',
];
var generateTouches = function (moduleDef, touches) {
    var e_3, _a, e_4, _b;
    try {
        for (var generateTouchesKey_1 = __values(generateTouchesKey), generateTouchesKey_1_1 = generateTouchesKey_1.next(); !generateTouchesKey_1_1.done; generateTouchesKey_1_1 = generateTouchesKey_1.next()) {
            var key = generateTouchesKey_1_1.value;
            try {
                for (var _c = (e_4 = void 0, __values(moduleDef[key] ? (0, core_helpers_1.flatten)(moduleDef[key]) : [])), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var item = _d.value;
                    var def = (0, func_get_provider_1.default)(item);
                    if ((0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(def)) {
                        generateTouches(def, touches);
                        def = def.ngModule;
                    }
                    touches.add(def);
                    var meta = (0, core_reflect_meta_1.default)(def);
                    if (meta) {
                        generateTouches(meta, touches);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (generateTouchesKey_1_1 && !generateTouchesKey_1_1.done && (_a = generateTouchesKey_1.return)) _a.call(generateTouchesKey_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
};
var defineTouches = function (testBed, moduleDef, knownTouches) {
    var _a;
    var touches = knownTouches;
    if (!touches && ng_mocks_universe_1.default.getDefaults().size) {
        touches = (0, func_extract_tokens_1.default)(testBed._providers || /* istanbul ignore next Ivy part */ ((_a = testBed._compiler) === null || _a === void 0 ? void 0 : _a.providers)).touches;
        if (!touches) {
            touches = new Set();
            moduleDef.providers = moduleDef.providers || [];
            moduleDef.providers.push({ provide: core_tokens_1.NG_MOCKS_TOUCHES, useValue: touches });
        }
        generateTouches(moduleDef, touches);
    }
    return touches;
};
var applyPlatformOverrideDef = function (def) {
    var ngModule = (0, func_is_ng_module_def_with_providers_1.isNgModuleDefWithProviders)(def) ? /* istanbul ignore next */ def.ngModule : def;
    if (testing_1.TestBed.ngMocksOverrides.has(ngModule)) {
        return;
    }
    var original = (0, core_reflect_module_resolve_1.default)(ngModule);
    var set = (0, get_override_def_1.default)(original);
    if (set) {
        testing_1.TestBed.ngMocksOverrides.set(ngModule, { set: original });
        testing_1.TestBed.overrideModule(ngModule, { set: set });
    }
};
var applyPlatformOverridesBasedOnProvidedIn = function (provide, touches) {
    var providedIn = (0, core_reflect_provided_in_1.default)(provide);
    if (!providedIn) {
        return;
    }
    // knownTouches present from MockBuilder and we can rely on it,
    // otherwise we have to override the provider always.
    if (typeof providedIn !== 'string' && !touches.has(providedIn)) {
        return;
    }
    testing_1.TestBed.ngMocksOverrides.set(provide, {});
    testing_1.TestBed.overrideProvider(provide, (0, mock_provider_1.MockProvider)(provide));
};
var applyPlatformOverridesBasedOnDefaults = function (touches) {
    var e_5, _a;
    try {
        for (var _b = __values((0, core_helpers_1.mapEntries)(ng_mocks_universe_1.default.getDefaults())), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), provide = _d[0], _e = __read(_d[1], 1), config = _e[0];
            if (config !== 'mock') {
                continue;
            }
            if (!(0, func_is_ng_def_1.isNgDef)(provide, 'i') && !(0, func_is_ng_def_1.isNgDef)(provide, 't')) {
                continue;
            }
            if (touches.has(provide)) {
                continue;
            }
            if (testing_1.TestBed.ngMocksOverrides.has(provide)) {
                continue;
            }
            applyPlatformOverridesBasedOnProvidedIn(provide, touches);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_5) throw e_5.error; }
    }
};
var applyPlatformOverrides = function (testBed, touches) {
    var e_6, _a;
    // istanbul ignore else
    if (testing_1.TestBed.ngMocksOverrides) {
        var backup = ng_mocks_universe_1.default.touches;
        ng_mocks_universe_1.default.touches = touches;
        try {
            for (var _b = __values((0, core_helpers_1.flatten)(testBed.ngModule || /* istanbul ignore next */ [])), _c = _b.next(); !_c.done; _c = _b.next()) {
                var def = _c.value;
                applyPlatformOverrideDef(def);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        applyPlatformOverridesBasedOnDefaults(touches);
        ng_mocks_universe_1.default.touches = backup;
    }
};
var configureTestingModule = function (original) {
    return function (moduleDef) {
        initTestBed();
        var testBed = (0, testing_1.getTestBed)();
        var providers = (0, func_extract_tokens_1.default)(moduleDef.providers);
        var mocks = providers.mocks, overrides = providers.overrides;
        // touches are important,
        // therefore we are trying to fetch them from the known providers.
        var touches = defineTouches(testBed, moduleDef, providers.touches);
        if (mocks) {
            mock_helper_1.ngMocks.flushTestBed();
        }
        // istanbul ignore else
        if (overrides) {
            applyOverrides(overrides);
        }
        // _testModuleRef exists only after the 1st call,
        // so we shouldn't override platform again.
        if (touches && !testBed._instantiated && !testBed._testModuleRef) {
            applyPlatformOverrides(testBed, touches);
        }
        return original.call(testing_1.TestBed, moduleDef);
    };
};
var resetTestingModule = function (original) {
    return function () {
        ng_mocks_universe_1.default.global.delete('builder:config');
        ng_mocks_universe_1.default.global.delete('builder:module');
        testing_1.TestBed.ngMocksSelectors = undefined;
        applyNgMocksOverrides(testing_1.TestBed);
        return original.call(testing_1.TestBed);
    };
};
var install = function () {
    var hooks = (0, mock_helper_faster_install_1.default)();
    // istanbul ignore else
    if (!testing_1.TestBed.ngMocksOverridesInstalled) {
        // istanbul ignore else
        if (hooks.before.indexOf(configureTestingModule) === -1) {
            hooks.before.push(configureTestingModule);
        }
        // istanbul ignore else
        if (hooks.after.indexOf(resetTestingModule) === -1) {
            hooks.after.push(resetTestingModule);
        }
        (0, core_define_property_1.default)(testing_1.TestBed, 'ngMocksOverridesInstalled', true, false);
    }
};
install();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctbW9ja3MtZ2xvYmFsLW92ZXJyaWRlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbmctbW9ja3Mvc3JjL2xpYi9jb21tb24vbmctbW9ja3MtZ2xvYmFsLW92ZXJyaWRlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLGlEQUFpSDtBQUVqSCw0RkFBb0U7QUFDcEUsOEZBQXNFO0FBQ3RFLDBEQUFxRDtBQUNyRCx5R0FBZ0Y7QUFDaEYsZ0VBQThEO0FBRTlELGdGQUF3RDtBQUN4RCwrQ0FBcUQ7QUFDckQsMEVBQWtEO0FBQ2xELDhGQUFxRTtBQUNyRSx3RkFBK0Q7QUFDL0QsNkNBQWlEO0FBRWpELDBFQUFrRDtBQUNsRCxtREFBMkM7QUFDM0MsK0ZBQW9GO0FBQ3BGLDBFQUFrRDtBQUVsRCxJQUFNLGFBQWEsR0FBRyxVQUFDLEdBQVEsRUFBRSxRQUFhO0lBQzVDLElBQUksSUFBQSx3QkFBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRTtRQUNyQixpQkFBTyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUMxQztTQUFNLElBQUksSUFBQSx3QkFBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRTtRQUM1QixpQkFBTyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUMxQztTQUFNLElBQUksSUFBQSx3QkFBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRTtRQUM1QixpQkFBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDdkM7SUFDRCxJQUFJLElBQUEsd0JBQU8sRUFBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUU7UUFDckIsaUJBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FD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S0FBSyxHQUFHLElBQUEsb0NBQXVCLEdBQUUsQ0FBQztJQUN4Qyx1QkFBdUI7SUFDdkIsSUFBSSxDQUFFLGlCQUFlLENBQUMseUJBQXlCLEVBQUU7UUFDL0MsdUJBQXVCO1FBQ3ZCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUN2RCxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1NBQzNDO1FBQ0QsdUJBQXVCO1FBQ3ZCLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUNsRCxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsSUFBQSw4QkFBa0IsRUFBQyxpQkFBTyxFQUFFLDJCQUEyQixFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztLQUN2RTtBQUNILENBQUMsQ0FBQztBQUVGLE9BQU8sRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBEaXJlY3RpdmUsIE5nTW9kdWxlLCBQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRUZXN0QmVkLCBNZXRhZGF0YU92ZXJyaWRlLCBUZXN0QmVkLCBUZXN0QmVkU3RhdGljLCBUZXN0TW9kdWxlTWV0YWRhdGEgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuXG5pbXBvcnQgZnVuY0V4dHJhY3RUb2tlbnMgZnJvbSAnLi4vbW9jay1idWlsZGVyL2Z1bmMuZXh0cmFjdC10b2tlbnMnO1xuaW1wb3J0IGdldE92ZXJyaWRlRGVmIGZyb20gJy4uL21vY2stYnVpbGRlci9wcm9taXNlL2dldC1vdmVycmlkZS1kZWYnO1xuaW1wb3J0IHsgbmdNb2NrcyB9IGZyb20gJy4uL21vY2staGVscGVyL21vY2staGVscGVyJztcbmltcG9ydCBtb2NrSGVscGVyRmFzdGVySW5zdGFsbCBmcm9tICcuLi9tb2NrLWhlbHBlci9tb2NrLWhlbHBlci5mYXN0ZXItaW5zdGFsbCc7XG5pbXBvcnQgeyBNb2NrUHJvdmlkZXIgfSBmcm9tICcuLi9tb2NrLXByb3ZpZGVyL21vY2stcHJvdmlkZXInO1xuXG5pbXBvcnQgY29yZURlZmluZVByb3BlcnR5IGZyb20gJy4vY29yZS5kZWZpbmUtcHJvcGVydHknO1xuaW1wb3J0IHsgZmxhdHRlbiwgbWFwRW50cmllcyB9IGZyb20gJy4vY29yZS5oZWxwZXJzJztcbmltcG9ydCBjb3JlUmVmbGVjdE1ldGEgZnJvbSAnLi9jb3JlLnJlZmxlY3QubWV0YSc7XG5pbXBvcnQgY29yZVJlZmxlY3RNb2R1bGVSZXNvbHZlIGZyb20gJy4vY29yZS5yZWZsZWN0Lm1vZHVsZS1yZXNvbHZlJztcbmltcG9ydCBjb3JlUmVmbGVjdFByb3ZpZGVkSW4gZnJvbSAnLi9jb3JlLnJlZmxlY3QucHJvdmlkZWQtaW4nO1xuaW1wb3J0IHsgTkdfTU9DS1NfVE9VQ0hFUyB9IGZyb20gJy4vY29yZS50b2tlbnMnO1xuaW1wb3J0IHsgQW55VHlwZSB9IGZyb20gJy4vY29yZS50eXBlcyc7XG5pbXBvcnQgZnVuY0dldFByb3ZpZGVyIGZyb20gJy4vZnVuYy5nZXQtcHJvdmlkZXInO1xuaW1wb3J0IHsgaXNOZ0RlZiB9IGZyb20gJy4vZnVuYy5pcy1uZy1kZWYnO1xuaW1wb3J0IHsgaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMgfSBmcm9tICcuL2Z1bmMuaXMtbmctbW9kdWxlLWRlZi13aXRoLXByb3ZpZGVycyc7XG5pbXBvcnQgbmdNb2Nrc1VuaXZlcnNlIGZyb20gJy4vbmctbW9ja3MtdW5pdmVyc2UnO1xuXG5jb25zdCBhcHBseU92ZXJyaWRlID0gKGRlZjogYW55LCBvdmVycmlkZTogYW55KSA9PiB7XG4gIGlmIChpc05nRGVmKGRlZiwgJ2MnKSkge1xuICAgIFRlc3RCZWQub3ZlcnJpZGVDb21wb25lbnQoZGVmLCBvdmVycmlkZSk7XG4gIH0gZWxzZSBpZiAoaXNOZ0RlZihkZWYsICdkJykpIHtcbiAgICBUZXN0QmVkLm92ZXJyaWRlRGlyZWN0aXZlKGRlZiwgb3ZlcnJpZGUpO1xuICB9IGVsc2UgaWYgKGlzTmdEZWYoZGVmLCAnbScpKSB7XG4gICAgVGVzdEJlZC5vdmVycmlkZU1vZHVsZShkZWYsIG92ZXJyaWRlKTtcbiAgfVxuICBpZiAoaXNOZ0RlZihkZWYsICd0JykpIHtcbiAgICBUZXN0QmVkLm92ZXJyaWRlUHJvdmlkZXIoZGVmLCBvdmVycmlkZSk7XG4gIH0gZWxzZSBpZiAoaXNOZ0RlZihkZWYsICdpJykpIHtcbiAgICBUZXN0QmVkLm92ZXJyaWRlUHJvdmlkZXIoZGVmLCBvdmVycmlkZSk7XG4gIH1cbn07XG5cbmNvbnN0IGFwcGx5T3ZlcnJpZGVzID0gKG92ZXJyaWRlczogTWFwPEFueVR5cGU8YW55PiwgW01ldGFkYXRhT3ZlcnJpZGU8YW55PiwgTWV0YWRhdGFPdmVycmlkZTxhbnk+XT4pOiB2b2lkID0+IHtcbiAgZm9yIChjb25zdCBbZGVmLCBbb3ZlcnJpZGUsIG9yaWdpbmFsXV0gb2YgbWFwRW50cmllcyhvdmVycmlkZXMpKSB7XG4gICAgKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzLnNldChkZWYsIG9yaWdpbmFsKTtcbiAgICBhcHBseU92ZXJyaWRlKGRlZiwgb3ZlcnJpZGUpO1xuICB9XG59O1xuXG4vLyBUaGFua3MgSXZ5IGFuZCBpdHMgVGVzdEJlZC5vdmVycmlkZSAtIGl0IGRvZXMgbm90IGNsZWFuIHVwIGxlZnRvdmVycy5cbmNvbnN0IGFwcGx5TmdNb2Nrc092ZXJyaWRlcyA9ICh0ZXN0QmVkOiBUZXN0QmVkU3RhdGljICYgeyBuZ01vY2tzT3ZlcnJpZGVzPzogTWFwPGFueSwgYW55PiB9KTogdm9pZCA9PiB7XG4gIGlmICh0ZXN0QmVkLm5nTW9ja3NPdmVycmlkZXMpIHtcbiAgICBuZ01vY2tzLmZsdXNoVGVzdEJlZCgpO1xuICAgIGZvciAoY29uc3QgW2RlZiwgb3JpZ2luYWxdIG9mIG1hcEVudHJpZXModGVzdEJlZC5uZ01vY2tzT3ZlcnJpZGVzKSkge1xuICAgICAgYXBwbHlPdmVycmlkZShkZWYsIG9yaWdpbmFsKTtcbiAgICB9XG4gICAgdGVzdEJlZC5uZ01vY2tzT3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5jb25zdCBpbml0VGVzdEJlZCA9ICgpID0+IHtcbiAgaWYgKCEoVGVzdEJlZCBhcyBhbnkpLm5nTW9ja3NTZWxlY3RvcnMpIHtcbiAgICBjb3JlRGVmaW5lUHJvcGVydHkoVGVzdEJlZCwgJ25nTW9ja3NTZWxlY3RvcnMnLCBuZXcgTWFwKCkpO1xuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gIGlmICghKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzKSB7XG4gICAgY29yZURlZmluZVByb3BlcnR5KFRlc3RCZWQsICduZ01vY2tzT3ZlcnJpZGVzJywgbmV3IE1hcCgpKTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVUb3VjaGVzS2V5ID0gW1xuICAnYm9vdHN0cmFwJyxcbiAgJ2RlY2xhcmF0aW9ucycsXG4gICdlbnRyeUNvbXBvbmVudHMnLFxuICAnZXhwb3J0cycsXG4gICdpbXBvcnRzJyxcbiAgJ3Byb3ZpZGVycycsXG4gICd2aWV3UHJvdmlkZXJzJyxcbl0gYXMgY29uc3Q7XG5cbmNvbnN0IGdlbmVyYXRlVG91Y2hlcyA9IChcbiAgbW9kdWxlRGVmOiBQYXJ0aWFsPFRlc3RNb2R1bGVNZXRhZGF0YSAmIE5nTW9kdWxlICYgRGlyZWN0aXZlICYgUGlwZSAmIENvbXBvbmVudD4sXG4gIHRvdWNoZXM6IFNldDxhbnk+LFxuKTogdm9pZCA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGdlbmVyYXRlVG91Y2hlc0tleSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBtb2R1bGVEZWZba2V5XSA/IGZsYXR0ZW4obW9kdWxlRGVmW2tleV0pIDogW10pIHtcbiAgICAgIGxldCBkZWYgPSBmdW5jR2V0UHJvdmlkZXIoaXRlbSk7XG4gICAgICBpZiAoaXNOZ01vZHVsZURlZldpdGhQcm92aWRlcnMoZGVmKSkge1xuICAgICAgICBnZW5lcmF0ZVRvdWNoZXMoZGVmLCB0b3VjaGVzKTtcbiAgICAgICAgZGVmID0gZGVmLm5nTW9kdWxlO1xuICAgICAgfVxuICAgICAgdG91Y2hlcy5hZGQoZGVmKTtcbiAgICAgIGNvbnN0IG1ldGEgPSBjb3JlUmVmbGVjdE1ldGEoZGVmKTtcbiAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgIGdlbmVyYXRlVG91Y2hlcyhtZXRhLCB0b3VjaGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGRlZmluZVRvdWNoZXMgPSAodGVzdEJlZDogVGVzdEJlZCwgbW9kdWxlRGVmOiBUZXN0TW9kdWxlTWV0YWRhdGEsIGtub3duVG91Y2hlcz86IFNldDxhbnk+KSA9PiB7XG4gIGxldCB0b3VjaGVzID0ga25vd25Ub3VjaGVzO1xuXG4gIGlmICghdG91Y2hlcyAmJiBuZ01vY2tzVW5pdmVyc2UuZ2V0RGVmYXVsdHMoKS5zaXplKSB7XG4gICAgdG91Y2hlcyA9IGZ1bmNFeHRyYWN0VG9rZW5zKFxuICAgICAgKHRlc3RCZWQgYXMgYW55KS5fcHJvdmlkZXJzIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IEl2eSBwYXJ0ICovICh0ZXN0QmVkIGFzIGFueSkuX2NvbXBpbGVyPy5wcm92aWRlcnMsXG4gICAgKS50b3VjaGVzO1xuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgdG91Y2hlcyA9IG5ldyBTZXQoKTtcbiAgICAgIG1vZHVsZURlZi5wcm92aWRlcnMgPSBtb2R1bGVEZWYucHJvdmlkZXJzIHx8IFtdO1xuICAgICAgbW9kdWxlRGVmLnByb3ZpZGVycy5wdXNoKHsgcHJvdmlkZTogTkdfTU9DS1NfVE9VQ0hFUywgdXNlVmFsdWU6IHRvdWNoZXMgfSk7XG4gICAgfVxuICAgIGdlbmVyYXRlVG91Y2hlcyhtb2R1bGVEZWYsIHRvdWNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIHRvdWNoZXM7XG59O1xuXG5jb25zdCBhcHBseVBsYXRmb3JtT3ZlcnJpZGVEZWYgPSAoZGVmOiBhbnkpID0+IHtcbiAgY29uc3QgbmdNb2R1bGUgPSBpc05nTW9kdWxlRGVmV2l0aFByb3ZpZGVycyhkZWYpID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZGVmLm5nTW9kdWxlIDogZGVmO1xuICBpZiAoKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzLmhhcyhuZ01vZHVsZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmlnaW5hbCA9IGNvcmVSZWZsZWN0TW9kdWxlUmVzb2x2ZShuZ01vZHVsZSk7XG4gIGNvbnN0IHNldCA9IGdldE92ZXJyaWRlRGVmKG9yaWdpbmFsKTtcbiAgaWYgKHNldCkge1xuICAgIChUZXN0QmVkIGFzIGFueSkubmdNb2Nrc092ZXJyaWRlcy5zZXQobmdNb2R1bGUsIHsgc2V0OiBvcmlnaW5hbCB9KTtcbiAgICBUZXN0QmVkLm92ZXJyaWRlTW9kdWxlKG5nTW9kdWxlLCB7IHNldCB9KTtcbiAgfVxufTtcblxuY29uc3QgYXBwbHlQbGF0Zm9ybU92ZXJyaWRlc0Jhc2VkT25Qcm92aWRlZEluID0gKHByb3ZpZGU6IGFueSwgdG91Y2hlczogU2V0PGFueT4pID0+IHtcbiAgY29uc3QgcHJvdmlkZWRJbiA9IGNvcmVSZWZsZWN0UHJvdmlkZWRJbihwcm92aWRlKTtcbiAgaWYgKCFwcm92aWRlZEluKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGtub3duVG91Y2hlcyBwcmVzZW50IGZyb20gTW9ja0J1aWxkZXIgYW5kIHdlIGNhbiByZWx5IG9uIGl0LFxuICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byBvdmVycmlkZSB0aGUgcHJvdmlkZXIgYWx3YXlzLlxuICBpZiAodHlwZW9mIHByb3ZpZGVkSW4gIT09ICdzdHJpbmcnICYmICF0b3VjaGVzLmhhcyhwcm92aWRlZEluKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAoVGVzdEJlZCBhcyBhbnkpLm5nTW9ja3NPdmVycmlkZXMuc2V0KHByb3ZpZGUsIHt9KTtcbiAgVGVzdEJlZC5vdmVycmlkZVByb3ZpZGVyKHByb3ZpZGUsIE1vY2tQcm92aWRlcihwcm92aWRlIGFzIG5ldmVyKSk7XG59O1xuXG5jb25zdCBhcHBseVBsYXRmb3JtT3ZlcnJpZGVzQmFzZWRPbkRlZmF1bHRzID0gKHRvdWNoZXM6IFNldDxhbnk+KSA9PiB7XG4gIGZvciAoY29uc3QgW3Byb3ZpZGUsIFtjb25maWddXSBvZiBtYXBFbnRyaWVzKG5nTW9ja3NVbml2ZXJzZS5nZXREZWZhdWx0cygpKSkge1xuICAgIGlmIChjb25maWcgIT09ICdtb2NrJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNOZ0RlZihwcm92aWRlLCAnaScpICYmICFpc05nRGVmKHByb3ZpZGUsICd0JykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG91Y2hlcy5oYXMocHJvdmlkZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzLmhhcyhwcm92aWRlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFwcGx5UGxhdGZvcm1PdmVycmlkZXNCYXNlZE9uUHJvdmlkZWRJbihwcm92aWRlLCB0b3VjaGVzKTtcbiAgfVxufTtcblxuY29uc3QgYXBwbHlQbGF0Zm9ybU92ZXJyaWRlcyA9ICh0ZXN0QmVkOiBUZXN0QmVkLCB0b3VjaGVzOiBTZXQ8YW55PikgPT4ge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICBpZiAoKFRlc3RCZWQgYXMgYW55KS5uZ01vY2tzT3ZlcnJpZGVzKSB7XG4gICAgY29uc3QgYmFja3VwID0gbmdNb2Nrc1VuaXZlcnNlLnRvdWNoZXM7XG4gICAgbmdNb2Nrc1VuaXZlcnNlLnRvdWNoZXMgPSB0b3VjaGVzO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGZsYXR0ZW4odGVzdEJlZC5uZ01vZHVsZSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXSkpIHtcbiAgICAgIGFwcGx5UGxhdGZvcm1PdmVycmlkZURlZihkZWYpO1xuICAgIH1cbiAgICBhcHBseVBsYXRmb3JtT3ZlcnJpZGVzQmFzZWRPbkRlZmF1bHRzKHRvdWNoZXMpO1xuICAgIG5nTW9ja3NVbml2ZXJzZS50b3VjaGVzID0gYmFja3VwO1xuICB9XG59O1xuXG5jb25zdCBjb25maWd1cmVUZXN0aW5nTW9kdWxlID1cbiAgKG9yaWdpbmFsOiBUZXN0QmVkU3RhdGljWydjb25maWd1cmVUZXN0aW5nTW9kdWxlJ10pOiBUZXN0QmVkU3RhdGljWydjb25maWd1cmVUZXN0aW5nTW9kdWxlJ10gPT5cbiAgKG1vZHVsZURlZjogVGVzdE1vZHVsZU1ldGFkYXRhKSA9PiB7XG4gICAgaW5pdFRlc3RCZWQoKTtcblxuICAgIGNvbnN0IHRlc3RCZWQgPSBnZXRUZXN0QmVkKCk7XG5cbiAgICBjb25zdCBwcm92aWRlcnMgPSBmdW5jRXh0cmFjdFRva2Vucyhtb2R1bGVEZWYucHJvdmlkZXJzKTtcbiAgICBjb25zdCB7IG1vY2tzLCBvdmVycmlkZXMgfSA9IHByb3ZpZGVycztcbiAgICAvLyB0b3VjaGVzIGFyZSBpbXBvcnRhbnQsXG4gICAgLy8gdGhlcmVmb3JlIHdlIGFyZSB0cnlpbmcgdG8gZmV0Y2ggdGhlbSBmcm9tIHRoZSBrbm93biBwcm92aWRlcnMuXG4gICAgY29uc3QgdG91Y2hlcyA9IGRlZmluZVRvdWNoZXModGVzdEJlZCwgbW9kdWxlRGVmLCBwcm92aWRlcnMudG91Y2hlcyk7XG5cbiAgICBpZiAobW9ja3MpIHtcbiAgICAgIG5nTW9ja3MuZmx1c2hUZXN0QmVkKCk7XG4gICAgfVxuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICBhcHBseU92ZXJyaWRlcyhvdmVycmlkZXMpO1xuICAgIH1cbiAgICAvLyBfdGVzdE1vZHVsZVJlZiBleGlzdHMgb25seSBhZnRlciB0aGUgMXN0IGNhbGwsXG4gICAgLy8gc28gd2Ugc2hvdWxkbid0IG92ZXJyaWRlIHBsYXRmb3JtIGFnYWluLlxuICAgIGlmICh0b3VjaGVzICYmICEodGVzdEJlZCBhcyBhbnkpLl9pbnN0YW50aWF0ZWQgJiYgISh0ZXN0QmVkIGFzIGFueSkuX3Rlc3RNb2R1bGVSZWYpIHtcbiAgICAgIGFwcGx5UGxhdGZvcm1PdmVycmlkZXModGVzdEJlZCwgdG91Y2hlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwoVGVzdEJlZCwgbW9kdWxlRGVmKTtcbiAgfTtcblxuY29uc3QgcmVzZXRUZXN0aW5nTW9kdWxlID1cbiAgKG9yaWdpbmFsOiBUZXN0QmVkU3RhdGljWydyZXNldFRlc3RpbmdNb2R1bGUnXSk6IFRlc3RCZWRTdGF0aWNbJ3Jlc2V0VGVzdGluZ01vZHVsZSddID0+XG4gICgpID0+IHtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZ2xvYmFsLmRlbGV0ZSgnYnVpbGRlcjpjb25maWcnKTtcbiAgICBuZ01vY2tzVW5pdmVyc2UuZ2xvYmFsLmRlbGV0ZSgnYnVpbGRlcjptb2R1bGUnKTtcbiAgICAoVGVzdEJlZCBhcyBhbnkpLm5nTW9ja3NTZWxlY3RvcnMgPSB1bmRlZmluZWQ7XG4gICAgYXBwbHlOZ01vY2tzT3ZlcnJpZGVzKFRlc3RCZWQpO1xuXG4gICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwoVGVzdEJlZCk7XG4gIH07XG5cbmNvbnN0IGluc3RhbGwgPSAoKSA9PiB7XG4gIGNvbnN0IGhvb2tzID0gbW9ja0hlbHBlckZhc3Rlckluc3RhbGwoKTtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgaWYgKCEoVGVzdEJlZCBhcyBhbnkpLm5nTW9ja3NPdmVycmlkZXNJbnN0YWxsZWQpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICAgIGlmIChob29rcy5iZWZvcmUuaW5kZXhPZihjb25maWd1cmVUZXN0aW5nTW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIGhvb2tzLmJlZm9yZS5wdXNoKGNvbmZpZ3VyZVRlc3RpbmdNb2R1bGUpO1xuICAgIH1cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICAgIGlmIChob29rcy5hZnRlci5pbmRleE9mKHJlc2V0VGVzdGluZ01vZHVsZSkgPT09IC0xKSB7XG4gICAgICBob29rcy5hZnRlci5wdXNoKHJlc2V0VGVzdGluZ01vZHVsZSk7XG4gICAgfVxuICAgIGNvcmVEZWZpbmVQcm9wZXJ0eShUZXN0QmVkLCAnbmdNb2Nrc092ZXJyaWRlc0luc3RhbGxlZCcsIHRydWUsIGZhbHNlKTtcbiAgfVxufTtcblxuaW5zdGFsbCgpO1xuIl19