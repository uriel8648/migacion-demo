import { Inject, Injectable } from '@angular/core';
import { ScannedActionsSubject, } from '@ngrx/store';
import { Observable } from 'rxjs';
import { filter } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'rxjs';
export class Actions extends Observable {
    constructor(source) {
        super();
        if (source) {
            this.source = source;
        }
    }
    lift(operator) {
        const observable = new Actions();
        observable.source = this;
        observable.operator = operator;
        return observable;
    }
}
Actions.ɵfac = function Actions_Factory(t) { return new (t || Actions)(ɵngcc0.ɵɵinject(ScannedActionsSubject)); };
Actions.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: Actions, factory: Actions.ɵfac });
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
Actions.ctorParameters = () => [
    { type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Actions, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Observable, decorators: [{
                type: Inject,
                args: [ScannedActionsSubject]
            }] }]; }, null); })();
/**
 * `ofType` filters an Observable of `Actions` into an Observable of the actions
 * whose type strings are passed to it.
 *
 * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and
 * the type of the `Addition` action is `add`, then
 * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.
 *
 * Properly typing this function is hard and requires some advanced TS tricks
 * below.
 *
 * Type narrowing automatically works, as long as your `actions` object
 * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.
 *
 * For backwards compatibility, when one passes a single type argument
 * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`
 * completely overrides any possible inference from 'something'.
 *
 * Unfortunately, for unknown 'actions: Actions' these types will produce
 * 'Observable<never>'. In such cases one has to manually set the generic type
 * like `actions.ofType<AdditionAction>('add')`.
 *
 * @usageNotes
 *
 * Filter the Actions stream on the "customers page loaded" action
 *
 * ```ts
 * import { ofType } from '@ngrx/effects';
 * import * fromCustomers from '../customers';
 *
 * this.actions$.pipe(
 *  ofType(fromCustomers.pageLoaded)
 * )
 * ```
 */
export function ofType(...allowedTypes) {
    return filter((action) => allowedTypes.some((typeOrActionCreator) => {
        if (typeof typeOrActionCreator === 'string') {
            // Comparing the string to type
            return typeOrActionCreator === action.type;
        }
        // We are filtering by ActionCreator
        return typeOrActionCreator.type === action.type;
    }));
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9lZmZlY3RzL3NyYy9hY3Rpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFJTCxxQkFBcUIsR0FDdEIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLFVBQVUsRUFBOEIsTUFBTSxNQUFNLENBQUM7QUFDOUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFHeEMsTUFBTSxPQUFPLE9BQW9CLFNBQVEsVUFBYTtBQUN0RCxJQUFFLFlBQTJDLE1BQXNCO0FBQ25FLFFBQUksS0FBSyxFQUFFLENBQUM7QUFDWixRQUNJLElBQUksTUFBTSxFQUFFO0FBQ2hCLFlBQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDM0IsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ1csSUFBSSxDQUFJLFFBQXdCO0FBQUksUUFDM0MsTUFBTSxVQUFVLEdBQUcsSUFBSSxPQUFPLEVBQUssQ0FBQztBQUN4QyxRQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQzdCLFFBQUksVUFBVSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDbkMsUUFBSSxPQUFPLFVBQVUsQ0FBQztBQUN0QixJQUFFLENBQUM7QUFDSDt5R0FoQkM7QUFBVSxtR0FDVDtBQUFDO0FBQUk7QUFBcUM7QUFDM0M7QUFHQTtBQUFRO0FBQ0g7QUFBSTtBQUlOLFlBYkssVUFBVSx1QkFLSixNQUFNLFNBQUMscUJBQXFCO0FBQVE7Ozs7OztrQ0FBRTtBQXFGckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FDcEIsR0FBRyxZQUE0RDtBQUM5RCxJQUNELE9BQU8sTUFBTSxDQUFDLENBQUMsTUFBYyxFQUFFLEVBQUUsQ0FDL0IsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLG1CQUFtQixFQUFFLEVBQUU7QUFDOUMsUUFBTSxJQUFJLE9BQU8sbUJBQW1CLEtBQUssUUFBUSxFQUFFO0FBQ25ELFlBQVEsK0JBQStCO0FBQ3ZDLFlBQVEsT0FBTyxtQkFBbUIsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ25ELFNBQU87QUFDUCxRQUNNLG9DQUFvQztBQUMxQyxRQUFNLE9BQU8sbUJBQW1CLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDdEQsSUFBSSxDQUFDLENBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQztBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBBY3Rpb24sXG4gIEFjdGlvbkNyZWF0b3IsXG4gIENyZWF0b3IsXG4gIFNjYW5uZWRBY3Rpb25zU3ViamVjdCxcbn0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT3BlcmF0b3JGdW5jdGlvbiwgT3BlcmF0b3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFjdGlvbnM8ViA9IEFjdGlvbj4gZXh0ZW5kcyBPYnNlcnZhYmxlPFY+IHtcbiAgY29uc3RydWN0b3IoQEluamVjdChTY2FubmVkQWN0aW9uc1N1YmplY3QpIHNvdXJjZT86IE9ic2VydmFibGU8Vj4pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICB9XG5cbiAgb3ZlcnJpZGUgbGlmdDxSPihvcGVyYXRvcjogT3BlcmF0b3I8ViwgUj4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgICBjb25zdCBvYnNlcnZhYmxlID0gbmV3IEFjdGlvbnM8Uj4oKTtcbiAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICB9XG59XG5cbi8vIE1vZHVsZS1wcml2YXRlIGhlbHBlciB0eXBlXG50eXBlIEFjdGlvbkV4dHJhY3RvcjxcbiAgVCBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgRVxuPiA9IFQgZXh0ZW5kcyBzdHJpbmcgPyBFIDogUmV0dXJuVHlwZTxFeHRyYWN0PFQsIEFDPj47XG5cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8XG4gIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+W10sXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBSZXR1cm5UeXBlPEFDW251bWJlcl0+XG4+KC4uLmFsbG93ZWRUeXBlczogQUMpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuXG5leHBvcnQgZnVuY3Rpb24gb2ZUeXBlPFxuICBFIGV4dGVuZHMgRXh0cmFjdDxVLCB7IHR5cGU6IFQxIH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IFQxIGV4dGVuZHMgc3RyaW5nID8gRSA6IFJldHVyblR5cGU8RXh0cmFjdDxUMSwgQUM+PlxuPih0MTogVDEpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyLCBBQywgRT5cbj4odDE6IFQxLCB0MjogVDIpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIHwgVDMgfT4sXG4gIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LFxuICBUMSBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUMiBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUMyBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLFxuICBWID0gQWN0aW9uRXh0cmFjdG9yPFQxIHwgVDIgfCBUMywgQUMsIEU+XG4+KHQxOiBUMSwgdDI6IFQyLCB0MzogVDMpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIHwgVDMgfCBUNCB9PixcbiAgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sXG4gIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQyIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQzIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQ0IGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBBY3Rpb25FeHRyYWN0b3I8VDEgfCBUMiB8IFQzIHwgVDQsIEFDLCBFPlxuPih0MTogVDEsIHQyOiBUMiwgdDM6IFQzLCB0NDogVDQpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1IH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDMgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDQgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDUgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1LCBBQywgRT5cbj4odDE6IFQxLCB0MjogVDIsIHQzOiBUMywgdDQ6IFQ0LCB0NTogVDUpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuLyoqXG4gKiBGYWxsYmFjayBmb3IgbW9yZSB0aGFuIDUgYXJndW1lbnRzLlxuICogVGhlcmUgaXMgbm8gaW5mZXJlbmNlLCBzbyB0aGUgcmV0dXJuIHR5cGUgaXMgdGhlIHNhbWUgYXMgdGhlIGlucHV0IC1cbiAqIE9ic2VydmFibGU8QWN0aW9uPi5cbiAqXG4gKiBXZSBwcm92aWRlIGEgdHlwZSBwYXJhbWV0ZXIsIGV2ZW4gdGhvdWdoIFRTIHdpbGwgbm90IGluZmVyIGl0IGZyb20gdGhlXG4gKiBhcmd1bWVudHMsIHRvIHByZXNlcnZlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIHZlcnNpb25zIG9mIG5ncnguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8ViBleHRlbmRzIEFjdGlvbj4oXG4gIC4uLmFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nIHwgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+PlxuKTogT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIFY+O1xuLyoqXG4gKiBgb2ZUeXBlYCBmaWx0ZXJzIGFuIE9ic2VydmFibGUgb2YgYEFjdGlvbnNgIGludG8gYW4gT2JzZXJ2YWJsZSBvZiB0aGUgYWN0aW9uc1xuICogd2hvc2UgdHlwZSBzdHJpbmdzIGFyZSBwYXNzZWQgdG8gaXQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBhY3Rpb25zYCBoYXMgdHlwZSBgQWN0aW9uczxBZGRpdGlvbkFjdGlvbnxTdWJzdHJhY3Rpb25BY3Rpb24+YCwgYW5kXG4gKiB0aGUgdHlwZSBvZiB0aGUgYEFkZGl0aW9uYCBhY3Rpb24gaXMgYGFkZGAsIHRoZW5cbiAqIGBhY3Rpb25zLnBpcGUob2ZUeXBlKCdhZGQnKSlgIHJldHVybnMgYW4gYE9ic2VydmFibGU8QWRkaXRpb25BY3Rpb24+YC5cbiAqXG4gKiBQcm9wZXJseSB0eXBpbmcgdGhpcyBmdW5jdGlvbiBpcyBoYXJkIGFuZCByZXF1aXJlcyBzb21lIGFkdmFuY2VkIFRTIHRyaWNrc1xuICogYmVsb3cuXG4gKlxuICogVHlwZSBuYXJyb3dpbmcgYXV0b21hdGljYWxseSB3b3JrcywgYXMgbG9uZyBhcyB5b3VyIGBhY3Rpb25zYCBvYmplY3RcbiAqIHN0YXJ0cyB3aXRoIGEgYEFjdGlvbnM8U29tZVVuaW9uT2ZBY3Rpb25zPmAgaW5zdGVhZCBvZiBnZW5lcmljIGBBY3Rpb25zYC5cbiAqXG4gKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdoZW4gb25lIHBhc3NlcyBhIHNpbmdsZSB0eXBlIGFyZ3VtZW50XG4gKiBgb2ZUeXBlPFQ+KCdzb21ldGhpbmcnKWAgdGhlIHJlc3VsdCBpcyBhbiBgT2JzZXJ2YWJsZTxUPmAuIE5vdGUsIHRoYXQgYFRgXG4gKiBjb21wbGV0ZWx5IG92ZXJyaWRlcyBhbnkgcG9zc2libGUgaW5mZXJlbmNlIGZyb20gJ3NvbWV0aGluZycuXG4gKlxuICogVW5mb3J0dW5hdGVseSwgZm9yIHVua25vd24gJ2FjdGlvbnM6IEFjdGlvbnMnIHRoZXNlIHR5cGVzIHdpbGwgcHJvZHVjZVxuICogJ09ic2VydmFibGU8bmV2ZXI+Jy4gSW4gc3VjaCBjYXNlcyBvbmUgaGFzIHRvIG1hbnVhbGx5IHNldCB0aGUgZ2VuZXJpYyB0eXBlXG4gKiBsaWtlIGBhY3Rpb25zLm9mVHlwZTxBZGRpdGlvbkFjdGlvbj4oJ2FkZCcpYC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIEZpbHRlciB0aGUgQWN0aW9ucyBzdHJlYW0gb24gdGhlIFwiY3VzdG9tZXJzIHBhZ2UgbG9hZGVkXCIgYWN0aW9uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuICogaW1wb3J0ICogZnJvbUN1c3RvbWVycyBmcm9tICcuLi9jdXN0b21lcnMnO1xuICpcbiAqIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICBvZlR5cGUoZnJvbUN1c3RvbWVycy5wYWdlTG9hZGVkKVxuICogKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGUoXG4gIC4uLmFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nIHwgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+PlxuKTogT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIEFjdGlvbj4ge1xuICByZXR1cm4gZmlsdGVyKChhY3Rpb246IEFjdGlvbikgPT5cbiAgICBhbGxvd2VkVHlwZXMuc29tZSgodHlwZU9yQWN0aW9uQ3JlYXRvcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBDb21wYXJpbmcgdGhlIHN0cmluZyB0byB0eXBlXG4gICAgICAgIHJldHVybiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBhY3Rpb24udHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXJlIGZpbHRlcmluZyBieSBBY3Rpb25DcmVhdG9yXG4gICAgICByZXR1cm4gdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlID09PSBhY3Rpb24udHlwZTtcbiAgICB9KVxuICApO1xufVxuIl19